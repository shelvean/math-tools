<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5B8PRB2WZT"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag("js", new Date());
    gtag("config", "G-5B8PRB2WZT");
  </script>
  <title>Geometry of Linear Systems in 2D</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" crossorigin="anonymous"></script>
  <style>
    #canvas-labels {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
      width: 800px;
      height: 600px;
      z-index: 2;
    }
    .vector-label {
      position: absolute;
      font-size: 18px;
      background: rgba(255,255,255,0.8);
      padding: 2px 6px;
      border-radius: 5px;
      transform: translate(-50%, -50%);
      white-space: nowrap;
      pointer-events: none;
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 font-sans antialiased">
  <nav class="fixed top-0 left-0 w-full z-10 bg-white shadow-md">
    <div class="max-w-4xl mx-auto px-4 py-2">
      <ul class="flex justify-center space-x-4">
        <li><a href="index.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Home</a></li>
        <li><a href="teaching.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Teaching</a></li>
        <li><a href="projects.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Diff Eq</a></li>
        <li><a href="linear.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Linear Algebra</a></li>
		<li><a href="numerical.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Numerical Methods</a></li>

      </ul>
    </div>
  </nav>
  <h1 class="text-4xl text-center text-blue-600 font-bold mt-16 mb-6">Geometry of Linear Systems in 2D</h1>
  <div class="relative w-[800px] h-[600px] mx-auto">
    <canvas id="vectorCanvas" width="800" height="600" class="border border-gray-300 bg-white shadow-md"></canvas>
    <div id="canvas-labels"></div>
    <div class="absolute top-0 right-[-160px] w-40 bg-white p-3 border border-gray-200 rounded-lg shadow-sm">
      <h3 class="text-lg font-semibold text-gray-600 mb-2">Scale</h3>
      <button id="zoomIn" class="w-full bg-blue-600 text-white py-1 rounded hover:bg-blue-700 transition-colors mb-2">Zoom In</button>
      <button id="zoomOut" class="w-full bg-blue-600 text-white py-1 rounded hover:bg-blue-700 transition-colors mb-2">Zoom Out</button>
      <button id="resetView" class="w-full bg-gray-600 text-white py-1 rounded hover:bg-gray-700 transition-colors">Reset View</button>
    </div>
  </div>
  <div id="solution-info" class="text-center mt-5 text-xl"></div>
  <div class="flex flex-wrap justify-center gap-4 max-w-5xl mx-auto mt-5 px-4">
    <div class="w-full md:w-[30%] min-w-[250px] bg-white p-3 border border-gray-200 rounded-lg shadow-sm">
      <h3 class="text-lg font-semibold text-gray-600 mb-2 text-center">Vector Input</h3>
      <div class="flex space-x-4">
        <div class="flex-1">
          <div class="flex items-center mb-2">
            <span class="mathjax-label mr-2 text-base" id="v1-label"></span>
          </div>
          <div class="flex items-center mb-2">
            <span class="mathjax-label w-8 text-center mr-1" id="c1-coeff-label"></span>
            <input type="number" id="c1" placeholder="c₁" step="any" value="3" class="border border-gray-300 rounded p-2 w-20 text-sm">
          </div>
          <div class="flex items-center mb-2">
            <span class="mathjax-label w-8 text-center mr-1" id="v1x-label"></span>
            <input type="number" id="vec1x" placeholder="x₁" step="any" value="2" class="border border-gray-300 rounded p-2 w-20 text-sm">
          </div>
          <div class="flex items-center mb-2">
            <span class="mathjax-label w-8 text-center mr-1" id="v1y-label"></span>
            <input type="number" id="vec1y" placeholder="y₁" step="any" value="4" class="border border-gray-300 rounded p-2 w-20 text-sm">
          </div>
        </div>
        <div class="flex-1">
          <div class="flex items-center mb-2">
            <span class="mathjax-label mr-2 text-base" id="v2-label"></span>
          </div>
          <div class="flex items-center mb-2">
            <span class="mathjax-label w-8 text-center mr-1" id="c2-coeff-label"></span>
            <input type="number" id="c2" placeholder="c₂" step="any" value="2" class="border border-gray-300 rounded p-2 w-20 text-sm">
          </div>
          <div class="flex items-center mb-2">
            <span class="mathjax-label w-8 text-center mr-1" id="v2x-label"></span>
            <input type="number" id="vec2x" placeholder="x₂" step="any" value="1" class="border border-gray-300 rounded p-2 w-20 text-sm">
          </div>
          <div class="flex items-center mb-2">
            <span class="mathjax-label w-8 text-center mr-1" id="v2y-label"></span>
            <input type="number" id="vec2y" placeholder="y₂" step="any" value="-3" class="border border-gray-300 rounded p-2 w-20 text-sm">
          </div>
        </div>
      </div>
      <button id="showAddition" class="w-full bg-blue-600 text-white py-1 rounded hover:bg-blue-700 transition-colors">Show Linear Combination</button>
    </div>
    <div class="w-full md:w-[30%] min-w-[250px] bg-white p-3 border border-gray-200 rounded-lg shadow-sm">
      <h3 class="text-lg font-semibold text-gray-600 mb-2">System of Equations</h3>
      <div class="mb-2">
        <span class="mathjax-label mr-2 text-base" id="l1-label"></span>
        <input type="text" id="eq1" placeholder="2x + y = 8" value="2x + y = 8" class="border border-gray-300 rounded p-2 w-40 text-sm">
      </div>
      <div class="mb-2">
        <span class="mathjax-label mr-2 text-base" id="l2-label"></span>
        <input type="text" id="eq2" placeholder="4x - 3y = 6" value="4x - 3y = 6" class="border border-gray-300 rounded p-2 w-40 text-sm">
      </div>
      <button id="solveSystem" class="w-full bg-blue-600 text-white py-1 rounded hover:bg-blue-700 transition-colors">Solve System</button>
    </div>
  </div>
  <footer class="text-center text-gray-500 text-sm mt-6">
    &copy; Shelvean Kapita. Last Modified: June 30, 2025
  </footer>
  <script>
    // Utility to display errors
    function displayError(message) {
      const solutionInfo = document.getElementById('solution-info');
      solutionInfo.innerHTML = `<span class="text-red-500 text-lg">${message}</span>`;
    }

    // Initialize MathJax labels
    function renderMathJaxLabels() {
      const labels = {
        'v1-label': '\\( \\mathbf{v_1} = \\begin{bmatrix} x_1 \\\\ y_1 \\end{bmatrix} \\)',
        'v2-label': '\\( \\mathbf{v_2} = \\begin{bmatrix} x_2 \\\\ y_2 \\end{bmatrix} \\)',
        'c1-coeff-label': '\\( c_1 \\)',
        'c2-coeff-label': '\\( c_2 \\)',
        'v1x-label': '\\( x_1 \\)',
        'v1y-label': '\\( y_1 \\)',
        'v2x-label': '\\( x_2 \\)',
        'v2y-label': '\\( y_2 \\)',
        'l1-label': '\\( \\mathbf{L_1}: \\)',
        'l2-label': '\\( \\mathbf{L_2}: \\)'
      };
      Object.keys(labels).forEach(id => {
        document.getElementById(id).innerHTML = labels[id];
      });
      if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
        MathJax.typesetPromise(Object.keys(labels).map(id => `#${id}`)).catch(err => {
          console.warn('MathJax failed to render:', err);
          Object.keys(labels).forEach(id => {
            document.getElementById(id).textContent = id.includes('v1-label') ? 'v₁ = [x₁, y₁]' :
              id.includes('v2-label') ? 'v₂ = [x₂, y₂]' :
              id.includes('c1-coeff-label') ? 'c₁' :
              id.includes('c2-coeff-label') ? 'c₂' :
              id.includes('x1-label') ? 'x₁' :
              id.includes('y1-label') ? 'y₁' :
              id.includes('x2-label') ? 'x₂' :
              id.includes('y2-label') ? 'y₂' :
              id.includes('l1-label') ? 'L₁:' : 'L₂:';
          });
        });
      } else {
        displayError('MathJax failed to load. Some labels may not render correctly.');
        Object.keys(labels).forEach(id => {
          document.getElementById(id).textContent = id.includes('v1-label') ? 'v₁ = [x₁, y₁]' :
            id.includes('v2-label') ? 'v₂ = [x₂, y₂]' :
            id.includes('c1-coeff-label') ? 'c₁' :
            id.includes('c2-coeff-label') ? 'c₂' :
            id.includes('x1-label') ? 'x₁' :
            id.includes('y1-label') ? 'y₁' :
            id.includes('x2-label') ? 'x₂' :
            id.includes('y2-label') ? 'y₂' :
            id.includes('l1-label') ? 'L₁:' : 'L₂:';
        });
      }
    }

    // Wait for MathJax to load before rendering
    function initializeMathJax() {
      if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
        renderMathJaxLabels();
        setTimeout(() => {
          document.getElementById('solveSystem').click();
        }, 100);
      } else {
        setTimeout(initializeMathJax, 100);
      }
    }
    document.addEventListener('DOMContentLoaded', initializeMathJax);

    const canvas = document.getElementById('vectorCanvas');
    const ctx = canvas.getContext('2d');
    let scaleFactor = 20;

    // Coordinate transformation
    function mathToCanvasX(x) {
      return 400 + x * scaleFactor;
    }
    function mathToCanvasY(y) {
      return 300 - y * scaleFactor;
    }

    // Label management
    const labelContainer = document.getElementById('canvas-labels');
    function clearVectorLabels() {
      labelContainer.innerHTML = '';
    }
    function addVectorLabel(mathX, mathY, latex, color) {
      const label = document.createElement('span');
      label.className = 'vector-label';
      label.style.color = color;
      label.innerHTML = `\\(${latex}\\)`;
      const offset = 20;
      let canvasX = mathToCanvasX(mathX);
      let canvasY = mathToCanvasY(mathY);
      canvasX += offset;
      canvasY -= offset;
      label.style.left = `${canvasX}px`;
      label.style.top = `${canvasY}px`;
      labelContainer.appendChild(label);
    }
    function renderVectorLabels() {
      if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
        MathJax.typesetPromise([labelContainer, '#solution-info']).catch(err => {
          console.warn('MathJax typesetting failed:', err);
          displayError('Failed to render mathematical labels.');
        });
      }
    }

    // Draw arrow (vector)
    function drawArrow(mathStartX, mathStartY, mathEndX, mathEndY, color) {
      const startCanvasX = mathToCanvasX(mathStartX);
      const startCanvasY = mathToCanvasY(mathStartY);
      const endCanvasX = mathToCanvasX(mathEndX);
      const endCanvasY = mathToCanvasY(mathEndY);
      ctx.strokeStyle = color;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(startCanvasX, startCanvasY);
      ctx.lineTo(endCanvasX, endCanvasY);
      ctx.stroke();
      const dx = mathEndX - mathStartX;
      const dy = mathEndY - mathStartY;
      const theta = Math.atan2(dy, dx);
      const arrowAngle = Math.PI / 6;
      const arrowLength = 0.5;
      const p1x = mathEndX - arrowLength * Math.cos(theta + arrowAngle);
      const p1y = mathEndY - arrowLength * Math.sin(theta + arrowAngle);
      const p2x = mathEndX - arrowLength * Math.cos(theta - arrowAngle);
      const p2y = mathEndY - arrowLength * Math.sin(theta - arrowAngle);
      const p1CanvasX = mathToCanvasX(p1x);
      const p1CanvasY = mathToCanvasY(p1y);
      const p2CanvasX = mathToCanvasX(p2x);
      const p2CanvasY = mathToCanvasY(p2y);
      ctx.beginPath();
      ctx.moveTo(endCanvasX, endCanvasY);
      ctx.lineTo(p1CanvasX, p1CanvasY);
      ctx.moveTo(endCanvasX, endCanvasY);
      ctx.lineTo(p2CanvasX, p2CanvasY);
      ctx.stroke();
    }

    // Draw grid and axes
    function drawGridAndAxes() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      clearVectorLabels();
      ctx.strokeStyle = 'lightgray';
      ctx.lineWidth = 1;
      const minX = -400 / scaleFactor;
      const maxX = 400 / scaleFactor;
      const minY = -300 / scaleFactor;
      const maxY = 300 / scaleFactor;

      // Draw vertical grid lines
      for (let k = Math.ceil(minX); k <= Math.floor(maxX); k++) {
        const canvasX = mathToCanvasX(k);
        ctx.beginPath();
        ctx.moveTo(canvasX, 0);
        ctx.lineTo(canvasX, canvas.height);
        ctx.stroke();
      }

      // Draw horizontal grid lines
      for (let k = Math.ceil(minY); k <= Math.floor(maxY); k++) {
        const canvasY = mathToCanvasY(k);
        ctx.beginPath();
        ctx.moveTo(0, canvasY);
        ctx.lineTo(canvas.width, canvasY);
        ctx.stroke();
      }

      // Draw axes
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      const canvasOriginX = mathToCanvasX(0);
      const canvasOriginY = mathToCanvasY(0);
      ctx.beginPath();
      ctx.moveTo(0, canvasOriginY);
      ctx.lineTo(canvas.width, canvasOriginY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(canvasOriginX, 0);
      ctx.lineTo(canvasOriginX, canvas.height);
      ctx.stroke();

      // Draw coordinate labels
      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      for (let k = Math.ceil(minX); k <= Math.floor(maxX); k++) {
        if (k !== 0) {
          const canvasX = mathToCanvasX(k);
          ctx.fillText(k.toString(), canvasX, canvasOriginY + 5);
        }
      }
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for (let k = Math.ceil(minY); k <= Math.floor(maxY); k++) {
        if (k !== 0) {
          const canvasY = mathToCanvasY(k);
          ctx.fillText(k.toString(), canvasOriginX - 10, canvasY);
        }
      }
    }

    // Draw linear combination
    function drawAddition(vec1, vec2, c1, c2) {
      return function() {
        drawGridAndAxes();
        const scaledVec1 = { x: c1 * vec1.x, y: c1 * vec1.y, color: vec1.color };
        const scaledVec2 = { x: c2 * vec2.x, y: c2 * vec2.y, color: vec2.color };
        const sum = { x: scaledVec1.x + scaledVec2.x, y: scaledVec1.y + scaledVec2.y, color: 'black' };

        function formatCoefficient(c) {
          if (c === 1) return '';
          if (c === -1) return '-';
          if (Number.isInteger(c)) return c.toString();
          return c.toFixed(2);
        }
        function formatCoordinate(v) {
          if (Number.isInteger(v)) return v.toString();
          return v.toFixed(2);
        }

        const v1Label = formatCoefficient(c1) ? `${formatCoefficient(c1)} \\mathbf{v_1}` : '\\mathbf{v_1}';
        const v2Label = formatCoefficient(c2) ? `${formatCoefficient(c2)} \\mathbf{v_2}` : '\\mathbf{v_2}';
        const terms = [];
        if (c1 !== 0) terms.push(c1 === -1 ? '-\\mathbf{v_1}' : c1 === 1 ? '\\mathbf{v_1}' : `${formatCoefficient(c1)} \\mathbf{v_1}`);
        if (c2 !== 0) terms.push(c2 === -1 ? '-\\mathbf{v_2}' : c2 === 1 ? '\\mathbf{v_2}' : `${formatCoefficient(c2)} \\mathbf{v_2}`);
        let sumLabel = terms.length > 0 ? '' : '0';
        for (let i = 0; i < terms.length; i++) {
          if (i === 0) {
            sumLabel += terms[i];
          } else {
            sumLabel += terms[i].startsWith('-') ? ` ${terms[i]}` : ` + ${terms[i]}`;
          }
        }

        if (c1 !== 0) drawArrow(0, 0, scaledVec1.x, scaledVec1.y, scaledVec1.color);
        if (c2 !== 0) drawArrow(0, 0, scaledVec2.x, scaledVec2.y, scaledVec2.color);
        if (sum.x !== 0 || sum.y !== 0) drawArrow(0, 0, sum.x, sum.y, sum.color);

        if (sum.x !== 0 || sum.y !== 0) {
          ctx.fillStyle = 'rgba(0, 0, 255, 0.2)';
          ctx.beginPath();
          ctx.moveTo(mathToCanvasX(0), mathToCanvasY(0));
          ctx.lineTo(mathToCanvasX(scaledVec1.x), mathToCanvasY(scaledVec1.y));
          ctx.lineTo(mathToCanvasX(scaledVec1.x + scaledVec2.x), mathToCanvasY(scaledVec1.y + scaledVec2.y));
          ctx.lineTo(mathToCanvasX(scaledVec2.x), mathToCanvasY(scaledVec2.y));
          ctx.closePath();
          ctx.fill();
        }

        clearVectorLabels();
        if (c1 !== 0) addVectorLabel(scaledVec1.x, scaledVec1.y, v1Label, scaledVec1.color);
        if (c2 !== 0) addVectorLabel(scaledVec2.x, scaledVec2.y, v2Label, scaledVec2.color);
        if (sum.x !== 0 || sum.y !== 0) addVectorLabel(sum.x, sum.y, sumLabel, sum.color);

        document.getElementById('solution-info').innerHTML = `Linear Combination: \\(${sumLabel} = \\begin{bmatrix} ${formatCoordinate(sum.x)} \\\\ ${formatCoordinate(sum.y)} \\end{bmatrix}\\)`; 
        renderVectorLabels();
      };
    }

    // Parse linear equation
    function parseEquation(equation) {
      if (!equation) throw new Error('Equation cannot be empty.');
      equation = equation.replace(/\s+/g, '');
      const sides = equation.split('=');
      if (sides.length !== 2) throw new Error('Invalid equation: must contain exactly one "=".');
      const left = sides[0];
      const right = sides[1];
      const c = parseFloat(right);
      if (isNaN(c)) throw new Error('Invalid constant term: right side must be a number.');
      const terms = left.match(/([+-]?\d*\.?\d*[xy]?)/g)?.filter(term => term !== '') || [];
      if (terms.length === 0) throw new Error('No valid terms found in equation.');
      let a = 0, b = 0, leftConstant = 0;
      terms.forEach(term => {
        if (term.endsWith('x')) {
          const coeffStr = term.slice(0, -1);
          a += (coeffStr === '' || coeffStr === '+') ? 1 : (coeffStr === '-') ? -1 : parseFloat(coeffStr);
        } else if (term.endsWith('y')) {
          const coeffStr = term.slice(0, -1);
          b += (coeffStr === '' || coeffStr === '+') ? 1 : (coeffStr === '-') ? -1 : parseFloat(coeffStr);
        } else {
          const val = (term === '+' || term === '-') ? (term === '+' ? 1 : -1) : parseFloat(term);
          if (!isNaN(val)) leftConstant += val;
        }
      });
      if (isNaN(a) || isNaN(b) || isNaN(leftConstant)) throw new Error('Invalid coefficients in equation.');
      return { a, b, c: c - leftConstant };
    }

    // Get line segment within view
    function getLineSegment(a, b, c, minX, maxX, minY, maxY) {
      if (b === 0) {
        if (a === 0) return null;
        const x = c / a;
        if (x >= minX && x <= maxX) return { p1: {x, y: minY}, p2: {x, y: maxY} };
        return null;
      } else if (a === 0) {
        if (b === 0) return null;
        const y = c / b;
        if (y >= minY && y <= maxY) return { p1: {x: minX, y}, p2: {x: maxX, y} };
        return null;
      } else {
        const points = [];
        const y_at_minX = (c - a * minX) / b;
        if (y_at_minX >= minY && y_at_minX <= maxY) points.push({x: minX, y: y_at_minX});
        const y_at_maxX = (c - a * maxX) / b;
        if (y_at_maxX >= minY && y_at_maxX <= maxY) points.push({x: maxX, y: y_at_maxX});
        const x_at_minY = (c - b * minY) / a;
        if (x_at_minY >= minX && x_at_minY <= maxX) points.push({x: x_at_minY, y: minY});
        const x_at_maxY = (c - b * maxY) / a;
        if (x_at_maxY >= minX && x_at_maxY <= maxX) points.push({x: x_at_maxY, y: maxY});
        const uniquePoints = points.filter((p, i) => points.findIndex(q => q.x === p.x && q.y === p.y) === i);
        return uniquePoints.length >= 2 ? { p1: uniquePoints[0], p2: uniquePoints[1] } : null;
      }
    }

    // Draw line
    function drawLine(p1, p2, color) {
      const canvasX1 = mathToCanvasX(p1.x);
      const canvasY1 = mathToCanvasY(p1.y);
      const canvasX2 = mathToCanvasX(p2.x);
      const canvasY2 = mathToCanvasY(p2.y);
      ctx.strokeStyle = color;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(canvasX1, canvasY1);
      ctx.lineTo(canvasX2, canvasY2);
      ctx.stroke();
    }

    // Solve and draw system
    document.getElementById('solveSystem').addEventListener('click', () => {
      try {
        const eq1 = document.getElementById('eq1').value.trim();
        const eq2 = document.getElementById('eq2').value.trim();
        const line1 = parseEquation(eq1);
        const line2 = parseEquation(eq2);
        const { a: a1, b: b1, c: c1 } = line1;
        const { a: a2, b: b2, c: c2 } = line2;
        const D = a1 * b2 - a2 * b1;
        const D_x = c1 * b2 - c2 * b1;
        const D_y = a1 * c2 - a2 * c1;
        currentDrawFunction = () => {
          drawGridAndAxes();
          const minX = -400 / scaleFactor;
          const maxX = 400 / scaleFactor;
          const minY = -300 / scaleFactor;
          const maxY = 300 / scaleFactor;
          const segment1 = getLineSegment(a1, b1, c1, minX, maxX, minY, maxY);
          const segment2 = getLineSegment(a2, b2, c2, minX, maxX, minY, maxY);
          if (D !== 0) {
            const x = D_x / D;
            const y = D_y / D;
            if (x < minX || x > maxX || y < minY || y > maxY) {
              let scaleFactor_x = x !== 0 ? 350 / Math.abs(x) : Infinity;
              let scaleFactor_y = y !== 0 ? 250 / Math.abs(y) : Infinity;
              scaleFactor = Math.min(scaleFactor_x, scaleFactor_y) * 0.8 || 20;
            }
            if (segment1) {
              drawLine(segment1.p1, segment1.p2, 'darkred');
              addVectorLabel(segment1.p1.x, segment1.p1.y, '\\mathbf{L_1}', 'darkred');
            }
            if (segment2) {
              drawLine(segment2.p1, segment2.p2, 'darkblue');
              addVectorLabel(segment2.p1.x, segment2.p1.y, '\\mathbf{L_2}', 'darkblue');
            }
            const canvasX = mathToCanvasX(x);
            const canvasY = mathToCanvasY(y);
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 5, 0, 2 * Math.PI);
            ctx.fill();
            document.getElementById('solution-info').innerHTML = `Solution: \\(\\begin{bmatrix} ${formatCoordinate(x)} \\\\ ${formatCoordinate(y)} \\end{bmatrix}\\)`;
          } else {
            scaleFactor = 20;
            if (D_x === 0 && D_y === 0) {
              if (segment1) {
                drawLine(segment1.p1, segment1.p2, 'darkgreen');
                addVectorLabel(segment1.p1.x, segment1.p1.y, '\\mathbf{L_1} \\text{ and } \\mathbf{L_2}', 'darkgreen');
              }
              document.getElementById('solution-info').innerHTML = 'Infinitely many solutions';
            } else {
              if (segment1) {
                drawLine(segment1.p1, segment1.p2, 'darkred');
                addVectorLabel(segment1.p1.x, segment1.p1.y, '\\mathbf{L_1}', 'darkred');
              }
              if (segment2) {
                drawLine(segment2.p1, segment2.p2, 'darkblue');
                addVectorLabel(segment2.p1.x, segment2.p1.y, '\\mathbf{L_2}', 'darkblue');
              }
              document.getElementById('solution-info').innerHTML = 'No solution';
            }
          }
          renderVectorLabels();
        };
        currentDrawFunction();
      } catch (error) {
        displayError(error.message);
        drawGridAndAxes();
      }
    });

    // Initial draw
    let currentDrawFunction = drawGridAndAxes;
    drawGridAndAxes();

    // Vector addition event
    document.getElementById('showAddition').addEventListener('click', () => {
      const vec1x = parseFloat(document.getElementById('vec1x').value);
      const vec1y = parseFloat(document.getElementById('vec1y').value);
      const vec2x = parseFloat(document.getElementById('vec2x').value);
      const vec2y = parseFloat(document.getElementById('vec2y').value);
      const c1 = parseFloat(document.getElementById('c1').value) || 1;
      const c2 = parseFloat(document.getElementById('c2').value) || 1;
      if (isNaN(vec1x) || isNaN(vec1y) || isNaN(vec2x) || isNaN(vec2y) || isNaN(c1) || isNaN(c2)) {
        displayError('Please enter valid numbers for all vector components and coefficients.');
        drawGridAndAxes();
      } else {
        const vec1 = { x: vec1x, y: vec1y, color: 'darkred' };
        const vec2 = { x: vec2x, y: vec2y, color: 'darkblue' };
        currentDrawFunction = drawAddition(vec1, vec2, c1, c2);
        currentDrawFunction();
      }
    });

    // Reset view
    document.getElementById('resetView').addEventListener('click', () => {
      scaleFactor = 20;
      document.getElementById('c1').value = '3';
      document.getElementById('c2').value = '2';
      document.getElementById('vec1x').value = '2';
      document.getElementById('vec1y').value = '4';
      document.getElementById('vec2x').value = '1';
      document.getElementById('vec2y').value = '-3';
      document.getElementById('eq1').value = '2x + y = 8';
      document.getElementById('eq2').value = '4x - 3y = 6';
      currentDrawFunction = drawGridAndAxes;
      drawGridAndAxes();
      document.getElementById('solution-info').innerHTML = '';
    });

    // Zoom controls
    document.getElementById('zoomIn').addEventListener('click', () => {
      scaleFactor += 5;
      currentDrawFunction();
    });
    document.getElementById('zoomOut').addEventListener('click', () => {
      scaleFactor = Math.max(5, scaleFactor - 5);
      currentDrawFunction();
    });

    // Format coordinate for display
    function formatCoordinate(v) {
      if (Number.isInteger(v)) return v.toString();
      return v.toFixed(2);
    }
  </script>
</body>
</html>