<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="description" content="A web-based tool to compute the QR Factorization of a matrix. Input the matrix dimensions and values to calculate A = QR, with options for full or economy QR and decimal or surd output." />
    <meta name="keywords" content="QR factorization, QR decomposition, matrix decomposition, linear algebra, matrix calculator, numerical analysis, full QR, economy QR" />
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LEQE004C92"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LEQE004C92');
</script>
    <title>QR Factorization</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" />
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@14.6.0/lib/browser/math.js"></script>
    <style>
        .katex-display { margin: 1em 0; overflow-x: auto; }
        body { padding-left: 12.5vw; padding-right: 12.5vw; }
        @media (max-width: 900px) { body { padding-left: 3vw; padding-right: 3vw; }}
        .matrix-cell { width: 4rem; padding: 0.5rem; text-align: center; border: 2px solid #d1d5db; border-radius: 0.375rem; }
        .matrix-cell:hover { border-color: #3b82f6; border-width: 3px; }
        .matrix-cell:focus { outline: none; border-color: #3b82f6; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center">
    <div class="fixed top-0 left-0 w-full bg-white shadow-md z-10">
        <div class="max-w-4xl mx-auto px-4 py-2">
            <ul class="flex justify-center space-x-4">
                <li><a href="https://people.tamu.edu/~kapita/index.html" class="text-indigo-600 hover:text-blue-600 font-bold text-xl">Home</a></li>
                <li><a href="https://people.tamu.edu/~kapita/teaching.html" class="text-indigo-600 hover:text-blue-600 font-bold text-xl">Teaching</a></li>
                <li><a href="https://people.tamu.edu/~kapita/projects.html" class="text-indigo-600 hover:text-blue-600 font-bold text-xl">Diff Eq</a></li>
                <li><a href="https://people.tamu.edu/~kapita/linear.html" class="text-indigo-600 hover:text-blue-600 font-bold text-xl">Linear Algebra</a></li>
				<li><a href="https://people.tamu.edu/~kapita/numerical.html" class="text-indigo-600 hover:text-blue-600 font-bold text-xl">Numerical Methods</a></li>

            </ul>
        </div>
    </div>
    <div class="bg-white p-6 rounded-lg shadow-md max-w-4xl w-full mt-16">
        <h2 class="text-2xl font-bold mb-4 text-center text-gray-800">QR Factorization</h2>
        <p class="text-center text-gray-600 mb-6">
            Compute the <strong>QR Factorization</strong> of a matrix $A$ using Gram-Schmidt orthogonalization.<br>
            <span class="text-sm">Useful for solving least squares problems and computing eigenvalues.</span>
        </p>

        <!-- About QR Factorization - Collapsible -->
        <div class="bg-blue-50 border border-blue-300 rounded-lg mb-6 overflow-hidden">
            <button onclick="toggleQRConcepts()" class="w-full p-4 text-left flex items-center justify-between hover:bg-blue-100 transition duration-200">
                <h3 class="font-bold text-lg text-blue-800">About QR Factorization</h3>
                <span id="qrToggleIcon" class="text-blue-800 font-bold text-xl">−</span>
            </button>
            <div id="qrContent" class="px-4 pb-4">
                <p class="text-gray-700 mb-2 text-sm">For an $m \times n$ matrix $A$, the QR factorization is:</p>
                <p class="text-center mb-3">$$ A = QR $$</p>

                <p class="text-gray-700 mb-2"><strong>Components:</strong></p>
                <ul class="text-gray-700 text-sm mb-3 ml-6 list-disc">
                    <li>$Q$ is an $m \times m$ orthogonal matrix (or $m \times n$ for economy QR)</li>
                    <li>$R$ is an $m \times n$ upper triangular matrix (or $n \times n$ for economy QR)</li>
                    <li>$Q^TQ = I$ (columns of $Q$ are orthonormal)</li>
                </ul>

                <p class="text-gray-700 mb-2"><strong>Applications:</strong></p>
                <ul class="text-gray-700 text-sm ml-6 list-disc">
                    <li>Solving least squares problems: $\min \|Ax - b\|$</li>
                    <li>Computing eigenvalues (QR algorithm)</li>
                    <li>Orthonormalizing a set of vectors</li>
                </ul>
            </div>
        </div>

        <div class="bg-gray-50 p-4 rounded-lg mb-6 flex justify-center items-center space-x-4">
            <span class="text-gray-700">Rows $m$:</span>
            <input type="number" id="m" min="1" required class="w-16 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
            <span class="text-gray-700">Columns $n$:</span>
            <input type="number" id="n" min="1" required class="w-16 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button type="button" onclick="generateMatrix()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 transition duration-300">Generate Matrix</button>
            <button type="button" onclick="loadExample()" class="bg-purple-500 text-white px-4 py-2 rounded hover:bg-purple-600 transition duration-300">Load Example</button>
        </div>
        <div class="flex justify-center mb-6 space-x-6">
            <span class="text-gray-700">QR Type:</span>
            <label class="flex items-center">
                <input type="radio" name="qrType" value="full" checked class="mr-2">
                <span>Full</span>
            </label>
            <label class="flex items-center">
                <input type="radio" name="qrType" value="economy" class="mr-2">
                <span>Economy </span>
            </label>
        </div>
        <div class="flex justify-center mb-6 space-x-6">
            <span class="text-gray-700">Output Form:</span>
            <label class="flex items-center">
                <input type="radio" name="outputForm" value="decimal" class="mr-2">
                <span>Decimal</span>
            </label>
            <label class="flex items-center">
                <input type="radio" name="outputForm" value="surd" checked class="mr-2">
                <span>Surd</span>
            </label>
        </div>
        <div id="matrixInput" class="mb-6 overflow-x-auto"></div>
        <div class="flex justify-center space-x-4 mb-6">
            <button id="calcBtn" type="button" class="bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-600 transition duration-300 w-1/3">Compute QR</button>
            <button id="clearBtn" type="button" class="bg-gray-500 text-white px-6 py-2 rounded hover:bg-gray-600 transition duration-300 w-1/3">Clear All</button>
        </div>
        <div id="result" class="mt-6 p-4 bg-gray-50 rounded-lg"></div>
        <div class="mt-6 border-t pt-4 text-center text-gray-600 text-sm">
            © 2025 Shelvean Kapita: kapita@tamu.edu <br> Last modified: July 27, 2025
            <br>
            Licensed under the <a href="https://opensource.org/licenses/MIT" target="_blank">MIT License</a>.
        </div>
    </div>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "$", right: "$", display: false }
                ],
                throwOnError: false
            });
        });

        function generateMatrix() {
            const m = parseInt(document.getElementById("m").value, 10);
            const n = parseInt(document.getElementById("n").value, 10);
            if (isNaN(m) || m <= 0 || isNaN(n) || n <= 0) {
                alert("Please enter valid positive integers for m and n.");
                return;
            }
            const matrixDiv = document.getElementById("matrixInput");
            matrixDiv.innerHTML = "";
            const statementDiv = document.createElement("div");
            statementDiv.className = "text-center mb-4";
            const statement = document.createElement("div");
            statement.className = "latex";
            statement.textContent = `$$ \\text{Compute the QR Factorization } A = QR $$`;
            statementDiv.appendChild(statement);
            const emptyStatement = document.createElement("div");
            emptyStatement.className = "latex";
            emptyStatement.textContent = `$$ \\text{(empty spaces are treated as 0)} $$`;
            statementDiv.appendChild(emptyStatement);
            matrixDiv.appendChild(statementDiv);
            const aDiv = document.createElement("div");
            aDiv.className = "flex flex-col items-center";
            const aLabel = document.createElement("p");
            aLabel.className = "text-center font-semibold latex";
            aLabel.textContent = "Matrix $A$";
            aDiv.appendChild(aLabel);
            const aTable = document.createElement("table");
            aTable.className = "border-collapse";
            for (let i = 0; i < m; i++) {
                const tr = document.createElement("tr");
                for (let j = 0; j < n; j++) {
                    const td = document.createElement("td");
                    td.className = "p-1";
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "matrix-cell";
                    input.id = "A_" + i + "_" + j;
                    td.appendChild(input);
                    tr.appendChild(td);
                }
                aTable.appendChild(tr);
            }
            aDiv.appendChild(aTable);
            matrixDiv.appendChild(aDiv);
            renderMathInElement(matrixDiv, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "$", right: "$", display: false }
                ],
                throwOnError: false
            });
        }

        function clearAll() {
            document.getElementById("m").value = "";
            document.getElementById("n").value = "";
            document.getElementById("matrixInput").innerHTML = "";
            document.getElementById("result").innerHTML = "";
            document.querySelector('input[name="qrType"][value="full"]').checked = true;
            document.querySelector('input[name="outputForm"][value="surd"]').checked = true;
        }

        document.getElementById("clearBtn").addEventListener("click", clearAll);

        function parseFraction(str) {
            str = str.trim();
            if (str === '') return 0;
            try {
                let evaluated = math.evaluate(str);
                if (typeof evaluated === 'number') {
                    return evaluated;
                } else {
                    return 0;
                }
            } catch (e) {
                alert("Please enter valid numbers, fractions, or mathematical expressions in all cells.");
                return null;
            }
        }

        function readMatrix() {
            const m = parseInt(document.getElementById("m").value, 10);
            const n = parseInt(document.getElementById("n").value, 10);
            const A = [];
            for (let i = 0; i < m; i++) {
                const row = [];
                for (let j = 0; j < n; j++) {
                    const cell = document.getElementById("A_" + i + "_" + j);
                    const value = cell.value.trim();
                    const num = parseFraction(value);
                    if (num === null) {
                        return null;
                    }
                    row.push(num);
                }
                A.push(row);
            }
            return A;
        }

        function dot(a, b) {
            let s = 0;
            for (let i = 0; i < a.length; i++) s += a[i] * b[i];
            return s;
        }

        function norm2(a) {
            return Math.sqrt(dot(a, a));
        }

        function scalarMult(v, s) {
            return v.map(e => e * s);
        }

        function addVecs(a, b) {
            return a.map((e, i) => e + b[i]);
        }

        function isZeroMatrix(A) {
            const m = A.length, n = A[0].length;
            for (let i = 0; i < m; i++)
                for (let j = 0; j < n; j++)
                    if (Math.abs(A[i][j]) > 1e-7) return false;
            return true;
        }

        function identityMatrix(size) {
            const I = Array(size).fill(null).map(() => Array(size).fill(0));
            for (let i = 0; i < size; i++) {
                I[i][i] = 1;
            }
            return I;
        }

        function gcd(a, b) {
            if (!b) return Math.abs(a);
            return gcd(b, a % b);
        }

        function toFraction(f, maxden = 100) {
            if (Math.abs(f) < 1e-12) return { num: 0, den: 1 };
            let sign = f < 0 ? -1 : 1;
            f = Math.abs(f);
            let best_num = 1, best_den = 1, best_err = Math.abs(f - 1);
            for (let den = 1; den <= maxden; ++den) {
                let num = Math.round(f * den);
                let err = Math.abs(f - num / den);
                if (err < best_err) {
                    best_err = err;
                    best_num = num;
                    best_den = den;
                    if (best_err < 1e-12) break;
                }
            }
            best_num *= sign;
            let g = gcd(best_num, best_den);
            return { num: best_num / g, den: best_den / g };
        }

        function isPerfectSquare(n) {
            if (n < 0) return false;
            const root = Math.round(Math.sqrt(n));
            return Math.abs(root * root - n) < 1e-12;
        }

        function canBeSurd(val) {
            const MAX_DEN = 100;
            const MAX_NUM = 100;
            for (let b = 2; b <= MAX_DEN; ++b) {
                if (!isPerfectSquare(b)) {
                    const sqrtb = Math.sqrt(b);
                    for (let c = 1; c <= MAX_DEN; ++c) {
                        const a_approx = (val * c) / sqrtb;
                        if (Math.abs(a_approx - Math.round(a_approx)) < 1e-9 && Math.abs(Math.round(a_approx)) <= MAX_NUM) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function canBeSimpleFraction(val) {
            const frac = toFraction(val, 100);
            return Math.abs(frac.num) < 100 && frac.den < 100 && frac.den !== 1;
        }

        function formatSurd(val) {
            const MAX_DEN = 100;
            const MAX_NUM = 100;
            for (let b = 2; b <= MAX_DEN; ++b) {
                if (!isPerfectSquare(b)) {
                    const sqrtb = Math.sqrt(b);
                    for (let c = 1; c <= MAX_DEN; ++c) {
                        const a_approx = (val * c) / sqrtb;
                        if (Math.abs(a_approx - Math.round(a_approx)) < 1e-9 && Math.abs(Math.round(a_approx)) <= MAX_NUM) {
                            const a = Math.round(a_approx);
                            const sign = a < 0 ? "-" : "";
                            const a_abs = Math.abs(a);
                            const sqrtPart = `\\sqrt{${b}}`;
                            if (c === 1) {
                                return a_abs === 1 ? `${sign}${sqrtPart}` : `${sign}${a_abs}${sqrtPart}`;
                            } else {
                                const coeff = a_abs === 1 ? '' : a_abs;
                                return `${sign}${coeff}${sqrtPart}/${c}`;
                            }
                        }
                    }
                }
            }
            return null;
        }

        function formatFraction(val) {
            const frac = toFraction(val, 100);
            if (frac.den === 1) return `${frac.num}`;
            if (Math.abs(frac.num) < 100 && frac.den < 100) {
                const num = Math.abs(frac.num);
                const sign = frac.num < 0 ? "-" : "";
                return `${sign}${num}/${frac.den}`;
            }
            return null;
        }

        function formatForLatex(val, outputForm, forceDecimal = false, useFraction = false) {
            if (Math.abs(val) < 1e-12) return "0";
            if (outputForm === "decimal" || forceDecimal) {
                if (Math.abs(val - Math.round(val)) < 1e-12) return Math.round(val).toString();
                return val.toFixed(4).replace(/\.?0+$/, '');
            }
            if (useFraction) {
                const frac = formatFraction(val);
                return frac !== null ? frac : val.toFixed(4).replace(/\.?0+$/, '');
            }
            const surd = formatSurd(val);
            return surd !== null ? surd : val.toFixed(4).replace(/\.?0+$/, '');
        }

        function matrixToLatex(M, outputForm, forceDecimal = false, useFraction = false) {
            const rows = M.length;
            const cols = M[0].length;
            if (rows === 1 && cols === 1) return formatForLatex(M[0][0], outputForm, forceDecimal, useFraction);
            let latex = "\\begin{bmatrix}";
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    latex += formatForLatex(M[i][j], outputForm, forceDecimal, useFraction);
                    if (j < cols - 1) latex += " & ";
                }
                if (i < rows - 1) latex += " \\\\ ";
            }
            latex += "\\end{bmatrix}";
            return latex;
        }

        // Householder QR Factorization
        function computeQR(A) {
            const m = A.length;
            const n = A[0].length;
            if (isZeroMatrix(A)) {
                const Q = identityMatrix(m);
                const R = Array(m).fill().map(() => Array(n).fill(0));
                return { fullQ: Q, fullR: R, thinQ: Array(m).fill().map(() => Array(0)), thinR: Array(0).fill().map(() => Array(n).fill(0)), rank: 0 };
            }
            let R = A.map((row) => row.slice());
            let Q = identityMatrix(m);
            for (let k = 0; k < Math.min(m, n); k++) {
                let x = [];
                for (let i = k; i < m; i++) x.push(R[i][k]);
                let normx = norm2(x);
                if (normx < 1e-14) continue;
                let v = x.slice();
                v[0] += (x[0] >= 0 ? 1 : -1) * normx;
                let vnorm = norm2(v);
                if (vnorm < 1e-14) continue;
                for (let i = 0; i < v.length; i++) v[i] /= vnorm;
                for (let j = k; j < n; j++) {
                    let dotprod = 0;
                    for (let i = 0; i < v.length; i++) dotprod += v[i] * R[k + i][j];
                    for (let i = 0; i < v.length; i++) {
                        R[k + i][j] -= 2 * v[i] * dotprod;
                        if (Math.abs(R[k + i][j]) < 1e-14) R[k + i][j] = 0;
                    }
                }
                for (let i = 0; i < m; i++) {
                    let dotprod = 0;
                    for (let j = 0; j < v.length; j++) dotprod += Q[i][k + j] * v[j];
                    for (let j = 0; j < v.length; j++) {
                        Q[i][k + j] -= 2 * v[j] * dotprod;
                        if (Math.abs(Q[i][k + j]) < 1e-14) Q[i][k + j] = 0;
                    }
                }
            }
            for (let i = 0; i < Math.min(m, n); i++) {
                if (R[i][i] < 0) {
                    for (let j = 0; j < n; j++) R[i][j] = -R[i][j];
                    for (let j = 0; j < m; j++) Q[j][i] = -Q[j][i];
                }
            }
            let rank = 0;
            for (let i = 0; i < Math.min(m, n); i++) if (Math.abs(R[i][i]) > 1e-14) rank++;
            let thinQ = Q.map((row) => row.slice(0, rank));
            let thinR = R.slice(0, rank).map((row) => row.slice());
            return { fullQ: Q, fullR: R, thinQ: thinQ, thinR: thinR, rank: rank };
        }

        document.getElementById("calcBtn").addEventListener("click", function () {
            const A = readMatrix();
            if (A === null) return;
            const m = A.length;
            const n = A[0].length;
            const { fullQ, fullR, thinQ, thinR } = computeQR(A);
            const qrType = document.querySelector('input[name="qrType"]:checked').value;
            const outputForm = document.querySelector('input[name="outputForm"]:checked').value;
            let Q_display, R_display;
            if (qrType === "economy") {
                Q_display = thinQ;
                R_display = thinR;
            } else {
                Q_display = fullQ;
                R_display = fullR;
            }
            let forceDecimal = false;
            let useFraction = false;
            if (outputForm === "surd") {
                let allSurd = true;
                let allSimpleFraction = true;
                function checkMatrix(matrix) {
                    for (let i = 0; i < matrix.length; i++) {
                        for (let j = 0; j < matrix[0].length; j++) {
                            const val = matrix[i][j];
                            if (Math.abs(val) < 1e-12) continue;
                            if (Math.abs(val - Math.round(val)) < 1e-12) continue;
                            if (!canBeSurd(val)) allSurd = false;
                            if (!canBeSimpleFraction(val)) allSimpleFraction = false;
                        }
                    }
                }
                checkMatrix(Q_display);
                checkMatrix(R_display);
                if (!allSurd && !allSimpleFraction) {
                    forceDecimal = true;
                } else if (allSimpleFraction) {
                    useFraction = true;
                }
            }
            const Q_latex = matrixToLatex(Q_display, outputForm, forceDecimal, useFraction);
            const R_latex = matrixToLatex(R_display, outputForm, forceDecimal, useFraction);
            const resultDiv = document.getElementById("result");
            resultDiv.innerHTML = `<div class="latex">$$ Q = ${Q_latex} $$</div><div class="latex">$$ R = ${R_latex} $$</div>`;
            renderMathInElement(resultDiv, {
                delimiters: [{ left: "$$", right: "$$", display: true }],
                throwOnError: false
            });
        });

        function toggleQRConcepts() {
            var content = document.getElementById("qrContent");
            var icon = document.getElementById("qrToggleIcon");
            if (content.style.display === "none") {
                content.style.display = "block";
                icon.textContent = "−";
            } else {
                content.style.display = "none";
                icon.textContent = "+";
            }
        }

        function loadExample() {
            document.getElementById("m").value = "3";
            document.getElementById("n").value = "2";
            generateMatrix();
            setTimeout(() => {
                // Example: 3x2 matrix for QR factorization
                document.getElementById("A_0_0").value = "1";
                document.getElementById("A_0_1").value = "1";
                document.getElementById("A_1_0").value = "1";
                document.getElementById("A_1_1").value = "0";
                document.getElementById("A_2_0").value = "0";
                document.getElementById("A_2_1").value = "1";
            }, 100);
        }

        // Render LaTeX on page load
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "$", right: "$", display: false }
                ],
                throwOnError: false
            });
        });
    </script>
</body>

</html>
