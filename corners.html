<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Shelvean Kapita - Interactive Method of Corners for Linear Programming" />
    <meta name="keywords" content="Shelvean Kapita, Linear Programming, Method of Corners, Graphical Method" />
    <title>Linear Programming: Method of Corners</title>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LEQE004C92"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-LEQE004C92');
    </script>

    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,400;0,700;1,400;1,700&family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet" />

    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        body { background: #f8f9fa; min-height: 100vh; padding: 20px; overflow-y: auto; font-size: 18px; }
        h1 { text-align: center; color: #2c3e50; margin-bottom: 24px; font-size: 32px; font-weight: 600; }

        header {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
            padding: 1.5rem 1rem;
            margin-bottom: 1.5rem;
        }

        .header-title {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 1rem;
        }

        .header-title a {
            color: #1a202c;
            text-decoration: none;
            transition: color 0.2s;
        }

        .header-title a:hover {
            color: #4f46e5;
        }

        nav ul {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 2.5rem;
            margin: 0;
            padding: 0;
            list-style: none;
        }

        nav a {
            color: #4f46e5;
            font-weight: 700;
            font-size: 1.25rem;
            transition: color 0.2s;
            text-decoration: none;
        }

        nav a:hover { color: #4338ca; }

        .container { max-width: 1800px; margin: 0 auto; display: grid; grid-template-columns: 1fr 1fr 460px; grid-template-rows: auto 680px auto; gap: 18px; }
        .inequalities-display { grid-column: 1 / span 2; background: white; border-radius: 8px; padding: 16px 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border: 1px solid #e0e6ed; display: flex; align-items: center; justify-content: center; flex-wrap: wrap; gap: 14px; min-height: 60px; font-size: 20px; }
        .plot-area { grid-column: 1 / span 2; grid-row: 2; background: white; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); position: relative; }
        #plot { width: 100%; height: 100%; }
        .right-panel { grid-column: 3; grid-row: 1 / span 3; background: white; border-radius: 10px; padding: 20px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); display: flex; flex-direction: column; gap: 24px; font-size: 17px; }
        .panel-section { flex: 1; }
        .panel-title { color: #2c3e50; font-size: 20px; font-weight: 600; margin-bottom: 14px; display: flex; align-items: center; gap: 10px; }
        .shading-controls { display: flex; flex-direction: column; gap: 12px; padding: 14px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef; font-size: 17px; }
        .example-list { display: flex; flex-direction: column; gap: 12px; }
        .example-btn { background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; padding: 14px; cursor: pointer; transition: all 0.2s; text-align: left; font-size: 16px; }
        .example-btn:hover { background: #e9ecef; border-color: #ccc; }
        .example-title { font-weight: 600; color: #2c3e50; font-size: 18px; margin-bottom: 4px; }
        .example-desc { color: #6c757d; font-size: 15px; line-height: 1.4; }
        .controls { display: flex; flex-direction: column; gap: 12px; }
        .action-btn { padding: 14px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 17px; transition: all 0.2s; }
        #update-plot { background: #3498db; color: white; }
        #update-plot:hover { background: #2980b9; }
        #clear-all { background: #f8f9fa; color: #495057; border: 1px solid #e9ecef; }
        #clear-all:hover { background: #e9ecef; }
        .corner-points-section { flex: 1; display: flex; flex-direction: column; }
        .corner-points-title { color: #2c3e50; font-size: 20px; font-weight: 600; margin-bottom: 14px; display: flex; align-items: center; gap: 10px; }
        #corner-points-table { width: 100%; border-collapse: collapse; border-radius: 6px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); font-size: 16px; }
        #corner-points-table th { background: #f8f9fa; padding: 12px; text-align: left; font-weight: 600; color: #2c3e50; border-bottom: 2px solid #e9ecef; }
        #corner-points-table td { padding: 12px; border-bottom: 1px solid #e9ecef; }
        #corner-points-table tr:last-child td { border-bottom: none; }
        .corner-label { font-weight: 700; color: #2c3e50; }
        .corner-coordinates, .objective-value { font-family: monospace; color: #495057; }
        .input-section { grid-column: 1 / span 2; grid-row: 3; background: white; border-radius: 10px; padding: 20px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
        .constraints-section, .objective-section { display: flex; flex-direction: column; }
        .input-header { display: flex; align-items: center; gap: 12px; margin-bottom: 18px; flex-wrap: wrap; }
        .input-title { color: #2c3e50; font-size: 20px; font-weight: 600; }
        #add-inequality, #add-non-negativity { background: #2ecc71; color: white; border: none; border-radius: 5px; padding: 10px 18px; font-weight: 600; cursor: pointer; font-size: 16px; transition: background 0.2s; }
        #add-inequality:hover, #add-non-negativity:hover { background: #27ae60; }
        .inequality-inputs { display: flex; flex-direction: column; gap: 12px; }
        .ineq-row { display: flex; align-items: center; gap: 10px; padding: 10px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef; }
        .lhs-input, .rhs-input, .objective-input { padding: 10px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 17px; transition: border-color 0.2s; }
        .lhs-input { flex: 1; min-width: 0; }
        .rhs-input { width: 200px; }
        .objective-input { width: 240px; }
        .relation-select { width: 70px; padding: 10px; border: 1px solid #dee2e6; border-radius: 4px; background: white; cursor: pointer; font-size: 17px; }
        .remove-btn { background: #e74c3c; color: white; border: none; border-radius: 4px; width: 36px; height: 36px; cursor: pointer; font-size: 18px; transition: background 0.2s; flex-shrink: 0; }
        .remove-btn:hover { background: #c0392b; }
        .help-text { color: #6c757d; font-size: 15px; margin-top: 10px; font-style: italic; }
        .objective-row { display: flex; align-items: center; gap: 12px; }
        .objective-row span { font-size: 20px; font-weight: 600; }

        footer {
            text-align: center;
            padding: 2rem;
            border-top: 1px solid #e5e7eb;
            color: #6b7280;
            font-size: 0.875rem;
            margin-top: 3rem;
        }

        @media (max-width: 1200px) {
            .container { grid-template-columns: 1fr; grid-template-rows: auto auto auto auto; gap: 16px; }
            .right-panel { grid-column: 1; grid-row: 2; }
            .plot-area { grid-row: 3; height: 500px; }
            .input-section { grid-column: 1; grid-row: 4; grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <!-- Header with navigation -->
    <header>
        <div class="max-w-6xl mx-auto">
            <h1 class="header-title">
                <a href="index.html">Shelvean Kapita</a>
            </h1>
            <nav>
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="teaching.html">Teaching</a></li>
                    <li><a href="projects.html">Diff Eq</a></li>
                    <li><a href="linear.html">Linear Algebra</a></li>
                    <li><a href="optim.html">Linear Programming</a></li>
                    <li><a href="numerical.html">Numerical Methods</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <h1>Linear Programming: Method of Corners</h1>

    <div class="container">
        <div class="inequalities-display" id="inequalities-display">
            <span style="color: #adb5bd;">Add inequalities below</span>
        </div>

        <div class="plot-area">
            <div id="plot"></div>
        </div>

        <div class="right-panel">
            <div class="panel-section">
                <div class="panel-title">Examples</div>
                <div class="example-list">
                    <button class="example-btn" data-example="feasible-region">
                        <div class="example-title">Bounded Region</div>
                        <div class="example-desc">x ≥ 0, y ≥ 0, 2x + y ≤ 10, x + 2y ≤ 8<br>P = 3x + 4y</div>
                    </button>
                    <button class="example-btn" data-example="unbounded">
                        <div class="example-title">Unbounded Region</div>
                        <div class="example-desc">x ≥ 0, y ≥ 0, 2x + y ≥ 10, x + 2y ≥ 8<br>P = x + y</div>
                    </button>
                    <button class="example-btn" data-example="single-halfplane">
                        <div class="example-title">Single Half-Plane</div>
                        <div class="example-desc">x + y ≥ 3</div>
                    </button>
                </div>
            </div>

            <div class="shading-controls">
                <div class="panel-title" style="margin-bottom:10px;font-size:18px;">Shading Mode</div>
                <label><input type="radio" name="shading-mode" value="true"> True Shading (feasible side)</label>
                <label><input type="radio" name="shading-mode" value="reverse" checked> Reverse Shading (infeasible side)</label>
            </div>

            <div class="controls">
                <button class="action-btn" id="update-plot">Update Plot</button>
                <button class="action-btn" id="clear-all">Clear All</button>
            </div>

            <div class="corner-points-section">
                <div class="corner-points-title">Corner Points & Objective Values</div>
                <table id="corner-points-table">
                    <thead>
                        <tr>
                            <th>Label</th>
                            <th>Coordinates (x, y)</th>
                            <th>P Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td colspan="3" style="text-align: center; color: #adb5bd; font-style: italic;">
                                Corner points will appear here for bounded regions
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="input-section">
            <div class="constraints-section">
                <div class="input-header">
                    <div class="input-title">Enter Constraints (Inequalities)</div>
                    <div>
                        <button id="add-inequality">+ Add Inequality</button>
                        <button id="add-non-negativity">+ Add Non-Negativity</button>
                    </div>
                </div>
                <div class="inequality-inputs" id="inequality-inputs"></div>
                <div class="help-text">Examples: "2x+3y", "x-y", "y", "0.5x+2y", "(1/2)x+(3/5)y", "-x/2+3y/5"</div>
            </div>

            <div class="objective-section">
                <div class="input-header">
                    <div class="input-title">Enter Objective Function</div>
                </div>
                <div class="objective-row">
                    <span>P =</span>
                    <input type="text" class="objective-input" id="objective-function" placeholder="e.g., 3x+4y" value="3x+4y">
                </div>
                <div style="margin-top: 20px;">
                    <label for="display-mode" style="font-weight: 600; color: #2c3e50; display: block; margin-bottom: 8px;">Coordinates Display Format:</label>
                    <select id="display-mode" class="relation-select" style="width: 100%; padding: 10px;">
                        <option value="decimal">Decimals</option>
                        <option value="fraction">Fractions</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <footer class="text-center py-8 border-t border-gray-200 text-gray-600 text-sm mt-16">
        <p>© <span id="current-year"></span> Shelvean Kapita. All rights reserved.</p>
        <p class="mt-2">
            This interactive tool is licensed under the 
            <a href="https://opensource.org/licenses/MIT" target="_blank" rel="noopener noreferrer" 
               class="text-indigo-600 hover:text-indigo-800 underline">
                MIT License
            </a>.
        </p>
        <p class="mt-4 text-xs text-gray-500">Last modified on January 15, 2026.</p>
    </footer>

    <script>
        // Update copyright year dynamically
        document.getElementById('current-year').textContent = new Date().getFullYear();

        class InequalityPlotter {
            constructor() {
                this.colors = ['#E41A1C', '#377EB8', '#4DAF4A', '#984EA3', '#FF7F00', '#A65628', '#F781BF', '#999999'];
                this.plotInitialized = false;
                this.cornerLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
                this.bindEvents();
                setTimeout(() => {
                    this.updatePlot();
                    this.loadExample('feasible-region');
                }, 100);
            }

            bindEvents() {
                document.getElementById('add-inequality').addEventListener('click', () => this.addInequality());
                document.getElementById('add-non-negativity').addEventListener('click', () => this.addNonNegativity());
                document.getElementById('update-plot').addEventListener('click', () => this.updatePlot());
                document.getElementById('clear-all').addEventListener('click', () => this.clearAll());
                document.getElementById('objective-function').addEventListener('input', () => this.updatePlot());

                // Add event listener for display mode dropdown
                setTimeout(() => {
                    const displayModeSelect = document.getElementById('display-mode');
                    if (displayModeSelect) {
                        displayModeSelect.addEventListener('change', () => this.updatePlot());
                    }
                }, 200);

                document.querySelectorAll('.example-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const example = e.currentTarget.dataset.example;
                        this.loadExample(example);
                    });
                });

                document.querySelectorAll('input[name="shading-mode"]').forEach(radio => {
                    radio.addEventListener('change', () => this.updatePlot());
                });

                window.addEventListener('resize', () => {
                    if (this.plotInitialized) {
                        this.updatePlot();
                    }
                });
            }

            addNonNegativity() {
                let hasX = false;
                document.querySelectorAll('.ineq-row').forEach(row => {
                    const lhs = row.querySelector('.lhs-input').value.trim().toLowerCase();
                    if (lhs === 'x') hasX = true;
                });
                if (!hasX) {
                    this.addInequality({ lhs: "x", relation: '≥', rhs: 0 });
                }
                let hasY = false;
                document.querySelectorAll('.ineq-row').forEach(row => {
                    const lhs = row.querySelector('.lhs-input').value.trim().toLowerCase();
                    if (lhs === 'y') hasY = true;
                });
                if (!hasY) {
                    this.addInequality({ lhs: "y", relation: '≥', rhs: 0 });
                }
                if (hasX && hasY) {
                    alert('Non-negativity constraints x ≥ 0 and y ≥ 0 are already present.');
                }
            }

            getShadingMode() {
                const selected = document.querySelector('input[name="shading-mode"]:checked');
                return selected ? selected.value : 'reverse';
            }

            createInequalityRow(data = { lhs: "x", relation: '≥', rhs: 0 }) {
                const row = document.createElement('div');
                row.className = 'ineq-row';
                row.innerHTML = `
                    <input type="text" class="lhs-input" placeholder="e.g., 2x+3y" value="${data.lhs}">
                    <select class="relation-select">
                        <option value="≤" ${data.relation === '≤' ? 'selected' : ''}>≤</option>
                        <option value="≥" ${data.relation === '≥' ? 'selected' : ''}>≥</option>
                        <option value="<" ${data.relation === '<' ? 'selected' : ''}>&lt;</option>
                        <option value=">" ${data.relation === '>' ? 'selected' : ''}>&gt;</option>
                    </select>
                    <input type="text" class="rhs-input" placeholder="10 or 10/3" value="${data.rhs}">
                    <button class="remove-btn" title="Remove">×</button>
                `;
                row.querySelector('.remove-btn').addEventListener('click', () => {
                    row.remove();
                    this.updatePlot();
                });
                row.querySelectorAll('input, select').forEach(el => {
                    el.addEventListener('input', () => this.updatePlot());
                    el.addEventListener('change', () => this.updatePlot());
                });
                return row;
            }

            addInequality(data) {
                const container = document.getElementById('inequality-inputs');
                const row = this.createInequalityRow(data);
                container.appendChild(row);
                this.updatePlot();
            }

            evaluateFraction(fractionStr) {
                // Handle fractions like "1/2", "-3/4", etc.
                const parts = fractionStr.split('/');
                if (parts.length === 2) {
                    const numerator = parseFloat(parts[0]);
                    const denominator = parseFloat(parts[1]);
                    if (!isNaN(numerator) && !isNaN(denominator) && denominator !== 0) {
                        return numerator / denominator;
                    }
                }
                return parseFloat(fractionStr);
            }

            parseCoefficient(coeffStr) {
                if (coeffStr === '' || coeffStr === '+') return 1;
                if (coeffStr === '-') return -1;

                // Check if it contains a fraction
                if (coeffStr.includes('/')) {
                    // Handle cases like (-1/2) or -1/2
                    coeffStr = coeffStr.replace(/[()]/g, '');
                    return this.evaluateFraction(coeffStr);
                }

                return parseFloat(coeffStr);
            }

            parseLHS(lhsString) {
                let str = lhsString.replace(/\s+/g, '').toLowerCase();
                str = str.replace(/\*/g, '');
                let a = 0;
                let b = 0;

                if (str === '') return { a: 0, b: 0 };
                if (str === 'x') return { a: 1, b: 0 };
                if (str === 'y') return { a: 0, b: 1 };
                if (str === '-x') return { a: -1, b: 0 };
                if (str === '-y') return { a: 0, b: -1 };

                // Match x terms with various coefficient formats
                // Handles: 2x, -3x, (1/2)x, (-1/2)x, x/2, -x/2, 0.5x, etc.
                const xPatterns = [
                    /(\([+-]?\d+\/\d+\))x/,           // (1/2)x or (-1/2)x
                    /([+-]?\d+\.?\d*)x\/(\d+\.?\d*)/,  // 3x/2 or -x/2
                    /([+-]?\d+\/\d+)x/,                // 1/2x or -1/2x
                    /([+-]?\d*\.?\d*)x/                // 2x, -3x, 0.5x
                ];

                for (const pattern of xPatterns) {
                    const xMatch = str.match(pattern);
                    if (xMatch) {
                        if (pattern.source.includes('x\\/')) {
                            // Handle x/denominator format (e.g., 3x/2)
                            const numeratorCoeff = xMatch[1];
                            const denominator = xMatch[2];
                            const num = this.parseCoefficient(numeratorCoeff);
                            const den = parseFloat(denominator);
                            a = num / den;
                        } else {
                            // Handle (fraction)x or regular coefficient
                            const coeff = xMatch[1];
                            a = this.parseCoefficient(coeff);
                        }
                        str = str.replace(xMatch[0], '');
                        break;
                    }
                }

                // Match y terms with various coefficient formats
                const yPatterns = [
                    /(\([+-]?\d+\/\d+\))y/,           // (1/2)y or (-3/5)y
                    /([+-]?\d+\.?\d*)y\/(\d+\.?\d*)/,  // 3y/5 or -y/2
                    /([+-]?\d+\/\d+)y/,                // 1/2y or -3/5y
                    /([+-]?\d*\.?\d*)y/                // 2y, -3y, 0.5y
                ];

                for (const pattern of yPatterns) {
                    const yMatch = str.match(pattern);
                    if (yMatch) {
                        if (pattern.source.includes('y\\/')) {
                            // Handle y/denominator format (e.g., 3y/5)
                            const numeratorCoeff = yMatch[1];
                            const denominator = yMatch[2];
                            const num = this.parseCoefficient(numeratorCoeff);
                            const den = parseFloat(denominator);
                            b = num / den;
                        } else {
                            // Handle (fraction)y or regular coefficient
                            const coeff = yMatch[1];
                            b = this.parseCoefficient(coeff);
                        }
                        str = str.replace(yMatch[0], '');
                        break;
                    }
                }

                // Check for remaining constant term
                if (str !== '' && !isNaN(parseFloat(str))) {
                    b = parseFloat(str);
                }

                if (isNaN(a)) a = 0;
                if (isNaN(b)) b = 0;
                return { a, b };
            }

            getInequalities() {
                const inequalities = [];
                const rows = document.querySelectorAll('.ineq-row');
                rows.forEach((row, i) => {
                    const lhs = row.querySelector('.lhs-input').value || '';
                    const relation = row.querySelector('.relation-select').value;
                    const rhsString = row.querySelector('.rhs-input').value || '0';
                    const rhs = this.evaluateFraction(rhsString);
                    const coefficients = this.parseLHS(lhs);
                    inequalities.push({
                        a: coefficients.a,
                        b: coefficients.b,
                        c: rhs,
                        relation: relation,
                        color: this.colors[i % this.colors.length],
                        lhsString: lhs,
                        rhsString: rhsString.trim()
                    });
                });
                return inequalities;
            }

            getObjective() {
                const expr = document.getElementById('objective-function').value.trim().toLowerCase() || '0';
                const coeffs = this.parseLHS(expr);
                return { px: coeffs.a, py: coeffs.b };
            }

            updateInequalitiesDisplay(inequalities) {
                const display = document.getElementById('inequalities-display');
                if (inequalities.length === 0) {
                    display.innerHTML = '<span style="color: #adb5bd;">Add inequalities below</span>';
                    return;
                }
                display.innerHTML = '';
                inequalities.forEach((ineq, i) => {
                    const container = document.createElement('div');
                    container.className = 'inequality-item';
                    const latex = this.generateLatex(ineq, i);
                    const latexSpan = document.createElement('span');
                    latexSpan.className = 'inequality-katex';
                    container.appendChild(latexSpan);
                    try {
                        katex.render(latex, latexSpan, { throwOnError: false });
                    } catch (error) {
                        latexSpan.textContent = `${this.formatLHS(ineq)} ${ineq.relation} ${ineq.c}`;
                    }
                    display.appendChild(container);
                });
            }

            formatRHSForLatex(rhsString, rhsValue) {
                // Check if the input is in fraction format
                if (rhsString.includes('/')) {
                    const parts = rhsString.split('/');
                    if (parts.length === 2) {
                        const num = parts[0].trim();
                        const den = parts[1].trim();
                        if (!isNaN(parseFloat(num)) && !isNaN(parseFloat(den))) {
                            return `\\frac{${num}}{${den}}`;
                        }
                    }
                }
                // Otherwise, try to convert to fraction if it's not an integer
                if (!Number.isInteger(rhsValue)) {
                    const frac = this.toFraction(rhsValue);
                    if (frac.denominator !== 1) {
                        return `\\frac{${frac.numerator}}{${frac.denominator}}`;
                    }
                }
                // Return as regular number
                return this.formatNumber(rhsValue);
            }

            generateLatex(ineq, index) {
                const a = this.formatCoefficient(ineq.a, false);
                const b = this.formatCoefficient(ineq.b, true);
                const relation = this.getLatexRelation(ineq.relation);
                const c = this.formatRHSForLatex(ineq.rhsString, ineq.c);
                let latex = '';
                if (a === '0' && b === '0') {
                    latex = `0 ${relation} ${c}`;
                } else if (a === '0') {
                    latex = `${b} ${relation} ${c}`;
                } else if (b === '0') {
                    latex = `${a} ${relation} ${c}`;
                } else {
                    const bSign = ineq.b < 0 ? '-' : '+';
                    const bAbs = this.formatCoefficient(Math.abs(ineq.b), true);
                    latex = `${a} ${bSign} ${bAbs} ${relation} ${c}`;
                }
                return `\\color{${this.colors[index % this.colors.length]}}{${latex}}`;
            }

            formatLHS(ineq) {
                const a = this.formatCoefficient(ineq.a, false);
                const b = this.formatCoefficient(ineq.b, true);
                if (a === '0' && b === '0') return '0';
                if (a === '0') return b;
                if (b === '0') return a;
                const bSign = ineq.b < 0 ? '-' : '+';
                const bAbs = this.formatCoefficient(Math.abs(ineq.b), true);
                return `${a} ${bSign} ${bAbs}`;
            }

            hexToRgb(hex) {
                const bigint = parseInt(hex.slice(1), 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return { r, g, b };
            }

            calculateBounds(inequalities) {
                if (inequalities.length === 0) {
                    return { xMin: -5, xMax: 5, yMin: -5, yMax: 5 };
                }
                let xMin = -10, xMax = 10, yMin = -10, yMax = 10;
                inequalities.forEach(ineq => {
                    if (Math.abs(ineq.a) > 0.001) {
                        const xInt = ineq.c / ineq.a;
                        xMin = Math.min(xMin, xInt);
                        xMax = Math.max(xMax, xInt);
                    }
                    if (Math.abs(ineq.b) > 0.001) {
                        const yInt = ineq.c / ineq.b;
                        yMin = Math.min(yMin, yInt);
                        yMax = Math.max(yMax, yInt);
                    }
                });
                const rangeX = xMax - xMin || 10;
                const rangeY = yMax - yMin || 10;
                const padding = Math.max(rangeX * 0.4, rangeY * 0.4, 4);
                xMin -= padding;
                xMax += padding;
                yMin -= padding;
                yMax += padding;
                return { xMin, xMax, yMin, yMax };
            }

            intersectLines(ineq1, ineq2) {
                const det = ineq1.a * ineq2.b - ineq2.a * ineq1.b;
                if (Math.abs(det) < 1e-8) return null;
                const x = (ineq1.c * ineq2.b - ineq2.c * ineq1.b) / det;
                const y = (ineq1.a * ineq2.c - ineq2.a * ineq1.c) / det;
                return [x, y];
            }

            pointSatisfiesAll(point, inequalities) {
                const [x, y] = point;
                for (const ineq of inequalities) {
                    const val = ineq.a * x + ineq.b * y;
                    const tol = 1e-6;
                    if ((ineq.relation === '≤' || ineq.relation === '<') && val > ineq.c + tol) return false;
                    if ((ineq.relation === '≥' || ineq.relation === '>') && val < ineq.c - tol) return false;
                }
                return true;
            }

            findCornerPoints(inequalities, bounds) {
                if (inequalities.length < 2) return [];
                const points = [];
                for (let i = 0; i < inequalities.length; i++) {
                    for (let j = i + 1; j < inequalities.length; j++) {
                        const p = this.intersectLines(inequalities[i], inequalities[j]);
                        if (p && this.pointSatisfiesAll(p, inequalities)) {
                            points.push(p);
                        }
                    }
                }
                return points.filter((p, idx) => points.findIndex(q => Math.abs(q[0]-p[0])<1e-6 && Math.abs(q[1]-p[1])<1e-6) === idx);
            }

            sortPointsClockwise(points) {
                if (points.length < 3) return points;
                const cx = points.reduce((s,p) => s + p[0], 0) / points.length;
                const cy = points.reduce((s,p) => s + p[1], 0) / points.length;
                return points.sort((a,b) => Math.atan2(a[1]-cy, a[0]-cx) - Math.atan2(b[1]-cy, b[0]-cx));
            }

            evaluateObjective(point, obj) {
                return obj.px * point[0] + obj.py * point[1];
            }

            toFraction(decimal, tolerance = 1e-6) {
                // Handle integers
                if (Math.abs(decimal - Math.round(decimal)) < tolerance) {
                    return { numerator: Math.round(decimal), denominator: 1 };
                }

                // Handle negative numbers
                const sign = decimal < 0 ? -1 : 1;
                decimal = Math.abs(decimal);

                // Use continued fractions algorithm
                let numerator = 1;
                let denominator = 1;
                let bestNumerator = Math.round(decimal);
                let bestDenominator = 1;
                let bestError = Math.abs(decimal - bestNumerator);

                for (let d = 2; d <= 10000; d++) {
                    numerator = Math.round(decimal * d);
                    const error = Math.abs(decimal - numerator / d);

                    if (error < bestError) {
                        bestNumerator = numerator;
                        bestDenominator = d;
                        bestError = error;
                    }

                    if (error < tolerance) {
                        break;
                    }
                }

                // Simplify the fraction
                const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
                const divisor = gcd(bestNumerator, bestDenominator);

                return {
                    numerator: sign * (bestNumerator / divisor),
                    denominator: bestDenominator / divisor
                };
            }

            formatNumberAsLatex(num, useLatex = true) {
                const displayMode = document.getElementById('display-mode')?.value || 'decimal';

                if (displayMode === 'fraction') {
                    const frac = this.toFraction(num);
                    if (frac.denominator === 1) {
                        return useLatex ? frac.numerator.toString() : frac.numerator.toString();
                    } else {
                        return useLatex ? `\\frac{${frac.numerator}}{${frac.denominator}}` : `${frac.numerator}/${frac.denominator}`;
                    }
                } else {
                    // Decimal mode
                    if (Number.isInteger(num)) return num.toString();
                    return (Math.round(num * 100) / 100).toString();
                }
            }

            updateCornerPointsTable(cornerPoints, obj) {
                const tbody = document.querySelector('#corner-points-table tbody');
                tbody.innerHTML = '';
                if (cornerPoints.length === 0) {
                    tbody.innerHTML = `<tr><td colspan="3" style="text-align: center; color: #adb5bd; font-style: italic;">No corner points (unbounded or empty region)</td></tr>`;
                    return;
                }
                cornerPoints.forEach((p, i) => {
                    const val = this.evaluateObjective(p, obj);
                    const label = this.cornerLabels[i] || String.fromCharCode(65 + i);
                    const tr = document.createElement('tr');

                    // Create cells
                    const labelCell = document.createElement('td');
                    labelCell.className = 'corner-label';
                    labelCell.textContent = label;

                    const coordCell = document.createElement('td');
                    coordCell.className = 'corner-coordinates';
                    const xLatex = this.formatNumberAsLatex(p[0], true);
                    const yLatex = this.formatNumberAsLatex(p[1], true);
                    const coordLatex = `\\left(${xLatex}, ${yLatex}\\right)`;
                    try {
                        katex.render(coordLatex, coordCell, { throwOnError: false });
                    } catch (error) {
                        coordCell.textContent = `(${this.formatNumber(p[0])}, ${this.formatNumber(p[1])})`;
                    }

                    const valueCell = document.createElement('td');
                    valueCell.className = 'objective-value';
                    const valLatex = this.formatNumberAsLatex(val, true);
                    try {
                        katex.render(valLatex, valueCell, { throwOnError: false });
                    } catch (error) {
                        valueCell.textContent = this.formatNumber(val);
                    }

                    tr.appendChild(labelCell);
                    tr.appendChild(coordCell);
                    tr.appendChild(valueCell);
                    tbody.appendChild(tr);
                });
            }

            extendLineToEdges(ineq, bounds) {
                const extension = 0.5 * (bounds.xMax - bounds.xMin);
                const x1 = bounds.xMin - extension;
                const x2 = bounds.xMax + extension;
                let y1, y2;
                if (Math.abs(ineq.b) > 0.001) {
                    y1 = (ineq.c - ineq.a * x1) / ineq.b;
                    y2 = (ineq.c - ineq.a * x2) / ineq.b;
                } else {
                    return null;
                }
                return { x: [x1, x2], y: [y1, y2] };
            }

            updatePlot() {
                const inequalities = this.getInequalities();
                const objective = this.getObjective();
                this.updateInequalitiesDisplay(inequalities);
                const bounds = this.calculateBounds(inequalities);
                const rawCornerPoints = this.findCornerPoints(inequalities, bounds);
                const cornerPoints = this.sortPointsClockwise(rawCornerPoints);
                this.updateCornerPointsTable(cornerPoints, objective);

                const data = [];
                const isReverse = this.getShadingMode() === 'reverse';

                inequalities.forEach((ineq, i) => {
                    const isStrict = ineq.relation === '<' || ineq.relation === '>';
                    const dash = isStrict ? 'dash' : 'solid';
                    const rgb = this.hexToRgb(ineq.color);
                    const shadeColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.15)`;

                    // Line trace (over-extended)
                    if (Math.abs(ineq.b) > 0.001) {
                        const extended = this.extendLineToEdges(ineq, bounds);
                        if (extended) {
                            data.push({
                                x: extended.x,
                                y: extended.y,
                                mode: 'lines',
                                line: { color: ineq.color, width: 3, dash: dash },
                                showlegend: false,
                                hoverinfo: 'none'
                            });
                        }
                    } else if (Math.abs(ineq.a) > 0.001) {
                        const xVal = ineq.c / ineq.a;
                        data.push({
                            x: [xVal, xVal],
                            y: [bounds.yMin - 10, bounds.yMax + 10],
                            mode: 'lines',
                            line: { color: ineq.color, width: 3, dash: dash },
                            showlegend: false,
                            hoverinfo: 'none'
                        });
                    }

                    // Shading polygons
                    let x = [], y = [];
                    let shadeAbove = (ineq.relation === '≥' || ineq.relation === '>') && ineq.b > 0 ||
                                    (ineq.relation === '≤' || ineq.relation === '<') && ineq.b < 0;
                    if (isReverse) shadeAbove = !shadeAbove;

                    if (Math.abs(ineq.b) > 0.001) {
                        const yLeft = (ineq.c - ineq.a * bounds.xMin) / ineq.b;
                        const yRight = (ineq.c - ineq.a * bounds.xMax) / ineq.b;
                        if (shadeAbove) {
                            x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
                            y = [yLeft, yRight, bounds.yMax, bounds.yMax];
                        } else {
                            x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
                            y = [yLeft, yRight, bounds.yMin, bounds.yMin];
                        }
                    } else if (Math.abs(ineq.a) > 0.001) {
                        const xVal = ineq.c / ineq.a;
                        let shadeRight = (ineq.relation === '≥' || ineq.relation === '>') && ineq.a > 0 ||
                                        (ineq.relation === '≤' || ineq.relation === '<') && ineq.a < 0;
                        if (isReverse) shadeRight = !shadeRight;
                        if (shadeRight) {
                            x = [xVal, bounds.xMax, bounds.xMax, xVal];
                            y = [bounds.yMin, bounds.yMin, bounds.yMax, bounds.yMax];
                        } else {
                            x = [bounds.xMin, xVal, xVal, bounds.xMin];
                            y = [bounds.yMin, bounds.yMin, bounds.yMax, bounds.yMax];
                        }
                    } else {
                        return;
                    }

                    data.push({
                        x: x,
                        y: y,
                        fill: 'toself',
                        fillcolor: shadeColor,
                        line: { width: 0 },
                        mode: 'lines',
                        showlegend: false,
                        hoverinfo: 'none'
                    });
                });

                if (cornerPoints.length > 0) {
                    cornerPoints.forEach((point, i) => {
                        const label = this.cornerLabels[i] || String.fromCharCode(65 + i);
                        data.push({
                            x: [point[0]],
                            y: [point[1]],
                            mode: 'markers+text',
                            marker: { size: 14, color: '#2c3e50', line: { color: 'white', width: 3 } },
                            text: [label],
                            textposition: 'top center',
                            textfont: { size: 18, family: 'Arial', weight: 'bold', color: '#2c3e50' },
                            showlegend: false,
                            hoverinfo: 'none'
                        });
                    });
                }

                const layout = {
                    plot_bgcolor: 'white',
                    paper_bgcolor: 'white',
                    xaxis: {
                        title: { text: 'x', font: { size: 20 } },
                        range: [bounds.xMin, bounds.xMax],
                        showgrid: true,
                        gridcolor: 'rgba(220, 220, 220, 0.6)',
                        gridwidth: 1,
                        zeroline: true,
                        zerolinecolor: '#333',
                        zerolinewidth: 2,
                        showline: true,
                        linecolor: '#333',
                        linewidth: 2,
                        tickfont: { size: 16 }
                    },
                    yaxis: {
                        title: { text: 'y', font: { size: 20 } },
                        range: [bounds.yMin, bounds.yMax],
                        showgrid: true,
                        gridcolor: 'rgba(220, 220, 220, 0.6)',
                        gridwidth: 1,
                        zeroline: true,
                        zerolinecolor: '#333',
                        zerolinewidth: 2,
                        showline: true,
                        linecolor: '#333',
                        linewidth: 2,
                        scaleanchor: "x",
                        scaleratio: 1,
                        tickfont: { size: 16 }
                    },
                    margin: { l: 60, r: 30, t: 30, b: 60 },
                    hovermode: false,
                    dragmode: 'pan',
                    showlegend: false
                };

                const config = {
                    responsive: true,
                    displayModeBar: true,
                    displaylogo: false,
                    modeBarButtonsToRemove: ['lasso2d', 'select2d']
                };

                if (this.plotInitialized) {
                    Plotly.react('plot', data, layout, config);
                } else {
                    Plotly.newPlot('plot', data, layout, config);
                    this.plotInitialized = true;
                }
            }

            formatCoefficient(coeff, isY) {
                if (Math.abs(coeff) < 0.0001) return '0';
                if (Math.abs(coeff - 1) < 0.0001) return isY ? 'y' : 'x';
                if (Math.abs(coeff + 1) < 0.0001) return isY ? '-y' : '-x';
                const formatted = Number.isInteger(coeff) ? coeff.toString() : coeff.toFixed(2);
                return formatted + (isY ? 'y' : 'x');
            }

            formatNumber(num) {
                if (Number.isInteger(num)) return num.toString();
                return Math.round(num * 100) / 100;
            }

            getLatexRelation(relation) {
                switch (relation) {
                    case '<': return '\\lt';
                    case '>': return '\\gt';
                    case '≤': return '\\le';
                    case '≥': return '\\ge';
                    default: return relation;
                }
            }

            clearAll() {
                if (confirm('Clear all inequalities?')) {
                    document.getElementById('inequality-inputs').innerHTML = '';
                    document.getElementById('objective-function').value = '';
                    this.updatePlot();
                }
            }

            loadExample(exampleName) {
                const examples = {
                    'feasible-region': [
                        { lhs: "x", relation: '≥', rhs: 0 },
                        { lhs: "y", relation: '≥', rhs: 0 },
                        { lhs: "2x+y", relation: '≤', rhs: 10 },
                        { lhs: "x+2y", relation: '≤', rhs: 8 }
                    ],
                    'unbounded': [
                        { lhs: "x", relation: '≥', rhs: 0 },
                        { lhs: "y", relation: '≥', rhs: 0 },
                        { lhs: "2x+y", relation: '≥', rhs: 10 },
                        { lhs: "x+2y", relation: '≥', rhs: 8 }
                    ],
                    'single-halfplane': [
                        { lhs: "x+y", relation: '≥', rhs: 3 }
                    ]
                };
                const example = examples[exampleName];
                if (!example) return;

                const container = document.getElementById('inequality-inputs');
                container.innerHTML = '';
                example.forEach(ineqData => {
                    this.addInequality(ineqData);
                });

                if (exampleName === 'feasible-region') {
                    document.getElementById('objective-function').value = '3x+4y';
                } else if (exampleName === 'unbounded') {
                    document.getElementById('objective-function').value = 'x+y';
                } else {
                    document.getElementById('objective-function').value = '';
                }

                this.updatePlot();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new InequalityPlotter();
        });
    </script>
</body>
</html>

