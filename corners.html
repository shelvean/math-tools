
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Shelvean Kapita - Interactive Method of Corners for Linear Programming" />
  <meta name="keywords" content="Shelvean Kapita, Linear Programming, Method of Corners, Graphical Method" />
  <title>Linear Programming: Method of Corners</title>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-LEQE004C92"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-LEQE004C92');
  </script>

  <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,400;0,700;1,400;1,700&family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet" />

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f9fafb;
      min-height: 100vh;
      padding: 12px;
      font-size: 15px;
      line-height: 1.45;
    }

    h1 {
      text-align: center;
      color: #1f2937;
      margin: 12px 0 20px;
      font-size: 1.9rem;
      font-weight: 600;
    }

    header {
      background: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.07);
      position: sticky;
      top: 0;
      z-index: 90;
      padding: 10px 12px;
      margin-bottom: 14px;
    }

    .header-title {
      font-size: 1.9rem;
      font-weight: 700;
      text-align: center;
      margin-bottom: 6px;
    }
    .header-title a { color: #111827; text-decoration: none; }
    .header-title a:hover { color: #4f46e5; }

    nav ul {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 1.2rem;
      margin: 0;
      padding: 0;
      list-style: none;
      font-size: 0.95rem;
    }
    nav a {
      color: #4f46e5;
      font-weight: 600;
      text-decoration: none;
    }
    nav a:hover { color: #4338ca; }

    .container {
      max-width: 1600px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr 1fr 380px;
      grid-template-rows: auto 520px auto;
      gap: 14px;
    }

    .inequalities-display {
      grid-column: 1 / span 2;
      background: white;
      border-radius: 6px;
      padding: 10px 14px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
      border: 1px solid #e5e7eb;
      min-height: 48px;
      font-size: 15.5px;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }

    .plot-area {
      grid-column: 1 / span 2;
      grid-row: 2;
      background: white;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
      position: relative;
      min-height: 480px;
    }
    #plot { width: 100%; height: 100%; }

    .p-value-display {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.96);
      padding: 10px 24px;
      border-radius: 6px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.14);
      font-size: 1.38rem;
      font-weight: 700;
      color: #1f2937;
      z-index: 10;
      display: none;
      border: 2px solid #3b82f6;
      cursor: pointer;
    }
    .p-value-display.active { display: block; }
    .p-value-display.maximum {
      background: rgba(34,197,94,0.94);
      border-color: #16a34a;
      color: white;
      animation: pulse 0.6s ease-in-out;
    }
    @keyframes pulse { 0%,100% { transform: translateX(-50%) scale(1); } 50% { transform: translateX(-50%) scale(1.06); } }

    .right-panel {
      grid-column: 3;
      grid-row: 1 / span 3;
      background: white;
      border-radius: 8px;
      padding: 14px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
      display: flex;
      flex-direction: column;
      gap: 16px;
      font-size: 14.5px;
    }

    .panel-title {
      color: #1f2937;
      font-size: 1.12rem;
      font-weight: 600;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .example-btn {
      background: #f3f4f6;
      border: 1px solid #d1d5db;
      border-radius: 5px;
      padding: 10px 12px;
      cursor: pointer;
      text-align: left;
      transition: all 0.13s;
      font-size: 14px;
    }
    .example-btn:hover {
      background: #e5e7eb;
      border-color: #9ca3af;
    }
    .example-title { font-weight: 600; color: #1f2937; font-size: 15px; margin-bottom: 3px; }
    .example-desc  { color: #6b7280; font-size: 13px; line-height: 1.35; }

    .shading-controls, .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .action-btn {
      padding: 10px;
      border: none;
      border-radius: 5px;
      font-weight: 600;
      cursor: pointer;
      font-size: 14.5px;
      transition: all 0.14s;
    }
    #update-plot { background: #3b82f6; color: white; }
    #update-plot:hover { background: #2563eb; }
    #play-sweep { background: #8b5cf6; color: white; }
    #play-sweep:hover { background: #7c3aed; }
    #play-sweep:disabled { background: #d1d5db; cursor: not-allowed; }
    #clear-all {
      background: #f3f4f6;
      color: #4b5563;
      border: 1px solid #d1d5db;
    }
    #clear-all:hover { background: #e5e7eb; }

    .ineq-row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      background: #f3f4f6;
      border-radius: 5px;
      border: 1px solid #e5e7eb;
    }
    .lhs-input     { flex: 1; min-width: 0; padding: 8px; font-size: 14.5px; }
    .rhs-input     { width: 110px; padding: 8px; font-size: 14.5px; }
    .relation-select { width: 62px; padding: 8px; font-size: 14.5px; }
    .remove-btn {
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 4px;
      width: 30px;
      height: 30px;
      font-size: 18px;
      cursor: pointer;
    }
    .remove-btn:hover { background: #dc2626; }

    #add-inequality, #add-non-negativity {
      background: #10b981;
      color: white;
      border: none;
      border-radius: 5px;
      padding: 7px 14px;
      font-weight: 600;
      font-size: 13.5px;
      cursor: pointer;
    }
    #add-inequality:hover, #add-non-negativity:hover { background: #059669; }

    .corner-points-section table {
      font-size: 13.5px;
      width: 100%;
      border-collapse: collapse;
    }
    #corner-points-table th {
      background: #f3f4f6;
      padding: 8px 10px;
      text-align: left;
      font-weight: 600;
      border-bottom: 2px solid #e5e7eb;
    }
    #corner-points-table td {
      padding: 8px 10px;
      border-bottom: 1px solid #f3f4f6;
    }

    .input-section {
      grid-column: 1 / span 2;
      grid-row: 3;
      background: white;
      border-radius: 8px;
      padding: 14px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    .objective-input { width: 180px; padding: 8px; font-size: 15px; }

    @media (max-width: 1100px) {
      .container {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto auto;
        gap: 12px;
      }
      .right-panel { grid-column: 1; grid-row: 2; }
      .plot-area { grid-row: 3; min-height: 460px; }
      .input-section { grid-column: 1; grid-row: 4; grid-template-columns: 1fr; }
    }

    footer {
      text-align: center;
      padding: 1.5rem 1rem;
      color: #6b7280;
      font-size: 0.82rem;
      margin-top: 2rem;
      border-top: 1px solid #e5e7eb;
    }
  </style>
</head>
<body>

<header>
  <div class="max-w-6xl mx-auto">
    <h1 class="header-title"><a href="index.html">Shelvean Kapita</a></h1>
    <nav>
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="teaching.html">Teaching</a></li>
        <li><a href="projects.html">Diff Eq</a></li>
        <li><a href="linear.html">Linear Algebra</a></li>
        <li><a href="optim.html">Linear Programming</a></li>
        <li><a href="numerical.html">Numerical Methods</a></li>
      </ul>
    </nav>
  </div>
</header>

<h1>Linear Programming: Method of Corners</h1>

<div class="container">

  <div class="inequalities-display" id="inequalities-display">
    <span style="color:#9ca3af;">Add inequalities below</span>
  </div>

  <div class="plot-area">
    <div class="p-value-display" id="p-value-display">
      <span class="p-label">Objective Value:</span>
      <span id="p-value-text">P = 0</span>
    </div>
    <div id="plot"></div>
  </div>

  <div class="right-panel">

    <div class="panel-section">
      <div class="panel-title">Examples</div>
      <div class="example-list">
        <button class="example-btn" data-example="feasible-region">
          <div class="example-title">Bounded Region</div>
          <div class="example-desc">x ≥ 0, y ≥ 0, 2x + y ≤ 10, x + 2y ≤ 8<br>P = 3x + 4y</div>
        </button>
        <button class="example-btn" data-example="unbounded">
          <div class="example-title">Unbounded Region</div>
          <div class="example-desc">x ≥ 0, y ≥ 0, 2x + y ≥ 10, x + 2y ≥ 8<br>P = x + y</div>
        </button>
        <button class="example-btn" data-example="single-halfplane">
          <div class="example-title">Single Half-Plane</div>
          <div class="example-desc">x + y ≥ 3</div>
        </button>
      </div>
    </div>

    <div class="shading-controls">
      <div class="panel-title" style="font-size:16px;margin-bottom:6px;">Shading Mode</div>
      <label><input type="radio" name="shading-mode" value="true"> True shading</label>
      <label><input type="radio" name="shading-mode" value="reverse" checked> Reverse shading</label>
    </div>

    <div class="shading-controls">
      <div class="panel-title" style="font-size:16px;margin-bottom:6px;">Sweep Settings</div>
      <label>
        <span style="display:block; margin-bottom:4px; font-weight:600;">Optimization:</span>
        <select id="optimization-type" style="width:100%; padding:6px; font-size:14px;">
          <option value="maximize">Maximize</option>
          <option value="minimize">Minimize</option>
          <option value="auto">Auto-detect</option>
        </select>
      </label>
      <label>
        <span style="display:block; margin-bottom:4px; font-weight:600;">Speed:</span>
        <select id="animation-speed" style="width:100%; padding:6px; font-size:14px;">
          <option value="4000">Fast (4s)</option>
          <option value="7000" selected>Normal (7s)</option>
          <option value="11000">Slow (11s)</option>
        </select>
      </label>
    </div>

    <div class="controls">
      <button class="action-btn" id="update-plot">Update Plot</button>
      <button class="action-btn" id="play-sweep">▶ Play Sweep</button>
      <button class="action-btn" id="clear-all">Clear All</button>
    </div>

    <div class="corner-points-section">
      <div class="panel-title">Corner Points & Values</div>
      <table id="corner-points-table">
        <thead>
          <tr><th>Label</th><th>(x, y)</th><th>P</th></tr>
        </thead>
        <tbody>
          <tr><td colspan="3" style="text-align:center; color:#9ca3af; font-style:italic; padding:10px;">
            Corner points appear here for bounded regions
          </td></tr>
        </tbody>
      </table>
    </div>

  </div>

  <div class="input-section">

    <div class="constraints-section">
      <div class="input-header" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; flex-wrap:wrap;">
        <div class="panel-title" style="margin:0;">Constraints</div>
        <div style="display:flex; gap:8px;">
          <button id="add-inequality">+ Inequality</button>
          <button id="add-non-negativity">+ x,y ≥ 0</button>
        </div>
      </div>
      <div class="inequality-inputs" id="inequality-inputs"></div>
      <div style="color:#6b7280; font-size:13px; margin-top:8px; font-style:italic;">
        Examples: 2x+3y, x-y, y, 0.5x+2y, (1/2)x+(3/5)y
      </div>
    </div>

    <div class="objective-section">
      <div class="panel-title" style="margin-bottom:12px;">Objective Function</div>
      <div style="display:flex; align-items:center; gap:10px;">
        <span style="font-size:1.2rem; font-weight:600;">P =</span>
        <input type="text" class="objective-input" id="objective-function" placeholder="e.g. 3x+4y" value="3x+4y">
      </div>

      <div style="margin-top:16px;">
        <label for="display-mode" style="font-weight:600; display:block; margin-bottom:6px; color:#1f2937;">Coordinates format:</label>
        <select id="display-mode" style="width:100%; padding:7px; font-size:14px;">
          <option value="decimal">Decimals</option>
          <option value="fraction">Fractions</option>
        </select>
      </div>
    </div>

  </div>

</div>

<footer>
  <p>© <span id="current-year"></span> Shelvean Kapita. All rights reserved.</p>
  <p style="margin-top:6px;">MIT License</p>
  <p style="margin-top:8px; font-size:0.78rem; color:#9ca3af;">Last modified on January 15, 2026</p>
</footer>

<script>
document.getElementById('current-year').textContent = new Date().getFullYear();

class InequalityPlotter {
  constructor() {
    this.colors = ['#E41A1C', '#377EB8', '#4DAF4A', '#984EA3', '#FF7F00', '#A65628', '#F781BF', '#999999'];
    this.plotInitialized = false;
    this.cornerLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
    this.sweepAnimationRunning = false;
    this.sweepAnimationId = null;
    this.bindEvents();
    setTimeout(() => {
      this.updatePlot();
      this.loadExample('feasible-region');
    }, 100);
  }

  bindEvents() {
    document.getElementById('add-inequality').addEventListener('click', () => this.addInequality());
    document.getElementById('add-non-negativity').addEventListener('click', () => this.addNonNegativity());
    document.getElementById('update-plot').addEventListener('click', () => this.updatePlot());
    document.getElementById('play-sweep').addEventListener('click', () => this.playSweepAnimation());
    document.getElementById('clear-all').addEventListener('click', () => this.clearAll());
    document.getElementById('objective-function').addEventListener('input', () => this.updatePlot());

    setTimeout(() => {
      const displayModeSelect = document.getElementById('display-mode');
      if (displayModeSelect) {
        displayModeSelect.addEventListener('change', () => this.updatePlot());
      }
    }, 200);

    document.querySelectorAll('.example-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const example = e.currentTarget.dataset.example;
        this.loadExample(example);
      });
    });

    document.querySelectorAll('input[name="shading-mode"]').forEach(radio => {
      radio.addEventListener('change', () => this.updatePlot());
    });

    window.addEventListener('resize', () => {
      if (this.plotInitialized) {
        this.updatePlot();
      }
    });
  }

  addNonNegativity() {
    let hasX = false;
    document.querySelectorAll('.ineq-row').forEach(row => {
      const lhs = row.querySelector('.lhs-input').value.trim().toLowerCase();
      if (lhs === 'x') hasX = true;
    });
    if (!hasX) {
      this.addInequality({ lhs: "x", relation: '≥', rhs: 0 });
    }
    let hasY = false;
    document.querySelectorAll('.ineq-row').forEach(row => {
      const lhs = row.querySelector('.lhs-input').value.trim().toLowerCase();
      if (lhs === 'y') hasY = true;
    });
    if (!hasY) {
      this.addInequality({ lhs: "y", relation: '≥', rhs: 0 });
    }
    if (hasX && hasY) {
      alert('Non-negativity constraints x ≥ 0 and y ≥ 0 are already present.');
    }
  }

  getShadingMode() {
    const selected = document.querySelector('input[name="shading-mode"]:checked');
    return selected ? selected.value : 'reverse';
  }

  createInequalityRow(data = { lhs: "x", relation: '≥', rhs: 0 }) {
    const row = document.createElement('div');
    row.className = 'ineq-row';
    row.innerHTML = `
      <input type="text" class="lhs-input" placeholder="e.g., 2x+3y" value="${data.lhs}">
      <select class="relation-select">
        <option value="≤" ${data.relation === '≤' ? 'selected' : ''}>≤</option>
        <option value="≥" ${data.relation === '≥' ? 'selected' : ''}>≥</option>
        <option value="<" ${data.relation === '<' ? 'selected' : ''}>&lt;</option>
        <option value=">" ${data.relation === '>' ? 'selected' : ''}>&gt;</option>
      </select>
      <input type="text" class="rhs-input" placeholder="10 or 10/3" value="${data.rhs}">
      <button class="remove-btn" title="Remove">×</button>
    `;
    row.querySelector('.remove-btn').addEventListener('click', () => {
      row.remove();
      this.updatePlot();
    });
    row.querySelectorAll('input, select').forEach(el => {
      el.addEventListener('input', () => this.updatePlot());
      el.addEventListener('change', () => this.updatePlot());
    });
    return row;
  }

  addInequality(data) {
    const container = document.getElementById('inequality-inputs');
    const row = this.createInequalityRow(data);
    container.appendChild(row);
    this.updatePlot();
  }

  evaluateFraction(fractionStr) {
    const parts = fractionStr.split('/');
    if (parts.length === 2) {
      const numerator = parseFloat(parts[0]);
      const denominator = parseFloat(parts[1]);
      if (!isNaN(numerator) && !isNaN(denominator) && denominator !== 0) {
        return numerator / denominator;
      }
    }
    return parseFloat(fractionStr);
  }

  parseCoefficient(coeffStr) {
    if (coeffStr === '' || coeffStr === '+') return 1;
    if (coeffStr === '-') return -1;
    if (coeffStr.includes('/')) {
      coeffStr = coeffStr.replace(/[()]/g, '');
      return this.evaluateFraction(coeffStr);
    }
    return parseFloat(coeffStr);
  }

  parseLHS(lhsString) {
    let str = lhsString.replace(/\s+/g, '').toLowerCase();
    str = str.replace(/\*/g, '');
    let a = 0;
    let b = 0;
    if (str === '') return { a: 0, b: 0 };
    if (str === 'x') return { a: 1, b: 0 };
    if (str === 'y') return { a: 0, b: 1 };
    if (str === '-x') return { a: -1, b: 0 };
    if (str === '-y') return { a: 0, b: -1 };

    const xPatterns = [
      /(\([+-]?\d+\/\d+\))x/,
      /([+-]?\d*\.?\d*)x/
    ];
    for (const pattern of xPatterns) {
      const xMatch = str.match(pattern);
      if (xMatch) {
        const coeff = xMatch[1];
        a = this.parseCoefficient(coeff);
        str = str.replace(xMatch[0], '');
        break;
      }
    }

    const yPatterns = [
      /(\([+-]?\d+\/\d+\))y/,
      /([+-]?\d*\.?\d*)y/
    ];
    for (const pattern of yPatterns) {
      const yMatch = str.match(pattern);
      if (yMatch) {
        const coeff = yMatch[1];
        b = this.parseCoefficient(coeff);
        str = str.replace(yMatch[0], '');
        break;
      }
    }

    if (str !== '' && !isNaN(parseFloat(str))) {
      b = parseFloat(str);
    }

    if (isNaN(a)) a = 0;
    if (isNaN(b)) b = 0;
    return { a, b };
  }

  getInequalities() {
    const inequalities = [];
    const rows = document.querySelectorAll('.ineq-row');
    rows.forEach((row, i) => {
      const lhs = row.querySelector('.lhs-input').value || '';
      const relation = row.querySelector('.relation-select').value;
      const rhsString = row.querySelector('.rhs-input').value || '0';
      const rhs = this.evaluateFraction(rhsString);
      const coefficients = this.parseLHS(lhs);
      inequalities.push({
        a: coefficients.a,
        b: coefficients.b,
        c: rhs,
        relation: relation,
        color: this.colors[i % this.colors.length],
        lhsString: lhs,
        rhsString: rhsString.trim()
      });
    });
    return inequalities;
  }

  getObjective() {
    const expr = document.getElementById('objective-function').value.trim().toLowerCase() || '0';
    const coeffs = this.parseLHS(expr);
    return { px: coeffs.a, py: coeffs.b };
  }

  updateInequalitiesDisplay(inequalities) {
    const display = document.getElementById('inequalities-display');
    if (inequalities.length === 0) {
      display.innerHTML = '<span style="color: #adb5bd;">Add inequalities below</span>';
      return;
    }
    display.innerHTML = '';
    inequalities.forEach((ineq, i) => {
      const container = document.createElement('div');
      container.className = 'inequality-item';
      const latex = this.generateLatex(ineq, i);
      const latexSpan = document.createElement('span');
      latexSpan.className = 'inequality-katex';
      container.appendChild(latexSpan);
      try {
        katex.render(latex, latexSpan, { throwOnError: false });
      } catch (error) {
        latexSpan.textContent = `${this.formatLHS(ineq)} ${ineq.relation} ${ineq.c}`;
      }
      display.appendChild(container);
    });
  }

  formatRHSForLatex(rhsString, rhsValue) {
    if (rhsString.includes('/')) {
      const parts = rhsString.split('/');
      if (parts.length === 2) {
        const num = parts[0].trim();
        const den = parts[1].trim();
        if (!isNaN(parseFloat(num)) && !isNaN(parseFloat(den))) {
          return `\\dfrac{${num}}{${den}}`;
        }
      }
    }
    if (!Number.isInteger(rhsValue)) {
      const frac = this.toFraction(rhsValue);
      if (frac.denominator !== 1) {
        return `\\dfrac{${frac.numerator}}{${frac.denominator}}`;
      }
    }
    return this.formatNumber(rhsValue);
  }

  generateLatex(ineq, index) {
    const a = this.formatCoefficient(ineq.a, false);
    const b = this.formatCoefficient(ineq.b, true);
    const relation = this.getLatexRelation(ineq.relation);
    const c = this.formatRHSForLatex(ineq.rhsString, ineq.c);
    let latex = '';
    if (a === '0' && b === '0') {
      latex = `0 ${relation} ${c}`;
    } else if (a === '0') {
      latex = `${b} ${relation} ${c}`;
    } else if (b === '0') {
      latex = `${a} ${relation} ${c}`;
    } else {
      const bSign = ineq.b < 0 ? '-' : '+';
      const bAbs = this.formatCoefficient(Math.abs(ineq.b), true);
      latex = `${a} ${bSign} ${bAbs} ${relation} ${c}`;
    }
    return `\\color{${this.colors[index % this.colors.length]}}{${latex}}`;
  }

  formatLHS(ineq) {
    const a = this.formatCoefficient(ineq.a, false);
    const b = this.formatCoefficient(ineq.b, true);
    if (a === '0' && b === '0') return '0';
    if (a === '0') return b;
    if (b === '0') return a;
    const bSign = ineq.b < 0 ? '-' : '+';
    const bAbs = this.formatCoefficient(Math.abs(ineq.b), true);
    return `${a} ${bSign} ${bAbs}`;
  }

  hexToRgb(hex) {
    const bigint = parseInt(hex.slice(1), 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return { r, g, b };
  }

  calculateBounds(inequalities) {
    if (inequalities.length === 0) {
      return { xMin: -5, xMax: 5, yMin: -5, yMax: 5 };
    }
    let xMin = -10, xMax = 10, yMin = -10, yMax = 10;
    inequalities.forEach(ineq => {
      if (Math.abs(ineq.a) > 0.001) {
        const xInt = ineq.c / ineq.a;
        xMin = Math.min(xMin, xInt);
        xMax = Math.max(xMax, xInt);
      }
      if (Math.abs(ineq.b) > 0.001) {
        const yInt = ineq.c / ineq.b;
        yMin = Math.min(yMin, yInt);
        yMax = Math.max(yMax, yInt);
      }
    });
    const cornerPoints = this.findCornerPoints(inequalities, { xMin, xMax, yMin, yMax });
    const isBounded = cornerPoints.length > 0;
    let paddingFactor, minPadding;
    if (isBounded) {
      const xCoords = cornerPoints.map(p => p[0]);
      const yCoords = cornerPoints.map(p => p[1]);
      xMin = Math.min(...xCoords);
      xMax = Math.max(...xCoords);
      yMin = Math.min(...yCoords);
      yMax = Math.max(...yCoords);
      paddingFactor = 0.2;
      minPadding = 1;
    } else {
      paddingFactor = 0.4;
      minPadding = 4;
    }
    const rangeX = xMax - xMin || 10;
    const rangeY = yMax - yMin || 10;
    const padding = Math.max(rangeX * paddingFactor, rangeY * paddingFactor, minPadding);
    xMin -= padding;
    xMax += padding;
    yMin -= padding;
    yMax += padding;
    return { xMin, xMax, yMin, yMax };
  }

  intersectLines(ineq1, ineq2) {
    const det = ineq1.a * ineq2.b - ineq2.a * ineq1.b;
    if (Math.abs(det) < 1e-8) return null;
    const x = (ineq1.c * ineq2.b - ineq2.c * ineq1.b) / det;
    const y = (ineq1.a * ineq2.c - ineq2.a * ineq1.c) / det;
    return [x, y];
  }

  pointSatisfiesAll(point, inequalities) {
    const [x, y] = point;
    for (const ineq of inequalities) {
      const val = ineq.a * x + ineq.b * y;
      const tol = 1e-6;
      if ((ineq.relation === '≤' || ineq.relation === '<') && val > ineq.c + tol) return false;
      if ((ineq.relation === '≥' || ineq.relation === '>') && val < ineq.c - tol) return false;
    }
    return true;
  }

  findCornerPoints(inequalities, bounds) {
    if (inequalities.length < 2) return [];
    const points = [];
    for (let i = 0; i < inequalities.length; i++) {
      for (let j = i + 1; j < inequalities.length; j++) {
        const p = this.intersectLines(inequalities[i], inequalities[j]);
        if (p && this.pointSatisfiesAll(p, inequalities)) {
          points.push(p);
        }
      }
    }
    return points.filter((p, idx) => points.findIndex(q => Math.abs(q[0]-p[0])<1e-6 && Math.abs(q[1]-p[1])<1e-6) === idx);
  }

  sortPointsClockwise(points) {
    if (points.length < 3) return points;
    const cx = points.reduce((s,p) => s + p[0], 0) / points.length;
    const cy = points.reduce((s,p) => s + p[1], 0) / points.length;
    return points.sort((a,b) => Math.atan2(a[1]-cy, a[0]-cx) - Math.atan2(b[1]-cy, b[0]-cx));
  }

  evaluateObjective(point, obj) {
    return obj.px * point[0] + obj.py * point[1];
  }

  toFraction(decimal, tolerance = 1e-6) {
    if (Math.abs(decimal - Math.round(decimal)) < tolerance) {
      return { numerator: Math.round(decimal), denominator: 1 };
    }
    const sign = decimal < 0 ? -1 : 1;
    decimal = Math.abs(decimal);
    let numerator = 1;
    let denominator = 1;
    let bestNumerator = Math.round(decimal);
    let bestDenominator = 1;
    let bestError = Math.abs(decimal - bestNumerator);
    for (let d = 2; d <= 10000; d++) {
      numerator = Math.round(decimal * d);
      const error = Math.abs(decimal - numerator / d);
      if (error < bestError) {
        bestNumerator = numerator;
        bestDenominator = d;
        bestError = error;
      }
      if (error < tolerance) break;
    }
    const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
    const divisor = gcd(bestNumerator, bestDenominator);
    return {
      numerator: sign * (bestNumerator / divisor),
      denominator: bestDenominator / divisor
    };
  }

  formatNumberAsLatex(num, useLatex = true) {
    const displayMode = document.getElementById('display-mode')?.value || 'decimal';
    if (displayMode === 'fraction') {
      const frac = this.toFraction(num);
      if (frac.denominator === 1) {
        return useLatex ? frac.numerator.toString() : frac.numerator.toString();
      } else {
        return useLatex ? `\\dfrac{${frac.numerator}}{${frac.denominator}}` : `${frac.numerator}/${frac.denominator}`;
      }
    } else {
      if (Number.isInteger(num)) return num.toString();
      return (Math.round(num * 100) / 100).toString();
    }
  }

  isRegionUnbounded(inequalities) {
    let hasUpperX = false, hasLowerX = false, hasUpperY = false, hasLowerY = false;
    inequalities.forEach(ineq => {
      if (Math.abs(ineq.a - 1) < 0.001 && Math.abs(ineq.b) < 0.001 && (ineq.relation === '≤' || ineq.relation === '<')) {
        hasUpperX = true;
      }
      if (Math.abs(ineq.a - 1) < 0.001 && Math.abs(ineq.b) < 0.001 && (ineq.relation === '≥' || ineq.relation === '>')) {
        hasLowerX = true;
      }
      if (Math.abs(ineq.b - 1) < 0.001 && Math.abs(ineq.a) < 0.001 && (ineq.relation === '≤' || ineq.relation === '<')) {
        hasUpperY = true;
      }
      if (Math.abs(ineq.b - 1) < 0.001 && Math.abs(ineq.a) < 0.001 && (ineq.relation === '≥' || ineq.relation === '>')) {
        hasLowerY = true;
      }
    });
    return !(hasUpperX && hasLowerX && hasUpperY && hasLowerY);
  }

  hasMaximum(inequalities, objective) {
    const unbounded = this.isRegionUnbounded(inequalities);
    if (!unbounded) return true;
    const upperBounds = inequalities.filter(ineq => ineq.relation === '≤' || ineq.relation === '<').length;
    const lowerBounds = inequalities.filter(ineq => ineq.relation === '≥' || ineq.relation === '>').length;
    if (objective.px >= 0 && objective.py >= 0 && upperBounds > 0) return true;
    if (objective.px <= 0 && objective.py <= 0 && lowerBounds > 0) return true;
    return upperBounds > lowerBounds;
  }

  hasMinimum(inequalities, objective) {
    const unbounded = this.isRegionUnbounded(inequalities);
    if (!unbounded) return true;
    const upperBounds = inequalities.filter(ineq => ineq.relation === '≤' || ineq.relation === '<').length;
    const lowerBounds = inequalities.filter(ineq => ineq.relation === '≥' || ineq.relation === '>').length;
    if (objective.px >= 0 && objective.py >= 0 && lowerBounds > 0) return true;
    if (objective.px <= 0 && objective.py <= 0 && upperBounds > 0) return true;
    return lowerBounds > upperBounds;
  }

  updateCornerPointsTable(cornerPoints, obj) {
    const tbody = document.querySelector('#corner-points-table tbody');
    tbody.innerHTML = '';
    if (cornerPoints.length === 0) {
      tbody.innerHTML = `<tr><td colspan="3" style="text-align:center; color:#9ca3af; font-style:italic;">No corner points (unbounded or empty region)</td></tr>`;
      return;
    }
    const pValues = cornerPoints.map(p => this.evaluateObjective(p, obj));
    const minP = Math.min(...pValues);
    const maxP = Math.max(...pValues);
    const tolerance = 1e-6;
    const minIndices = pValues.map((v, i) => Math.abs(v - minP) < tolerance ? i : -1).filter(i => i >= 0);
    const maxIndices = pValues.map((v, i) => Math.abs(v - maxP) < tolerance ? i : -1).filter(i => i >= 0);
    cornerPoints.forEach((p, i) => {
      const val = this.evaluateObjective(p, obj);
      const label = this.cornerLabels[i] || String.fromCharCode(65 + i);
      const tr = document.createElement('tr');
      const isMin = minIndices.includes(i);
      const isMax = maxIndices.includes(i);
      if (isMin || isMax) {
        tr.style.backgroundColor = '#e8f5e9';
        tr.style.fontWeight = '600';
      }
      const labelCell = document.createElement('td');
      labelCell.className = 'corner-label';
      labelCell.textContent = label;
      const coordCell = document.createElement('td');
      coordCell.className = 'corner-coordinates';
      const xLatex = this.formatNumberAsLatex(p[0], true);
      const yLatex = this.formatNumberAsLatex(p[1], true);
      const coordLatex = `\\left(${xLatex}, ${yLatex}\\right)`;
      try {
        katex.render(coordLatex, coordCell, { throwOnError: false });
      } catch (error) {
        coordCell.textContent = `(${this.formatNumber(p[0])}, ${this.formatNumber(p[1])})`;
      }
      const valueCell = document.createElement('td');
      valueCell.className = 'objective-value';
      const valLatex = this.formatNumberAsLatex(val, true);
      try {
        katex.render(valLatex, valueCell, { throwOnError: false });
      } catch (error) {
        valueCell.textContent = this.formatNumber(val);
      }
      tr.appendChild(labelCell);
      tr.appendChild(coordCell);
      tr.appendChild(valueCell);
      tbody.appendChild(tr);
    });
    const inequalities = this.getInequalities();
    const hasMax = this.hasMaximum(inequalities, obj);
    const hasMin = this.hasMinimum(inequalities, obj);
    if (minIndices.length > 1 || maxIndices.length > 1 || !hasMax || !hasMin) {
      const tr = document.createElement('tr');
      tr.style.borderTop = '2px solid #2c3e50';
      tr.style.fontStyle = 'italic';
      const td = document.createElement('td');
      td.colSpan = 3;
      td.style.padding = '12px';
      td.style.textAlign = 'center';
      let msg = '';
      if (maxIndices.length > 1) {
        const labels = maxIndices.map(i => this.cornerLabels[i]).join(', ');
        msg += `<span style="color: #27ae60; font-weight: 600;">Maximum occurs along edge: ${labels}</span>`;
      }
      if (minIndices.length > 1) {
        const labels = minIndices.map(i => this.cornerLabels[i]).join(', ');
        if (msg) msg += '<br>';
        msg += `<span style="color: #27ae60; font-weight: 600;">Minimum occurs along edge: ${labels}</span>`;
      }
      if (!hasMax) {
        if (msg) msg += '<br>';
        msg += `<span style="color: #e74c3c; font-weight: 600;">⚠ No maximum (unbounded above)</span>`;
      }
      if (!hasMin) {
        if (msg) msg += '<br>';
        msg += `<span style="color: #e74c3c; font-weight: 600;">⚠ No minimum (unbounded below)</span>`;
      }
      td.innerHTML = msg;
      tr.appendChild(td);
      tbody.appendChild(tr);
    }
  }

  extendLineToEdges(ineq, bounds) {
    const extension = 0.5 * (bounds.xMax - bounds.xMin);
    const x1 = bounds.xMin - extension;
    const x2 = bounds.xMax + extension;
    let y1, y2;
    if (Math.abs(ineq.b) > 0.001) {
      y1 = (ineq.c - ineq.a * x1) / ineq.b;
      y2 = (ineq.c - ineq.a * x2) / ineq.b;
    } else {
      return null;
    }
    return { x: [x1, x2], y: [y1, y2] };
  }

  updatePlot() {
    const inequalities = this.getInequalities();
    const objective = this.getObjective();
    this.updateInequalitiesDisplay(inequalities);
    const bounds = this.calculateBounds(inequalities);
    const rawCornerPoints = this.findCornerPoints(inequalities, bounds);
    const cornerPoints = this.sortPointsClockwise(rawCornerPoints);
    this.updateCornerPointsTable(cornerPoints, objective);
    const data = [];
    const isReverse = this.getShadingMode() === 'reverse';
    inequalities.forEach((ineq, i) => {
      const isStrict = ineq.relation === '<' || ineq.relation === '>';
      const dash = isStrict ? 'dash' : 'solid';
      const rgb = this.hexToRgb(ineq.color);
      const shadeColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.15)`;
      if (Math.abs(ineq.b) > 0.001) {
        const extended = this.extendLineToEdges(ineq, bounds);
        if (extended) {
          data.push({
            x: extended.x,
            y: extended.y,
            mode: 'lines',
            line: { color: ineq.color, width: 3, dash: dash },
            showlegend: false,
            hoverinfo: 'none'
          });
        }
      } else if (Math.abs(ineq.a) > 0.001) {
        const xVal = ineq.c / ineq.a;
        data.push({
          x: [xVal, xVal],
          y: [bounds.yMin - 10, bounds.yMax + 10],
          mode: 'lines',
          line: { color: ineq.color, width: 3, dash: dash },
          showlegend: false,
          hoverinfo: 'none'
        });
      }
      let x = [], y = [];
      let shadeAbove = (ineq.relation === '≥' || ineq.relation === '>') && ineq.b > 0 ||
                       (ineq.relation === '≤' || ineq.relation === '<') && ineq.b < 0;
      if (isReverse) shadeAbove = !shadeAbove;
      if (Math.abs(ineq.b) > 0.001) {
        const yLeft = (ineq.c - ineq.a * bounds.xMin) / ineq.b;
        const yRight = (ineq.c - ineq.a * bounds.xMax) / ineq.b;
        if (shadeAbove) {
          x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
          y = [yLeft, yRight, bounds.yMax, bounds.yMax];
        } else {
          x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
          y = [yLeft, yRight, bounds.yMin, bounds.yMin];
        }
      } else if (Math.abs(ineq.a) > 0.001) {
        const xVal = ineq.c / ineq.a;
        let shadeRight = (ineq.relation === '≥' || ineq.relation === '>') && ineq.a > 0 ||
                         (ineq.relation === '≤' || ineq.relation === '<') && ineq.a < 0;
        if (isReverse) shadeRight = !shadeRight;
        if (shadeRight) {
          x = [xVal, bounds.xMax, bounds.xMax, xVal];
          y = [bounds.yMin, bounds.yMin, bounds.yMax, bounds.yMax];
        } else {
          x = [bounds.xMin, xVal, xVal, bounds.xMin];
          y = [bounds.yMin, bounds.yMin, bounds.yMax, bounds.yMax];
        }
      } else {
        return;
      }
      data.push({
        x: x,
        y: y,
        fill: 'toself',
        fillcolor: shadeColor,
        line: { width: 0 },
        mode: 'lines',
        showlegend: false,
        hoverinfo: 'none'
      });
    });
    if (cornerPoints.length > 0) {
      cornerPoints.forEach((point, i) => {
        const label = this.cornerLabels[i] || String.fromCharCode(65 + i);
        data.push({
          x: [point[0]],
          y: [point[1]],
          mode: 'markers+text',
          marker: { size: 14, color: '#2c3e50', line: { color: 'white', width: 3 } },
          text: [label],
          textposition: 'top center',
          textfont: { size: 18, family: 'Arial', weight: 'bold', color: '#2c3e50' },
          showlegend: false,
          hoverinfo: 'none'
        });
      });
    }
    const layout = {
      plot_bgcolor: 'white',
      paper_bgcolor: 'white',
      xaxis: {
        title: { text: 'x', font: { size: 20 } },
        range: [bounds.xMin, bounds.xMax],
        showgrid: true,
        gridcolor: 'rgba(220, 220, 220, 0.6)',
        gridwidth: 1,
        zeroline: true,
        zerolinecolor: '#333',
        zerolinewidth: 2,
        showline: true,
        linecolor: '#333',
        linewidth: 2,
        tickfont: { size: 16 }
      },
      yaxis: {
        title: { text: 'y', font: { size: 20 } },
        range: [bounds.yMin, bounds.yMax],
        showgrid: true,
        gridcolor: 'rgba(220, 220, 220, 0.6)',
        gridwidth: 1,
        zeroline: true,
        zerolinecolor: '#333',
        zerolinewidth: 2,
        showline: true,
        linecolor: '#333',
        linewidth: 2,
        scaleanchor: "x",
        scaleratio: 1,
        tickfont: { size: 16 }
      },
      margin: { l: 60, r: 30, t: 30, b: 60 },
      hovermode: false,
      dragmode: 'pan',
      showlegend: false
    };
    const config = {
      responsive: true,
      displayModeBar: true,
      displaylogo: false,
      modeBarButtonsToRemove: ['lasso2d', 'select2d']
    };
    if (this.plotInitialized) {
      Plotly.react('plot', data, layout, config);
    } else {
      Plotly.newPlot('plot', data, layout, config);
      this.plotInitialized = true;
    }
  }

  formatCoefficient(coeff, isY) {
    if (Math.abs(coeff) < 0.0001) return '0';
    if (Math.abs(coeff - 1) < 0.0001) return isY ? 'y' : 'x';
    if (Math.abs(coeff + 1) < 0.0001) return isY ? '-y' : '-x';
    const formatted = Number.isInteger(coeff) ? coeff.toString() : coeff.toFixed(2);
    return formatted + (isY ? 'y' : 'x');
  }

  formatNumber(num) {
    if (Number.isInteger(num)) return num.toString();
    return Math.round(num * 100) / 100;
  }

  getLatexRelation(relation) {
    switch (relation) {
      case '<': return '\\lt';
      case '>': return '\\gt';
      case '≤': return '\\le';
      case '≥': return '\\ge';
      default: return relation;
    }
  }

  clearAll() {
    if (confirm('Clear all inequalities?')) {
      document.getElementById('inequality-inputs').innerHTML = '';
      document.getElementById('objective-function').value = '';
      this.updatePlot();
    }
  }

  loadExample(exampleName) {
    const examples = {
      'feasible-region': [
        { lhs: "x", relation: '≥', rhs: 0 },
        { lhs: "y", relation: '≥', rhs: 0 },
        { lhs: "2x+y", relation: '≤', rhs: 10 },
        { lhs: "x+2y", relation: '≤', rhs: 8 }
      ],
      'unbounded': [
        { lhs: "x", relation: '≥', rhs: 0 },
        { lhs: "y", relation: '≥', rhs: 0 },
        { lhs: "2x+y", relation: '≥', rhs: 10 },
        { lhs: "x+2y", relation: '≥', rhs: 8 }
      ],
      'single-halfplane': [
        { lhs: "x+y", relation: '≥', rhs: 3 }
      ]
    };
    const example = examples[exampleName];
    if (!example) return;
    const container = document.getElementById('inequality-inputs');
    container.innerHTML = '';
    example.forEach(ineqData => {
      this.addInequality(ineqData);
    });
    if (exampleName === 'feasible-region') {
      document.getElementById('objective-function').value = '3x+4y';
    } else if (exampleName === 'unbounded') {
      document.getElementById('objective-function').value = 'x+y';
    } else {
      document.getElementById('objective-function').value = '';
    }
    this.updatePlot();
  }

  async playSweepAnimation() {
    const inequalities = this.getInequalities();
    const objective = this.getObjective();
    const bounds = this.calculateBounds(inequalities);
    const rawCornerPoints = this.findCornerPoints(inequalities, bounds);
    const cornerPoints = this.sortPointsClockwise(rawCornerPoints);

    if (cornerPoints.length === 0) {
      alert('No corner points found! Please ensure you have a bounded feasible region.');
      return;
    }
    if (objective.px === 0 && objective.py === 0) {
      alert('Please enter a valid objective function (e.g., 3x+4y)');
      return;
    }

    const optType = document.getElementById('optimization-type').value;
    let isMaximize = true;
    if (optType === 'auto') {
      const hasMax = this.hasMaximum(inequalities, objective);
      const hasMin = this.hasMinimum(inequalities, objective);
      if (!hasMax && !hasMin) {
        alert('Cannot determine optimization type. The region appears to be unbounded in both directions.');
        return;
      }
      isMaximize = hasMax;
    } else {
      isMaximize = optType === 'maximize';
    }

    if (isMaximize && !this.hasMaximum(inequalities, objective)) {
      alert('No maximum exists! The objective function is unbounded above for this feasible region.\n\nTry minimizing instead.');
      return;
    }
    if (!isMaximize && !this.hasMinimum(inequalities, objective)) {
      alert('No minimum exists! The objective function is unbounded below for this feasible region.\n\nTry maximizing instead.');
      return;
    }

    const button = document.getElementById('play-sweep');
    button.disabled = true;
    button.textContent = '⏸ Animation Running...';

    const pValues = cornerPoints.map(p => this.evaluateObjective(p, objective));
    const minP = Math.min(...pValues);
    const maxP = Math.max(...pValues);
    const optimalP = isMaximize ? maxP : minP;
    const tolerance = 1e-6;
    const optimalIndices = pValues.map((v, i) => Math.abs(v - optimalP) < tolerance ? i : -1).filter(i => i >= 0);

    const range = maxP - minP;
    const startP = isMaximize ? (minP - range * 0.3) : (maxP + range * 0.3);
    const endP = isMaximize ? (maxP + range * 0.1) : (minP - range * 0.1);

    const display = document.getElementById('p-value-display');
    display.classList.add('active');
    display.classList.remove('maximum');

    const duration = parseInt(document.getElementById('animation-speed').value) || 7000;
    const fps = 30;
    const frames = Math.floor(duration / 1000 * fps);
    let currentFrame = 0;

    const animate = () => {
      if (currentFrame >= frames) {
        display.classList.add('maximum');
        const optTypeStr = isMaximize ? 'Maximum' : 'Minimum';
        let message;
        if (optimalIndices.length === 1) {
          const optimalLabel = this.cornerLabels[optimalIndices[0]];
          const optimalPoint = cornerPoints[optimalIndices[0]];
          const xCoord = this.formatNumberAsLatex(optimalPoint[0], false);
          const yCoord = this.formatNumberAsLatex(optimalPoint[1], false);
          message = `<strong>${optTypeStr}: P = ${this.formatNumberAsLatex(optimalP, false)}</strong><br>`;
          message += `<strong>at point ${optimalLabel} (${xCoord}, ${yCoord})</strong><br>`;
          message += `<span style="color: rgba(255,255,255,0.8); font-size: 16px; margin-top: 8px; display: inline-block;">Click to close</span>`;
        } else {
          const labels = optimalIndices.map(i => this.cornerLabels[i]).join(', ');
          const coordsList = optimalIndices.map(i => {
            const pt = cornerPoints[i];
            const x = this.formatNumberAsLatex(pt[0], false);
            const y = this.formatNumberAsLatex(pt[1], false);
            return `${this.cornerLabels[i]}(${x}, ${y})`;
          }).join(', ');
          message = `<strong>${optTypeStr}: P = ${this.formatNumberAsLatex(optimalP, false)}</strong><br>`;
          message += `<strong>Along edge: ${coordsList}</strong><br>`;
          message += `<span style="color: rgba(255,255,255,0.8); font-size: 16px; margin-top: 8px; display: inline-block;">Click to close</span>`;
        }
        document.getElementById('p-value-text').innerHTML = message;

        button.disabled = false;
        button.textContent = '▶ Play Sweep Animation';

        const closeHandler = () => {
          display.classList.remove('active', 'maximum');
          this.updatePlot();
          display.removeEventListener('click', closeHandler);
        };
        display.addEventListener('click', closeHandler);
        return;
      }

      const t = currentFrame / frames;
      const easeT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      const currentP = startP + (endP - startP) * easeT;

      document.getElementById('p-value-text').textContent = `P = ${this.formatNumberAsLatex(currentP, false)}`;

      const atOptimal = isMaximize ? (currentP >= optimalP - range * 0.05) : (currentP <= optimalP + range * 0.05);
      if (atOptimal) {
        display.style.borderColor = '#f39c12';
        display.style.background = 'rgba(243, 156, 18, 0.95)';
        display.style.color = 'white';
      } else {
        display.style.borderColor = '#3498db';
        display.style.background = 'rgba(255, 255, 255, 0.95)';
        display.style.color = '#2c3e50';
      }

      const reachedOptimal = isMaximize ? (currentP >= optimalP) : (currentP <= optimalP);
      this.updatePlotWithSweepLine(currentP, objective, bounds, inequalities, cornerPoints, optimalIndices, reachedOptimal);

      currentFrame++;
      requestAnimationFrame(animate);
    };

    animate();
  }

  updatePlotWithSweepLine(pValue, objective, bounds, inequalities, cornerPoints, optimalIndices, atOptimal) {
    const data = [];
    const isReverse = this.getShadingMode() === 'reverse';

    inequalities.forEach((ineq, i) => {
      const isStrict = ineq.relation === '<' || ineq.relation === '>';
      const dash = isStrict ? 'dash' : 'solid';
      const rgb = this.hexToRgb(ineq.color);
      const shadeColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.15)`;

      if (Math.abs(ineq.b) > 0.001) {
        const extended = this.extendLineToEdges(ineq, bounds);
        if (extended) {
          data.push({
            x: extended.x,
            y: extended.y,
            mode: 'lines',
            line: { color: ineq.color, width: 3, dash: dash },
            showlegend: false,
            hoverinfo: 'none'
          });
        }
      } else if (Math.abs(ineq.a) > 0.001) {
        const xVal = ineq.c / ineq.a;
        data.push({
          x: [xVal, xVal],
          y: [bounds.yMin - 10, bounds.yMax + 10],
          mode: 'lines',
          line: { color: ineq.color, width: 3, dash: dash },
          showlegend: false,
          hoverinfo: 'none'
        });
      }

      let x = [], y = [];
      let shadeAbove = (ineq.relation === '≥' || ineq.relation === '>') && ineq.b > 0 ||
                       (ineq.relation === '≤' || ineq.relation === '<') && ineq.b < 0;
      if (isReverse) shadeAbove = !shadeAbove;

      if (Math.abs(ineq.b) > 0.001) {
        const yLeft = (ineq.c - ineq.a * bounds.xMin) / ineq.b;
        const yRight = (ineq.c - ineq.a * bounds.xMax) / ineq.b;
        if (shadeAbove) {
          x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
          y = [yLeft, yRight, bounds.yMax, bounds.yMax];
        } else {
          x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
          y = [yLeft, yRight, bounds.yMin, bounds.yMin];
        }
      } else if (Math.abs(ineq.a) > 0.001) {
        const xVal = ineq.c / ineq.a;
        let shadeRight = (ineq.relation === '≥' || ineq.relation === '>') && ineq.a > 0 ||
                         (ineq.relation === '≤' || ineq.relation === '<') && ineq.a < 0;
        if (isReverse) shadeRight = !shadeRight;
        if (shadeRight) {
          x = [xVal, bounds.xMax, bounds.xMax, xVal];
          y = [bounds.yMin, bounds.yMin, bounds.yMax, bounds.yMax];
        } else {
          x = [bounds.xMin, xVal, xVal, bounds.xMin];
          y = [bounds.yMin, bounds.yMin, bounds.yMax, bounds.yMax];
        }
      } else {
        return;
      }
      data.push({
        x: x,
        y: y,
        fill: 'toself',
        fillcolor: shadeColor,
        line: { width: 0 },
        mode: 'lines',
        showlegend: false,
        hoverinfo: 'none'
      });
    });

    if (Math.abs(objective.py) > 0.001) {
      const extension = 0.5 * (bounds.xMax - bounds.xMin);
      const x1 = bounds.xMin - extension;
      const x2 = bounds.xMax + extension;
      const y1 = (pValue - objective.px * x1) / objective.py;
      const y2 = (pValue - objective.px * x2) / objective.py;
      const lineColor = atOptimal ? '#27ae60' : '#e74c3c';
      const lineWidth = atOptimal ? 5 : 4;
      data.push({
        x: [x1, x2],
        y: [y1, y2],
        mode: 'lines',
        line: { color: lineColor, width: lineWidth, dash: 'dashdot' },
        name: 'Objective Line',
        showlegend: false,
        hoverinfo: 'none'
      });
    } else if (Math.abs(objective.px) > 0.001) {
      const xVal = pValue / objective.px;
      const lineColor = atOptimal ? '#27ae60' : '#e74c3c';
      const lineWidth = atOptimal ? 5 : 4;
      data.push({
        x: [xVal, xVal],
        y: [bounds.yMin - 10, bounds.yMax + 10],
        mode: 'lines',
        line: { color: lineColor, width: lineWidth, dash: 'dashdot' },
        name: 'Objective Line',
        showlegend: false,
        hoverinfo: 'none'
      });
    }

    if (atOptimal && optimalIndices.length > 1) {
      const sortedIndices = [...optimalIndices].sort((a, b) => a - b);
      for (let i = 0; i < sortedIndices.length - 1; i++) {
        const idx1 = sortedIndices[i];
        const idx2 = sortedIndices[i + 1];
        const areAdjacent = (idx2 - idx1 === 1) || (idx1 === 0 && idx2 === cornerPoints.length - 1);
        if (areAdjacent) {
          const p1 = cornerPoints[idx1];
          const p2 = cornerPoints[idx2];
          data.push({
            x: [p1[0], p2[0]],
            y: [p1[1], p2[1]],
            mode: 'lines',
            line: { color: '#27ae60', width: 6 },
            showlegend: false,
            hoverinfo: 'none'
          });
        }
      }
      if (sortedIndices.includes(0) && sortedIndices.includes(cornerPoints.length - 1)) {
        const p1 = cornerPoints[0];
        const p2 = cornerPoints[cornerPoints.length - 1];
        data.push({
          x: [p1[0], p2[0]],
          y: [p1[1], p2[1]],
          mode: 'lines',
          line: { color: '#27ae60', width: 6 },
          showlegend: false,
          hoverinfo: 'none'
        });
      }
    }

    if (cornerPoints.length > 0) {
      cornerPoints.forEach((point, i) => {
        const label = this.cornerLabels[i] || String.fromCharCode(65 + i);
        const isOptimalPoint = optimalIndices.includes(i) && atOptimal;
        data.push({
          x: [point[0]],
          y: [point[1]],
          mode: 'markers+text',
          marker: {
            size: isOptimalPoint ? 20 : 14,
            color: isOptimalPoint ? '#27ae60' : '#2c3e50',
            line: { color: 'white', width: 3 }
          },
          text: [label],
          textposition: 'top center',
          textfont: {
            size: isOptimalPoint ? 22 : 18,
            family: 'Arial',
            weight: 'bold',
            color: isOptimalPoint ? '#27ae60' : '#2c3e50'
          },
          showlegend: false,
          hoverinfo: 'none'
        });
      });
    }

    const layout = {
      plot_bgcolor: 'white',
      paper_bgcolor: 'white',
      xaxis: {
        title: { text: 'x', font: { size: 20 } },
        range: [bounds.xMin, bounds.xMax],
        showgrid: true,
        gridcolor: 'rgba(220, 220, 220, 0.6)',
        gridwidth: 1,
        zeroline: true,
        zerolinecolor: '#333',
        zerolinewidth: 2,
        showline: true,
        linecolor: '#333',
        linewidth: 2,
        tickfont: { size: 16 }
      },
      yaxis: {
        title: { text: 'y', font: { size: 20 } },
        range: [bounds.yMin, bounds.yMax],
        showgrid: true,
        gridcolor: 'rgba(220, 220, 220, 0.6)',
        gridwidth: 1,
        zeroline: true,
        zerolinecolor: '#333',
        zerolinewidth: 2,
        showline: true,
        linecolor: '#333',
        linewidth: 2,
        scaleanchor: "x",
        scaleratio: 1,
        tickfont: { size: 16 }
      },
      margin: { l: 60, r: 30, t: 30, b: 60 },
      hovermode: false,
      dragmode: 'pan',
      showlegend: false
    };

    const config = {
      responsive: true,
      displayModeBar: true,
      displaylogo: false,
      modeBarButtonsToRemove: ['lasso2d', 'select2d']
    };

    Plotly.react('plot', data, layout, config);
  }
}

document.addEventListener('DOMContentLoaded', () => {
  new InequalityPlotter();
});
</script>
</body>
</html>
