<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-LEQE004C92"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-LEQE004C92');
  </script>
  <title>Linear Programming: Method of Corners</title>
  <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    body { background: #f8f9fa; min-height: 100vh; padding: 20px; overflow-y: auto; font-size: 18px; /* Increased base font size */ }
    h1 { text-align: center; color: #2c3e50; margin-bottom: 24px; font-size: 32px; font-weight: 600; }
    .container { max-width: 1800px; margin: 0 auto; display: grid; grid-template-columns: 1fr 1fr 460px; grid-template-rows: auto 680px auto; gap: 18px; }
    .inequalities-display { grid-column: 1 / span 2; background: white; border-radius: 8px; padding: 16px 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border: 1px solid #e0e6ed; display: flex; align-items: center; justify-content: center; flex-wrap: wrap; gap: 14px; min-height: 60px; font-size: 20px; }
    .inequality-item { display: flex; align-items: center; gap: 8px; }
    .inequality-katex { font-size: 1.1em; }
    .plot-area { grid-column: 1 / span 2; grid-row: 2; background: white; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); position: relative; }
    #plot { width: 100%; height: 100%; }
    .right-panel { grid-column: 3; grid-row: 1 / span 3; background: white; border-radius: 10px; padding: 20px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); display: flex; flex-direction: column; gap: 24px; font-size: 17px; }
    .panel-section { flex: 1; }
    .panel-title { color: #2c3e50; font-size: 20px; font-weight: 600; margin-bottom: 14px; display: flex; align-items: center; gap: 10px; }
    .panel-title::before { content: "üìö"; font-size: 1.2em; }
    .shading-controls { display: flex; flex-direction: column; gap: 12px; padding: 14px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef; font-size: 17px; }
    .shading-controls label { font-size: 17px; cursor: pointer; }
    .example-list { display: flex; flex-direction: column; gap: 12px; }
    .example-btn { background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; padding: 14px; cursor: pointer; transition: all 0.2s; text-align: left; font-size: 16px; }
    .example-btn:hover { background: #e9ecef; border-color: #ccc; }
    .example-title { font-weight: 600; color: #2c3e50; font-size: 18px; margin-bottom: 4px; }
    .example-desc { color: #6c757d; font-size: 15px; line-height: 1.4; }
    .controls { display: flex; flex-direction: column; gap: 12px; }
    .action-btn { padding: 14px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 17px; transition: all 0.2s; }
    #update-plot { background: #3498db; color: white; }
    #update-plot:hover { background: #2980b9; }
    #clear-all { background: #f8f9fa; color: #495057; border: 1px solid #e9ecef; }
    #clear-all:hover { background: #e9ecef; }
    .corner-points-section { flex: 1; display: flex; flex-direction: column; }
    .corner-points-title { color: #2c3e50; font-size: 20px; font-weight: 600; margin-bottom: 14px; display: flex; align-items: center; gap: 10px; }
    .corner-points-title::before { content: "üìç"; font-size: 1.2em; }
    #corner-points-table { width: 100%; border-collapse: collapse; border-radius: 6px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); font-size: 16px; }
    #corner-points-table th { background: #f8f9fa; padding: 12px; text-align: left; font-weight: 600; color: #2c3e50; border-bottom: 2px solid #e9ecef; }
    #corner-points-table td { padding: 12px; border-bottom: 1px solid #e9ecef; }
    #corner-points-table tr:last-child td { border-bottom: none; }
    .corner-label { font-weight: 700; color: #2c3e50; }
    .corner-coordinates, .objective-value { font-family: monospace; color: #495057; }
    .input-section { grid-column: 1 / span 2; grid-row: 3; background: white; border-radius: 10px; padding: 20px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
    .constraints-section, .objective-section { display: flex; flex-direction: column; }
    .input-header { display: flex; align-items: center; gap: 12px; margin-bottom: 18px; flex-wrap: wrap; }
    .input-title { color: #2c3e50; font-size: 20px; font-weight: 600; }
    #add-inequality, #add-non-negativity { background: #2ecc71; color: white; border: none; border-radius: 5px; padding: 10px 18px; font-weight: 600; cursor: pointer; font-size: 16px; transition: background 0.2s; }
    #add-inequality:hover, #add-non-negativity:hover { background: #27ae60; }
    .inequality-inputs { display: flex; flex-direction: column; gap: 12px; }
    .ineq-row { display: flex; align-items: center; gap: 10px; padding: 10px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef; }
    .lhs-input, .rhs-input, .objective-input { padding: 10px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 17px; transition: border-color 0.2s; }
    .lhs-input { flex: 1; min-width: 0; }
    .rhs-input { width: 200px; }
    .objective-input { width: 240px; }
    .lhs-input:focus, .rhs-input:focus, .objective-input:focus { outline: none; border-color: #3498db; }
    .relation-select { width: 70px; padding: 10px; border: 1px solid #dee2e6; border-radius: 4px; background: white; cursor: pointer; font-size: 17px; }
    .remove-btn { background: #e74c3c; color: white; border: none; border-radius: 4px; width: 36px; height: 36px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 18px; transition: background 0.2s; flex-shrink: 0; }
    .remove-btn:hover { background: #c0392b; }
    .help-text { color: #6c757d; font-size: 15px; margin-top: 10px; font-style: italic; }
    .objective-row { display: flex; align-items: center; gap: 12px; }
    .objective-row span { font-size: 20px; font-weight: 600; }
    @media (max-width: 1200px) {
      body { padding: 15px; }
      .container { grid-template-columns: 1fr; grid-template-rows: auto auto auto auto; gap: 16px; }
      .right-panel { grid-column: 1; grid-row: 2; }
      .plot-area { grid-row: 3; height: 500px; }
      .input-section { grid-column: 1; grid-row: 4; grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <h1>Linear Programming: Method of Corners</h1>
  <div class="container">
    <div class="inequalities-display" id="inequalities-display">
      <span style="color: #adb5bd;">Add inequalities below</span>
    </div>
    <div class="plot-area">
      <div id="plot"></div>
    </div>
    <div class="right-panel">
      <div class="panel-section">
        <div class="panel-title">Examples</div>
        <div class="example-list">
          <button class="example-btn" data-example="feasible-region">
            <div class="example-title">Bounded Region</div>
            <div class="example-desc">x ‚â• 0, y ‚â• 0, 2x + y ‚â§ 10, x + 2y ‚â§ 8<br>P = 3x + 4y</div>
          </button>
          <button class="example-btn" data-example="unbounded">
            <div class="example-title">Unbounded Region</div>
            <div class="example-desc">x ‚â• 0, y ‚â• 0, 2x + y ‚â• 10, x + 2y ‚â• 8<br>P = x + y</div>
          </button>
          <button class="example-btn" data-example="single-halfplane">
            <div class="example-title">Single Half-Plane</div>
            <div class="example-desc">x + y ‚â• 3</div>
          </button>
        </div>
      </div>
      <div class="shading-controls">
        <div class="panel-title" style="margin-bottom:10px;font-size:18px;">Shading Mode</div>
        <label><input type="radio" name="shading-mode" value="true"> True Shading (feasible side)</label>
        <label><input type="radio" name="shading-mode" value="reverse" checked> Reverse Shading (infeasible side)</label>
      </div>
      <div class="controls">
        <button class="action-btn" id="update-plot">Update Plot</button>
        <button class="action-btn" id="clear-all">Clear All</button>
      </div>
      <div class="corner-points-section">
        <div class="corner-points-title">Corner Points & Objective Values</div>
        <table id="corner-points-table">
          <thead>
            <tr>
              <th>Label</th>
              <th>Coordinates (x, y)</th>
              <th>P Value</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td colspan="3" style="text-align: center; color: #adb5bd; font-style: italic;"> Corner points will appear here for bounded regions </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    <div class="input-section">
      <div class="constraints-section">
        <div class="input-header">
          <div class="input-title">Enter Constraints (Inequalities)</div>
          <div>
            <button id="add-inequality">+ Add Inequality</button>
            <button id="add-non-negativity">+ Add Non-Negativity</button>
          </div>
        </div>
        <div class="inequality-inputs" id="inequality-inputs"></div>
        <div class="help-text"> Examples: "2x+3y", "x-y", "y", "0.5x+2y" </div>
      </div>
      <div class="objective-section">
        <div class="input-header">
          <div class="input-title">Enter Objective Function</div>
        </div>
        <div class="objective-row">
          <span>P =</span>
          <input type="text" class="objective-input" id="objective-function" placeholder="e.g., 3x+4y" value="3x+4y">
        </div>
      </div>
    </div>
  </div>

  <script>
    class InequalityPlotter {
      constructor() {
        this.colors = [ '#E41A1C', '#377EB8', '#4DAF4A', '#984EA3', '#FF7F00', '#A65628', '#F781BF', '#999999' ];
        this.plotInitialized = false;
        this.cornerLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
        this.bindEvents();
        setTimeout(() => { this.updatePlot(); this.loadExample('feasible-region'); }, 100);
      }

      bindEvents() {
        document.getElementById('add-inequality').addEventListener('click', () => this.addInequality());
        document.getElementById('add-non-negativity').addEventListener('click', () => this.addNonNegativity());
        document.getElementById('update-plot').addEventListener('click', () => this.updatePlot());
        document.getElementById('clear-all').addEventListener('click', () => this.clearAll());
        document.getElementById('objective-function').addEventListener('input', () => this.updatePlot());
        document.querySelectorAll('.example-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const example = e.currentTarget.dataset.example;
            this.loadExample(example);
          });
        });
        document.querySelectorAll('input[name="shading-mode"]').forEach(radio => {
          radio.addEventListener('change', () => this.updatePlot());
        });
        window.addEventListener('resize', () => {
          if (this.plotInitialized) {
            this.updatePlot();
          }
        });
      }

      addNonNegativity() {
        let hasX = false;
        document.querySelectorAll('.ineq-row').forEach(row => {
          const lhs = row.querySelector('.lhs-input').value.trim().toLowerCase();
          if (lhs === 'x') hasX = true;
        });
        if (!hasX) {
          this.addInequality({ lhs: "x", relation: '‚â•', rhs: 0 });
        }
        let hasY = false;
        document.querySelectorAll('.ineq-row').forEach(row => {
          const lhs = row.querySelector('.lhs-input').value.trim().toLowerCase();
          if (lhs === 'y') hasY = true;
        });
        if (!hasY) {
          this.addInequality({ lhs: "y", relation: '‚â•', rhs: 0 });
        }
        if (hasX && hasY) {
          alert('Non-negativity constraints x ‚â• 0 and y ‚â• 0 are already present.');
        }
      }

      getShadingMode() {
        const selected = document.querySelector('input[name="shading-mode"]:checked');
        return selected ? selected.value : 'reverse';  // default to reverse if none selected
      }

      createInequalityRow(data = { lhs: "x", relation: '‚â•', rhs: 0 }) {
        const row = document.createElement('div');
        row.className = 'ineq-row';
        row.innerHTML = `
          <input type="text" class="lhs-input" placeholder="e.g., 2x+3y" value="${data.lhs}">
          <select class="relation-select">
            <option value="‚â§" ${data.relation === '‚â§' ? 'selected' : ''}>‚â§</option>
            <option value="‚â•" ${data.relation === '‚â•' ? 'selected' : ''}>‚â•</option>
            <option value="<" ${data.relation === '<' ? 'selected' : ''}>&lt;</option>
            <option value=">" ${data.relation === '>' ? 'selected' : ''}>&gt;</option>
          </select>
          <input type="number" class="rhs-input" placeholder="10" value="${data.rhs}" step="any">
          <button class="remove-btn" title="Remove">√ó</button>
        `;
        row.querySelector('.remove-btn').addEventListener('click', () => {
          row.remove();
          this.updatePlot();
        });
        row.querySelectorAll('input, select').forEach(el => {
          el.addEventListener('input', () => this.updatePlot());
          el.addEventListener('change', () => this.updatePlot());
        });
        return row;
      }

      addInequality(data) {
        const container = document.getElementById('inequality-inputs');
        const row = this.createInequalityRow(data);
        container.appendChild(row);
        this.updatePlot();
      }

      parseLHS(lhsString) {
        let str = lhsString.replace(/\s+/g, '').toLowerCase();
        str = str.replace(/\*/g, '');
        let a = 0;
        let b = 0;
        if (str === '') return { a: 0, b: 0 };
        if (str === 'x') return { a: 1, b: 0 };
        if (str === 'y') return { a: 0, b: 1 };
        if (str === '-x') return { a: -1, b: 0 };
        if (str === '-y') return { a: 0, b: -1 };

        const xMatch = str.match(/([+-]?\d*\.?\d*)x/);
        if (xMatch) {
          const coeff = xMatch[1];
          if (coeff === '' || coeff === '+') a = 1;
          else if (coeff === '-') a = -1;
          else a = parseFloat(coeff);
          str = str.replace(xMatch[0], '');
        }

        const yMatch = str.match(/([+-]?\d*\.?\d*)y/);
        if (yMatch) {
          const coeff = yMatch[1];
          if (coeff === '' || coeff === '+') b = 1;
          else if (coeff === '-') b = -1;
          else b = parseFloat(coeff);
        } else if (str !== '' && !isNaN(parseFloat(str))) {
          b = parseFloat(str);
        }

        if (isNaN(a)) a = 0;
        if (isNaN(b)) b = 0;
        return { a, b };
      }

      getInequalities() {
        const inequalities = [];
        const rows = document.querySelectorAll('.ineq-row');
        rows.forEach((row, i) => {
          const lhs = row.querySelector('.lhs-input').value || '';
          const relation = row.querySelector('.relation-select').value;
          const rhs = parseFloat(row.querySelector('.rhs-input').value) || 0;
          const coefficients = this.parseLHS(lhs);
          inequalities.push({
            a: coefficients.a,
            b: coefficients.b,
            c: rhs,
            relation: relation,
            color: this.colors[i % this.colors.length],
            lhsString: lhs
          });
        });
        return inequalities;
      }

      getObjective() {
        const expr = document.getElementById('objective-function').value.trim().toLowerCase() || '0';
        const coeffs = this.parseLHS(expr);
        return { px: coeffs.a, py: coeffs.b };
      }

      updateInequalitiesDisplay(inequalities) {
        const display = document.getElementById('inequalities-display');
        if (inequalities.length === 0) {
          display.innerHTML = '<span style="color: #adb5bd;">Add inequalities below</span>';
          return;
        }
        display.innerHTML = '';
        inequalities.forEach((ineq, i) => {
          const container = document.createElement('div');
          container.className = 'inequality-item';
          const latex = this.generateLatex(ineq, i);
          const latexSpan = document.createElement('span');
          latexSpan.className = 'inequality-katex';
          container.appendChild(latexSpan);
          try {
            katex.render(latex, latexSpan, { throwOnError: false });
          } catch (error) {
            latexSpan.textContent = `${this.formatLHS(ineq)} ${ineq.relation} ${ineq.c}`;
          }
          display.appendChild(container);
        });
      }

      generateLatex(ineq, index) {
        const a = this.formatCoefficient(ineq.a, false);
        const b = this.formatCoefficient(ineq.b, true);
        const relation = this.getLatexRelation(ineq.relation);
        const c = this.formatNumber(ineq.c);
        let latex = '';
        if (a === '0' && b === '0') {
          latex = `0 ${relation} ${c}`;
        } else if (a === '0') {
          latex = `${b} ${relation} ${c}`;
        } else if (b === '0') {
          latex = `${a} ${relation} ${c}`;
        } else {
          const bSign = ineq.b < 0 ? '-' : '+';
          const bAbs = this.formatCoefficient(Math.abs(ineq.b), true);
          latex = `${a} ${bSign} ${bAbs} ${relation} ${c}`;
        }
        return `\\color{${this.colors[index % this.colors.length]}}{${latex}}`;
      }

      formatLHS(ineq) {
        const a = this.formatCoefficient(ineq.a, false);
        const b = this.formatCoefficient(ineq.b, true);
        if (a === '0' && b === '0') return '0';
        if (a === '0') return b;
        if (b === '0') return a;
        const bSign = ineq.b < 0 ? '-' : '+';
        const bAbs = this.formatCoefficient(Math.abs(ineq.b), true);
        return `${a} ${bSign} ${bAbs}`;
      }

      hexToRgb(hex) {
        const bigint = parseInt(hex.slice(1), 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return { r, g, b };
      }

      calculateBounds(inequalities) {
        if (inequalities.length === 0) {
          return { xMin: -5, xMax: 5, yMin: -5, yMax: 5 };
        }
        let xMin = -10, xMax = 10, yMin = -10, yMax = 10;
        inequalities.forEach(ineq => {
          if (Math.abs(ineq.a) > 0.001) {
            const xInt = ineq.c / ineq.a;
            xMin = Math.min(xMin, xInt);
            xMax = Math.max(xMax, xInt);
          }
          if (Math.abs(ineq.b) > 0.001) {
            const yInt = ineq.c / ineq.b;
            yMin = Math.min(yMin, yInt);
            yMax = Math.max(yMax, yInt);
          }
        });
        const rangeX = xMax - xMin || 10;
        const rangeY = yMax - yMin || 10;
        const padding = Math.max(rangeX * 0.4, rangeY * 0.4, 4);
        xMin -= padding;
        xMax += padding;
        yMin -= padding;
        yMax += padding;
        return { xMin, xMax, yMin, yMax };
      }

      intersectLines(ineq1, ineq2) {
        const det = ineq1.a * ineq2.b - ineq2.a * ineq1.b;
        if (Math.abs(det) < 1e-8) return null;
        const x = (ineq1.c * ineq2.b - ineq2.c * ineq1.b) / det;
        const y = (ineq1.a * ineq2.c - ineq2.a * ineq1.c) / det;
        return [x, y];
      }

      pointSatisfiesAll(point, inequalities) {
        const [x, y] = point;
        for (const ineq of inequalities) {
          const val = ineq.a * x + ineq.b * y;
          const tol = 1e-6;
          if ((ineq.relation === '‚â§' || ineq.relation === '<') && val > ineq.c + tol) return false;
          if ((ineq.relation === '‚â•' || ineq.relation === '>') && val < ineq.c - tol) return false;
        }
        return true;
      }

      findCornerPoints(inequalities, bounds) {
        if (inequalities.length < 2) return [];
        const points = [];
        for (let i = 0; i < inequalities.length; i++) {
          for (let j = i + 1; j < inequalities.length; j++) {
            const p = this.intersectLines(inequalities[i], inequalities[j]);
            if (p && this.pointSatisfiesAll(p, inequalities)) {
              points.push(p);
            }
          }
        }
        return points.filter((p, idx) => points.findIndex(q => Math.abs(q[0]-p[0])<1e-6 && Math.abs(q[1]-p[1])<1e-6) === idx );
      }

      sortPointsClockwise(points) {
        if (points.length < 3) return points;
        const cx = points.reduce((s,p) => s + p[0], 0) / points.length;
        const cy = points.reduce((s,p) => s + p[1], 0) / points.length;
        return points.sort((a,b) => Math.atan2(a[1]-cy, a[0]-cx) - Math.atan2(b[1]-cy, b[0]-cx));
      }

      evaluateObjective(point, obj) {
        return obj.px * point[0] + obj.py * point[1];
      }

      updateCornerPointsTable(cornerPoints, obj) {
        const tbody = document.querySelector('#corner-points-table tbody');
        tbody.innerHTML = '';
        if (cornerPoints.length === 0) {
          tbody.innerHTML = `<tr><td colspan="3" style="text-align: center; color: #adb5bd; font-style: italic;">No corner points (unbounded or empty region)</td></tr>`;
          return;
        }
        cornerPoints.forEach((p, i) => {
          const val = this.evaluateObjective(p, obj);
          const label = this.cornerLabels[i] || String.fromCharCode(65 + i);
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td class="corner-label">${label}</td>
            <td class="corner-coordinates">(${this.formatNumber(p[0])}, ${this.formatNumber(p[1])})</td>
            <td class="objective-value">${this.formatNumber(val)}</td>
          `;
          tbody.appendChild(tr);
        });
      }

      extendLineToEdges(ineq, bounds) {
        const extension = 0.5 * (bounds.xMax - bounds.xMin);
        const x1 = bounds.xMin - extension;
        const x2 = bounds.xMax + extension;
        let y1, y2;
        if (Math.abs(ineq.b) > 0.001) {
          y1 = (ineq.c - ineq.a * x1) / ineq.b;
          y2 = (ineq.c - ineq.a * x2) / ineq.b;
        } else {
          return null;
        }
        return { x: [x1, x2], y: [y1, y2] };
      }

      updatePlot() {
        const inequalities = this.getInequalities();
        const objective = this.getObjective();
        this.updateInequalitiesDisplay(inequalities);
        const bounds = this.calculateBounds(inequalities);
        const rawCornerPoints = this.findCornerPoints(inequalities, bounds);
        const cornerPoints = this.sortPointsClockwise(rawCornerPoints);
        this.updateCornerPointsTable(cornerPoints, objective);

        const data = [];
        const isReverse = this.getShadingMode() === 'reverse';

        inequalities.forEach((ineq, i) => {
          const isStrict = ineq.relation === '<' || ineq.relation === '>';
          const dash = isStrict ? 'dash' : 'solid';
          const rgb = this.hexToRgb(ineq.color);
          const shadeColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.15)`;

          // Line trace (over-extended)
          if (Math.abs(ineq.b) > 0.001) {
            const extended = this.extendLineToEdges(ineq, bounds);
            if (extended) {
              data.push({
                x: extended.x,
                y: extended.y,
                mode: 'lines',
                line: { color: ineq.color, width: 3, dash: dash },
                showlegend: false,
                hoverinfo: 'none'
              });
            }
          } else if (Math.abs(ineq.a) > 0.001) {
            const xVal = ineq.c / ineq.a;
            data.push({
              x: [xVal, xVal],
              y: [bounds.yMin - 10, bounds.yMax + 10],
              mode: 'lines',
              line: { color: ineq.color, width: 3, dash: dash },
              showlegend: false,
              hoverinfo: 'none'
            });
          }

          // Shading polygons (always to plot edges)
          let x = [], y = [];
          let shadeAbove = (ineq.relation === '‚â•' || ineq.relation === '>') && ineq.b > 0 ||
                           (ineq.relation === '‚â§' || ineq.relation === '<') && ineq.b < 0;
          if (isReverse) shadeAbove = !shadeAbove;

          if (Math.abs(ineq.b) > 0.001) {
            const yLeft = (ineq.c - ineq.a * bounds.xMin) / ineq.b;
            const yRight = (ineq.c - ineq.a * bounds.xMax) / ineq.b;
            if (shadeAbove) {
              x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
              y = [yLeft, yRight, bounds.yMax, bounds.yMax];
            } else {
              x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
              y = [yLeft, yRight, bounds.yMin, bounds.yMin];
            }
          } else if (Math.abs(ineq.a) > 0.001) {
            const xVal = ineq.c / ineq.a;
            let shadeRight = (ineq.relation === '‚â•' || ineq.relation === '>') && ineq.a > 0 ||
                             (ineq.relation === '‚â§' || ineq.relation === '<') && ineq.a < 0;
            if (isReverse) shadeRight = !shadeRight;
            if (shadeRight) {
              x = [xVal, bounds.xMax, bounds.xMax, xVal];
              y = [bounds.yMin, bounds.yMin, bounds.yMax, bounds.yMax];
            } else {
              x = [bounds.xMin, xVal, xVal, bounds.xMin];
              y = [bounds.yMin, bounds.yMin, bounds.yMax, bounds.yMax];
            }
          } else {
            return;
          }

          data.push({
            x: x,
            y: y,
            fill: 'toself',
            fillcolor: shadeColor,
            line: { width: 0 },
            mode: 'lines',
            showlegend: false,
            hoverinfo: 'none'
          });
        });

        if (cornerPoints.length > 0) {
          cornerPoints.forEach((point, i) => {
            const label = this.cornerLabels[i] || String.fromCharCode(65 + i);
            data.push({
              x: [point[0]],
              y: [point[1]],
              mode: 'markers+text',
              marker: { size: 14, color: '#2c3e50', line: { color: 'white', width: 3 } },
              text: [label],
              textposition: 'top center',
              textfont: { size: 18, family: 'Arial', weight: 'bold', color: '#2c3e50' },
              showlegend: false,
              hoverinfo: 'none'
            });
          });
        }

        const layout = {
          plot_bgcolor: 'white',
          paper_bgcolor: 'white',
          xaxis: {
            title: { text: 'x', font: { size: 20 } },
            range: [bounds.xMin, bounds.xMax],
            showgrid: true,
            gridcolor: 'rgba(220, 220, 220, 0.6)',
            gridwidth: 1,
            zeroline: true,
            zerolinecolor: '#333',
            zerolinewidth: 2,
            showline: true,
            linecolor: '#333',
            linewidth: 2,
            tickfont: { size: 16 }
          },
          yaxis: {
            title: { text: 'y', font: { size: 20 } },
            range: [bounds.yMin, bounds.yMax],
            showgrid: true,
            gridcolor: 'rgba(220, 220, 220, 0.6)',
            gridwidth: 1,
            zeroline: true,
            zerolinecolor: '#333',
            zerolinewidth: 2,
            showline: true,
            linecolor: '#333',
            linewidth: 2,
            scaleanchor: "x",
            scaleratio: 1,
            tickfont: { size: 16 }
          },
          margin: { l: 60, r: 30, t: 30, b: 60 },
          hovermode: false,
          dragmode: 'pan',
          showlegend: false
        };

        const config = {
          responsive: true,
          displayModeBar: true,
          displaylogo: false,
          modeBarButtonsToRemove: ['lasso2d', 'select2d']
        };

        if (this.plotInitialized) {
          Plotly.react('plot', data, layout, config);
        } else {
          Plotly.newPlot('plot', data, layout, config);
          this.plotInitialized = true;
        }
      }

      formatCoefficient(coeff, isY) {
        if (Math.abs(coeff) < 0.0001) return '0';
        if (Math.abs(coeff - 1) < 0.0001) return isY ? 'y' : 'x';
        if (Math.abs(coeff + 1) < 0.0001) return isY ? '-y' : '-x';
        const formatted = Number.isInteger(coeff) ? coeff.toString() : coeff.toFixed(2);
        return formatted + (isY ? 'y' : 'x');
      }

      formatNumber(num) {
        if (Number.isInteger(num)) return num.toString();
        return Math.round(num * 100) / 100;
      }

      getLatexRelation(relation) {
        switch (relation) {
          case '<': return '\\lt';
          case '>': return '\\gt';
          case '‚â§': return '\\le';
          case '‚â•': return '\\ge';
          default: return relation;
        }
      }

      clearAll() {
        if (confirm('Clear all inequalities?')) {
          document.getElementById('inequality-inputs').innerHTML = '';
          document.getElementById('objective-function').value = '';
          this.updatePlot();
        }
      }

      loadExample(exampleName) {
        const examples = {
          'feasible-region': [
            { lhs: "x", relation: '‚â•', rhs: 0 },
            { lhs: "y", relation: '‚â•', rhs: 0 },
            { lhs: "2x+y", relation: '‚â§', rhs: 10 },
            { lhs: "x+2y", relation: '‚â§', rhs: 8 }
          ],
          'unbounded': [
            { lhs: "x", relation: '‚â•', rhs: 0 },
            { lhs: "y", relation: '‚â•', rhs: 0 },
            { lhs: "2x+y", relation: '‚â•', rhs: 10 },
            { lhs: "x+2y", relation: '‚â•', rhs: 8 }
          ],
          'single-halfplane': [
            { lhs: "x+y", relation: '‚â•', rhs: 3 }
          ]
        };
        const example = examples[exampleName];
        if (!example) return;
        const container = document.getElementById('inequality-inputs');
        container.innerHTML = '';
        example.forEach(ineqData => {
          this.addInequality(ineqData);
        });
        if (exampleName === 'feasible-region') {
          document.getElementById('objective-function').value = '3x+4y';
        } else if (exampleName === 'unbounded') {
          document.getElementById('objective-function').value = 'x+y';
        } else {
          document.getElementById('objective-function').value = '';
        }
        this.updatePlot();
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      new InequalityPlotter();
    });
  </script>
</body>
</html>
