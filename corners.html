<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linear Programming: Method of Corners</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
     
        body {
            background: #f8f9fa;
            min-height: 100vh;
            padding: 15px;
            overflow-y: auto;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: 600;
        }
     
        .container {
            max-width: 1600px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr 400px;
            grid-template-rows: auto 600px auto;
            gap: 15px;
        }
     
        .inequalities-display {
            grid-column: 1 / span 2;
            background: white;
            border-radius: 6px;
            padding: 10px 15px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border: 1px solid #e0e6ed;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 50px;
        }
     
        .inequality-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
     
        .inequality-katex {
            font-size: 1em;
        }
     
        .plot-area {
            grid-column: 1 / span 2;
            grid-row: 2;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            position: relative;
        }
     
        #plot {
            width: 100%;
            height: 100%;
        }
     
        .right-panel {
            grid-column: 3;
            grid-row: 1 / span 3;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
     
        .panel-section {
            flex: 1;
        }
     
        .panel-title {
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
     
        .panel-title::before {
            content: "üìö";
        }
     
        .shading-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e9ecef;
        }
     
        .shading-controls label {
            font-size: 13px;
            cursor: pointer;
        }
     
        .example-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
     
        .example-btn {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }
     
        .example-btn:hover {
            background: #e9ecef;
            border-color: #ccc;
        }
     
        .example-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 13px;
            margin-bottom: 3px;
        }
     
        .example-desc {
            color: #6c757d;
            font-size: 11px;
            line-height: 1.3;
        }
     
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
     
        .action-btn {
            padding: 10px;
            border: none;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
     
        #update-plot {
            background: #3498db;
            color: white;
        }
     
        #update-plot:hover {
            background: #2980b9;
        }
     
        #clear-all {
            background: #f8f9fa;
            color: #495057;
            border: 1px solid #e9ecef;
        }
     
        #clear-all:hover {
            background: #e9ecef;
        }
     
        .corner-points-section {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
     
        .corner-points-title {
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
     
        .corner-points-title::before {
            content: "üìç";
        }
     
        #corner-points-table {
            width: 100%;
            border-collapse: collapse;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
     
        #corner-points-table th {
            background: #f8f9fa;
            padding: 10px;
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            border-bottom: 2px solid #e9ecef;
        }
     
        #corner-points-table td {
            padding: 10px;
            border-bottom: 1px solid #e9ecef;
            font-size: 13px;
        }
     
        #corner-points-table tr:last-child td {
            border-bottom: none;
        }
     
        .corner-label {
            font-weight: 700;
            color: #2c3e50;
        }
     
        .corner-coordinates, .objective-value {
            font-family: monospace;
            color: #495057;
        }
     
        .input-section {
            grid-column: 1 / span 2;
            grid-row: 3;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .constraints-section, .objective-section {
            display: flex;
            flex-direction: column;
        }
     
        .input-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
     
        .input-title {
            color: #2c3e50;
            font-size: 16px;
            font-weight: 600;
        }
     
        #add-inequality, #add-non-negativity {
            background: #2ecc71;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            font-weight: 600;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
     
        #add-inequality:hover, #add-non-negativity:hover {
            background: #27ae60;
        }
     
        .inequality-inputs {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
     
        .ineq-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e9ecef;
        }
     
        .lhs-input, .rhs-input, .objective-input {
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            font-size: 13px;
            transition: border-color 0.2s;
            width: 180px;
        }
     
        .lhs-input {
            flex: 1;
            min-width: 0;
            max-width: none;
        }
     
        .rhs-input {
            width: 180px;
        }
     
        .objective-input {
            width: 180px;
        }
     
        .lhs-input:focus, .rhs-input:focus, .objective-input:focus {
            outline: none;
            border-color: #3498db;
        }
     
        .relation-select {
            width: 60px;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            background: white;
            cursor: pointer;
            font-size: 13px;
        }
     
        .remove-btn {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 3px;
            width: 30px;
            height: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: background 0.2s;
            flex-shrink: 0;
        }
     
        .remove-btn:hover {
            background: #c0392b;
        }
     
        .help-text {
            color: #6c757d;
            font-size: 12px;
            margin-top: 8px;
            font-style: italic;
        }

        .objective-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
     
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto auto;
            }
         
            .right-panel {
                grid-column: 1;
                grid-row: 2;
            }
         
            .plot-area {
                grid-row: 3;
                height: 400px;
            }
         
            .input-section {
                grid-column: 1;
                grid-row: 4;
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1>Linear Programming: Method of Corners</h1>
    <div class="container">
        <div class="inequalities-display" id="inequalities-display">
            <span style="color: #adb5bd; font-size: 13px;">Add inequalities below</span>
        </div>
     
        <div class="plot-area">
            <div id="plot"></div>
        </div>
     
        <div class="right-panel">
            <div class="panel-section">
                <div class="panel-title">Examples</div>
                <div class="example-list">
                    <button class="example-btn" data-example="feasible-region">
                        <div class="example-title">Bounded Region</div>
                        <div class="example-desc">x ‚â• 0, y ‚â• 0, 2x + y ‚â§ 10, x + 2y ‚â§ 8<br>P = 3x + 4y</div>
                    </button>
                 
                    <button class="example-btn" data-example="unbounded">
                        <div class="example-title">Unbounded Region</div>
                        <div class="example-desc">x ‚â• 0, y ‚â• 0, 2x + y ‚â• 10, x + 2y ‚â• 8<br>P = x + y</div>
                    </button>
                 
                    <button class="example-btn" data-example="single-halfplane">
                        <div class="example-title">Single Half-Plane</div>
                        <div class="example-desc">x + y ‚â• 3</div>
                    </button>
                </div>
            </div>
         
            <div class="shading-controls">
                <div class="panel-title" style="margin-bottom:8px;font-size:14px;">Shading Mode</div>
                <label><input type="radio" name="shading-mode" value="true" checked> True Shading (feasible side)</label>
                <label><input type="radio" name="shading-mode" value="reverse"> Reverse Shading (infeasible side)</label>
            </div>
         
            <div class="controls">
                <button class="action-btn" id="update-plot">Update Plot</button>
                <button class="action-btn" id="clear-all">Clear All</button>
            </div>
         
            <div class="corner-points-section">
                <div class="corner-points-title">Corner Points & Objective Values</div>
                <table id="corner-points-table">
                    <thead>
                        <tr>
                            <th>Label</th>
                            <th>Coordinates (x, y)</th>
                            <th>P Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td colspan="3" style="text-align: center; color: #adb5bd; font-style: italic;">
                                Corner points will appear here for bounded regions
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
     
        <div class="input-section">
            <div class="constraints-section">
                <div class="input-header">
                    <div class="input-title">Enter Constraints (Inequalities)</div>
                    <div>
                        <button id="add-inequality">+ Add Inequality</button>
                        <button id="add-non-negativity">+ Add Non-Negativity</button>
                    </div>
                </div>
                <div class="inequality-inputs" id="inequality-inputs"></div>
                <div class="help-text">
                    Examples: "2x+3y", "x-y", "y", "0.5x+2y"
                </div>
            </div>

            <div class="objective-section">
                <div class="input-header">
                    <div class="input-title">Enter Objective Function</div>
                </div>
                <div class="objective-row">
                    <span style="font-weight:600;">P =</span>
                    <input type="text" class="objective-input" id="objective-function" placeholder="e.g., 3x+4y" value="3x+4y">
                </div>
            </div>
        </div>
    </div>
    <script>
        class InequalityPlotter {
            constructor() {
                this.colors = [
                    '#E41A1C', '#377EB8', '#4DAF4A', '#984EA3', '#FF7F00',
                    '#A65628', '#F781BF', '#999999'
                ];
                this.plotInitialized = false;
                this.cornerLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
             
                this.bindEvents();
             
                setTimeout(() => {
                    this.updatePlot();
                    this.loadExample('feasible-region');
                }, 100);
            }
         
            bindEvents() {
                document.getElementById('add-inequality').addEventListener('click', () => this.addInequality());
                document.getElementById('add-non-negativity').addEventListener('click', () => this.addNonNegativity());
                document.getElementById('update-plot').addEventListener('click', () => this.updatePlot());
                document.getElementById('clear-all').addEventListener('click', () => this.clearAll());
                document.getElementById('objective-function').addEventListener('input', () => this.updatePlot());
             
                document.querySelectorAll('.example-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const example = e.currentTarget.dataset.example;
                        this.loadExample(example);
                    });
                });
             
                document.querySelectorAll('input[name="shading-mode"]').forEach(radio => {
                    radio.addEventListener('change', () => this.updatePlot());
                });
             
                window.addEventListener('resize', () => {
                    if (this.plotInitialized) {
                        this.updatePlot();
                    }
                });
            }
         
            addNonNegativity() {
                // Add x ‚â• 0 if not already present
                let hasX = false;
                document.querySelectorAll('.ineq-row').forEach(row => {
                    const lhs = row.querySelector('.lhs-input').value.trim().toLowerCase();
                    if (lhs === 'x') hasX = true;
                });
                if (!hasX) {
                    this.addInequality({ lhs: "x", relation: '‚â•', rhs: 0 });
                }

                // Add y ‚â• 0 if not already present
                let hasY = false;
                document.querySelectorAll('.ineq-row').forEach(row => {
                    const lhs = row.querySelector('.lhs-input').value.trim().toLowerCase();
                    if (lhs === 'y') hasY = true;
                });
                if (!hasY) {
                    this.addInequality({ lhs: "y", relation: '‚â•', rhs: 0 });
                }

                if (hasX && hasY) {
                    alert('Non-negativity constraints x ‚â• 0 and y ‚â• 0 are already present.');
                }
            }
         
            getShadingMode() {
                const selected = document.querySelector('input[name="shading-mode"]:checked');
                return selected ? selected.value : 'true';
            }
         
            createInequalityRow(data = { lhs: "x", relation: '‚â•', rhs: 0 }) {
                const row = document.createElement('div');
                row.className = 'ineq-row';
             
                row.innerHTML = `
                    <input type="text" class="lhs-input" placeholder="e.g., 2x+3y" value="${data.lhs}">
                    <select class="relation-select">
                        <option value="‚â§" ${data.relation === '‚â§' ? 'selected' : ''}>‚â§</option>
                        <option value="‚â•" ${data.relation === '‚â•' ? 'selected' : ''}>‚â•</option>
                        <option value="<" ${data.relation === '<' ? 'selected' : ''}>&lt;</option>
                        <option value=">" ${data.relation === '>' ? 'selected' : ''}>&gt;</option>
                    </select>
                    <input type="number" class="rhs-input" placeholder="10" value="${data.rhs}" step="any">
                    <button class="remove-btn" title="Remove">√ó</button>
                `;
             
                row.querySelector('.remove-btn').addEventListener('click', () => {
                    row.remove();
                    this.updatePlot();
                });
             
                row.querySelectorAll('input, select').forEach(el => {
                    el.addEventListener('input', () => this.updatePlot());
                    el.addEventListener('change', () => this.updatePlot());
                });
             
                return row;
            }
         
            addInequality(data) {
                const container = document.getElementById('inequality-inputs');
                const row = this.createInequalityRow(data);
                container.appendChild(row);
                this.updatePlot();
            }
         
            parseLHS(lhsString) {
                let str = lhsString.replace(/\s+/g, '').toLowerCase();
                str = str.replace(/\*/g, '');
             
                let a = 0;
                let b = 0;
             
                if (str === '') return { a: 0, b: 0 };
                if (str === 'x') return { a: 1, b: 0 };
                if (str === 'y') return { a: 0, b: 1 };
                if (str === '-x') return { a: -1, b: 0 };
                if (str === '-y') return { a: 0, b: -1 };
             
                const xMatch = str.match(/([+-]?\d*\.?\d*)x/);
                if (xMatch) {
                    const coeff = xMatch[1];
                    if (coeff === '' || coeff === '+') a = 1;
                    else if (coeff === '-') a = -1;
                    else a = parseFloat(coeff);
                    str = str.replace(xMatch[0], '');
                }
             
                const yMatch = str.match(/([+-]?\d*\.?\d*)y/);
                if (yMatch) {
                    const coeff = yMatch[1];
                    if (coeff === '' || coeff === '+') b = 1;
                    else if (coeff === '-') b = -1;
                    else b = parseFloat(coeff);
                } else if (str !== '' && !isNaN(parseFloat(str))) {
                    b = parseFloat(str);
                }
             
                if (isNaN(a)) a = 0;
                if (isNaN(b)) b = 0;
             
                return { a, b };
            }
         
            getInequalities() {
                const inequalities = [];
                const rows = document.querySelectorAll('.ineq-row');
             
                rows.forEach((row, i) => {
                    const lhs = row.querySelector('.lhs-input').value || '';
                    const relation = row.querySelector('.relation-select').value;
                    const rhs = parseFloat(row.querySelector('.rhs-input').value) || 0;
                 
                    const coefficients = this.parseLHS(lhs);
                 
                    inequalities.push({
                        a: coefficients.a,
                        b: coefficients.b,
                        c: rhs,
                        relation: relation,
                        color: this.colors[i % this.colors.length],
                        lhsString: lhs
                    });
                });
             
                return inequalities;
            }

            getObjective() {
                const expr = document.getElementById('objective-function').value.trim().toLowerCase() || '0';
                const coeffs = this.parseLHS(expr);
                return { px: coeffs.a, py: coeffs.b };
            }
         
            updateInequalitiesDisplay(inequalities) {
                const display = document.getElementById('inequalities-display');
             
                if (inequalities.length === 0) {
                    display.innerHTML = '<span style="color: #adb5bd; font-size: 13px;">Add inequalities below</span>';
                    return;
                }
             
                display.innerHTML = '';
             
                inequalities.forEach((ineq, i) => {
                    const container = document.createElement('div');
                    container.className = 'inequality-item';
                 
                    const latex = this.generateLatex(ineq, i);
                    const latexSpan = document.createElement('span');
                    latexSpan.className = 'inequality-katex';
                    container.appendChild(latexSpan);
                 
                    try {
                        katex.render(latex, latexSpan, { throwOnError: false });
                    } catch (error) {
                        latexSpan.textContent = `${this.formatLHS(ineq)} ${ineq.relation} ${ineq.c}`;
                    }
                 
                    display.appendChild(container);
                });
            }
         
            generateLatex(ineq, index) {
                const a = this.formatCoefficient(ineq.a, false);
                const b = this.formatCoefficient(ineq.b, true);
                const relation = this.getLatexRelation(ineq.relation);
                const c = this.formatNumber(ineq.c);
             
                let latex = '';
                if (a === '0' && b === '0') {
                    latex = `0 ${relation} ${c}`;
                } else if (a === '0') {
                    latex = `${b} ${relation} ${c}`;
                } else if (b === '0') {
                    latex = `${a} ${relation} ${c}`;
                } else {
                    const bSign = ineq.b < 0 ? '-' : '+';
                    const bAbs = this.formatCoefficient(Math.abs(ineq.b), true);
                    latex = `${a} ${bSign} ${bAbs} ${relation} ${c}`;
                }
             
                return `\\color{${this.colors[index % this.colors.length]}}{${latex}}`;
            }
         
            formatLHS(ineq) {
                const a = this.formatCoefficient(ineq.a, false);
                const b = this.formatCoefficient(ineq.b, true);
             
                if (a === '0' && b === '0') return '0';
                if (a === '0') return b;
                if (b === '0') return a;
             
                const bSign = ineq.b < 0 ? '-' : '+';
                const bAbs = this.formatCoefficient(Math.abs(ineq.b), true);
                return `${a} ${bSign} ${bAbs}`;
            }
         
            hexToRgb(hex) {
                const bigint = parseInt(hex.slice(1), 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return { r, g, b };
            }
         
            calculateBounds(inequalities) {
                if (inequalities.length === 0) {
                    return { xMin: -5, xMax: 5, yMin: -5, yMax: 5 };
                }
             
                let xMin = -10, xMax = 10, yMin = -10, yMax = 10;
             
                inequalities.forEach(ineq => {
                    if (Math.abs(ineq.a) > 0.001) {
                        const xInt = ineq.c / ineq.a;
                        xMin = Math.min(xMin, xInt);
                        xMax = Math.max(xMax, xInt);
                    }
                    if (Math.abs(ineq.b) > 0.001) {
                        const yInt = ineq.c / ineq.b;
                        yMin = Math.min(yMin, yInt);
                        yMax = Math.max(yMax, yInt);
                    }
                });
             
                const padding = Math.max(Math.abs(xMax - xMin) * 0.2, 2);
                xMin -= padding;
                xMax += padding;
                yMin -= padding;
                yMax += padding;
             
                return { xMin, xMax, yMin, yMax };
            }
         
            intersectLines(ineq1, ineq2) {
                const det = ineq1.a * ineq2.b - ineq2.a * ineq1.b;
                if (Math.abs(det) < 1e-8) return null;
                const x = (ineq1.c * ineq2.b - ineq2.c * ineq1.b) / det;
                const y = (ineq1.a * ineq2.c - ineq2.a * ineq1.c) / det;
                return [x, y];
            }
         
            pointSatisfiesAll(point, inequalities) {
                const [x, y] = point;
                for (const ineq of inequalities) {
                    const val = ineq.a * x + ineq.b * y;
                    const tol = 1e-6;
                    if ((ineq.relation === '‚â§' || ineq.relation === '<') && val > ineq.c + tol) return false;
                    if ((ineq.relation === '‚â•' || ineq.relation === '>') && val < ineq.c - tol) return false;
                }
                return true;
            }
         
            findCornerPoints(inequalities, bounds) {
                if (inequalities.length < 2) return [];
                const points = [];
                for (let i = 0; i < inequalities.length; i++) {
                    for (let j = i + 1; j < inequalities.length; j++) {
                        const p = this.intersectLines(inequalities[i], inequalities[j]);
                        if (p && this.pointSatisfiesAll(p, inequalities)) {
                            points.push(p);
                        }
                    }
                }
                return points.filter((p, idx) =>
                    points.findIndex(q => Math.abs(q[0]-p[0])<1e-6 && Math.abs(q[1]-p[1])<1e-6) === idx
                );
            }
         
            sortPointsClockwise(points) {
                if (points.length < 3) return points;
                const cx = points.reduce((s,p) => s + p[0], 0) / points.length;
                const cy = points.reduce((s,p) => s + p[1], 0) / points.length;
                return points.sort((a,b) => Math.atan2(a[1]-cy, a[0]-cx) - Math.atan2(b[1]-cy, b[0]-cx));
            }
         
            evaluateObjective(point, obj) {
                return obj.px * point[0] + obj.py * point[1];
            }
         
            updateCornerPointsTable(cornerPoints, obj) {
                const tbody = document.querySelector('#corner-points-table tbody');
                tbody.innerHTML = '';
                if (cornerPoints.length === 0) {
                    tbody.innerHTML = `<tr><td colspan="3" style="text-align: center; color: #adb5bd; font-style: italic;">No corner points (unbounded or empty region)</td></tr>`;
                    return;
                }

                cornerPoints.forEach((p, i) => {
                    const val = this.evaluateObjective(p, obj);

                    const label = this.cornerLabels[i] || String.fromCharCode(65 + i);
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td class="corner-label">${label}</td>
                        <td class="corner-coordinates">(${this.formatNumber(p[0])}, ${this.formatNumber(p[1])})</td>
                        <td class="objective-value">${this.formatNumber(val)}</td>
                    `;
                    tbody.appendChild(tr);
                });
            }
         
            extendLineToEdges(ineq, bounds) {
                const extension = 0.05 * (bounds.xMax - bounds.xMin);
                const x1 = bounds.xMin - extension;
                const x2 = bounds.xMax + extension;
                let y1, y2;
                if (Math.abs(ineq.b) > 0.001) {
                    y1 = (ineq.c - ineq.a * x1) / ineq.b;
                    y2 = (ineq.c - ineq.a * x2) / ineq.b;
                } else {
                    return null;
                }
                return { x: [x1, x2], y: [y1, y2] };
            }
         
            updatePlot() {
                const inequalities = this.getInequalities();
                const objective = this.getObjective();
                this.updateInequalitiesDisplay(inequalities);
             
                const bounds = this.calculateBounds(inequalities);
                const rawCornerPoints = this.findCornerPoints(inequalities, bounds);
                const cornerPoints = this.sortPointsClockwise(rawCornerPoints);
                this.updateCornerPointsTable(cornerPoints, objective);
             
                const data = [];
                const isReverse = this.getShadingMode() === 'reverse';
             
                inequalities.forEach((ineq, i) => {
                    const isStrict = ineq.relation === '<' || ineq.relation === '>';
                    const dash = isStrict ? 'dash' : 'solid';
                    const rgb = this.hexToRgb(ineq.color);
                    const shadeColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.15)`;
                 
                    let shadeAbove = (ineq.relation === '‚â•' || ineq.relation === '>') && ineq.b > 0 ||
                                     (ineq.relation === '‚â§' || ineq.relation === '<') && ineq.b < 0;
                    if (isReverse) shadeAbove = !shadeAbove;
                 
                    // Boundary line
                    if (Math.abs(ineq.b) > 0.001) {
                        const extended = this.extendLineToEdges(ineq, bounds);
                        if (extended) {
                            data.push({
                                x: extended.x,
                                y: extended.y,
                                mode: 'lines',
                                line: { color: ineq.color, width: 2, dash: dash },
                                showlegend: false,
                                hoverinfo: 'none'
                            });
                        }
                    } else if (Math.abs(ineq.a) > 0.001) {
                        const xVal = ineq.c / ineq.a;
                        data.push({
                            x: [xVal, xVal],
                            y: [bounds.yMin, bounds.yMax],
                            mode: 'lines',
                            line: { color: ineq.color, width: 2, dash: dash },
                            showlegend: false,
                            hoverinfo: 'none'
                        });
                    }
                 
                    // Shading
                    let x = [], y = [];
                    if (Math.abs(ineq.b) > 0.001) {
                        const y1 = (ineq.c - ineq.a * bounds.xMin) / ineq.b;
                        const y2 = (ineq.c - ineq.a * bounds.xMax) / ineq.b;
                        if (shadeAbove) {
                            x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
                            y = [y1, y2, bounds.yMax, bounds.yMax];
                        } else {
                            x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
                            y = [y1, y2, bounds.yMin, bounds.yMin];
                        }
                    } else if (Math.abs(ineq.a) > 0.001) {
                        const xVal = ineq.c / ineq.a;
                        let shadeRight = (ineq.relation === '‚â•' || ineq.relation === '>') && ineq.a > 0 ||
                                         (ineq.relation === '‚â§' || ineq.relation === '<') && ineq.a < 0;
                        if (isReverse) shadeRight = !shadeRight;
                        y = [bounds.yMin, bounds.yMax, bounds.yMax, bounds.yMin];
                        if (shadeRight) {
                            x = [xVal, xVal, bounds.xMax, bounds.xMax];
                        } else {
                            x = [bounds.xMin, bounds.xMin, xVal, xVal];
                        }
                    } else {
                        return;
                    }
                 
                    data.push({
                        x: x,
                        y: y,
                        fill: 'toself',
                        fillcolor: shadeColor,
                        line: { width: 0 },
                        mode: 'lines',
                        showlegend: false,
                        hoverinfo: 'none'
                    });
                });
             
                // Corner point markers and labels (always from true feasible region)
                if (cornerPoints.length > 0) {
                    cornerPoints.forEach((point, i) => {
                        const label = this.cornerLabels[i] || String.fromCharCode(65 + i);
                        data.push({
                            x: [point[0]],
                            y: [point[1]],
                            mode: 'markers+text',
                            marker: { size: 12, color: '#2c3e50', line: { color: 'white', width: 2 } },
                            text: [label],
                            textposition: 'top center',
                            textfont: { size: 14, family: 'Arial', weight: 'bold', color: '#2c3e50' },
                            showlegend: false,
                            hoverinfo: 'none'
                        });
                    });
                }
             
                const layout = {
                    plot_bgcolor: 'white',
                    paper_bgcolor: 'white',
                    xaxis: {
                        title: 'x',
                        range: [bounds.xMin, bounds.xMax],
                        showgrid: true,
                        gridcolor: 'rgba(240, 240, 240, 0.5)',
                        zeroline: true,
                        zerolinecolor: '#333',
                        zerolinewidth: 1.2,
                        showline: true,
                        linecolor: '#333',
                        linewidth: 1.2
                    },
                    yaxis: {
                        title: 'y',
                        range: [bounds.yMin, bounds.yMax],
                        showgrid: true,
                        gridcolor: 'rgba(240, 240, 240, 0.5)',
                        zeroline: true,
                        zerolinecolor: '#333',
                        zerolinewidth: 1.2,
                        showline: true,
                        linecolor: '#333',
                        linewidth: 1.2,
                        scaleanchor: "x",
                        scaleratio: 1
                    },
                    margin: { l: 50, r: 20, t: 20, b: 50 },
                    hovermode: false,
                    dragmode: 'pan',
                    showlegend: false
                };
             
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    displaylogo: false,
                    modeBarButtonsToRemove: ['lasso2d', 'select2d']
                };
             
                if (this.plotInitialized) {
                    Plotly.react('plot', data, layout, config);
                } else {
                    Plotly.newPlot('plot', data, layout, config);
                    this.plotInitialized = true;
                }
            }
         
            formatCoefficient(coeff, isY) {
                if (Math.abs(coeff) < 0.0001) return '0';
                if (Math.abs(coeff - 1) < 0.0001) return isY ? 'y' : 'x';
                if (Math.abs(coeff + 1) < 0.0001) return isY ? '-y' : '-x';
                const formatted = Number.isInteger(coeff) ? coeff.toString() : coeff.toFixed(2);
                return formatted + (isY ? 'y' : 'x');
            }
         
            formatNumber(num) {
                if (Number.isInteger(num)) return num.toString();
                return Math.round(num * 100) / 100;
            }
         
            getLatexRelation(relation) {
                switch (relation) {
                    case '<': return '\\lt';
                    case '>': return '\\gt';
                    case '‚â§': return '\\le';
                    case '‚â•': return '\\ge';
                    default: return relation;
                }
            }
         
            clearAll() {
                if (confirm('Clear all inequalities?')) {
                    document.getElementById('inequality-inputs').innerHTML = '';
                    document.getElementById('objective-function').value = '';
                    this.updatePlot();
                }
            }
         
            loadExample(exampleName) {
                const examples = {
                    'feasible-region': [
                        { lhs: "x", relation: '‚â•', rhs: 0 },
                        { lhs: "y", relation: '‚â•', rhs: 0 },
                        { lhs: "2x+y", relation: '‚â§', rhs: 10 },
                        { lhs: "x+2y", relation: '‚â§', rhs: 8 }
                    ],
                    'unbounded': [
                        { lhs: "x", relation: '‚â•', rhs: 0 },
                        { lhs: "y", relation: '‚â•', rhs: 0 },
                        { lhs: "2x+y", relation: '‚â•', rhs: 10 },
                        { lhs: "x+2y", relation: '‚â•', rhs: 8 }
                    ],
                    'single-halfplane': [
                        { lhs: "x+y", relation: '‚â•', rhs: 3 }
                    ]
                };
             
                const example = examples[exampleName];
                if (!example) return;
             
                const container = document.getElementById('inequality-inputs');
                container.innerHTML = '';
             
                example.forEach(ineqData => {
                    this.addInequality(ineqData);
                });

                if (exampleName === 'feasible-region') {
                    document.getElementById('objective-function').value = '3x+4y';
                } else if (exampleName === 'unbounded') {
                    document.getElementById('objective-function').value = 'x+y';
                } else {
                    document.getElementById('objective-function').value = '';
                }

                this.updatePlot();
            }
        }
     
        document.addEventListener('DOMContentLoaded', () => {
            new InequalityPlotter();
        });
    </script>
</body>
</html>