<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Shelvean Kapita - Interactive Method of Corners for Linear Programming" />
    <meta name="keywords" content="Shelvean Kapita, Linear Programming, Method of Corners, Graphical Method" />
    <title>Linear Programming: Method of Corners</title>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LEQE004C92"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-LEQE004C92');
    </script>

    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,400;0,700;1,400;1,700&family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet" />

    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        body { background: #f8f9fa; min-height: 100vh; padding: 20px; overflow-y: auto; font-size: 18px; }
        h1 { text-align: center; color: #2c3e50; margin-bottom: 24px; font-size: 32px; font-weight: 600; }

        header {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
            padding: 1.5rem 1rem;
            margin-bottom: 1.5rem;
        }

        .header-title {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 1rem;
        }

        .header-title a {
            color: #1a202c;
            text-decoration: none;
            transition: color 0.2s;
        }

        .header-title a:hover {
            color: #4f46e5;
        }

        nav ul {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 2.5rem;
            margin: 0;
            padding: 0;
            list-style: none;
        }

        nav a {
            color: #4f46e5;
            font-weight: 700;
            font-size: 1.25rem;
            transition: color 0.2s;
            text-decoration: none;
        }

        nav a:hover { color: #4338ca; }

        .container { max-width: 1800px; margin: 0 auto; display: grid; grid-template-columns: 1fr 1fr 460px; grid-template-rows: auto 680px auto; gap: 18px; }
        .inequalities-display { grid-column: 1 / span 2; background: white; border-radius: 8px; padding: 16px 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border: 1px solid #e0e6ed; display: flex; align-items: center; justify-content: center; flex-wrap: wrap; gap: 14px; min-height: 60px; font-size: 20px; }
        .plot-area { grid-column: 1 / span 2; grid-row: 2; background: white; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); position: relative; }
        #plot { width: 100%; height: 100%; }
        .p-value-display { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(255, 255, 255, 0.95); padding: 16px 32px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); font-size: 28px; font-weight: 700; color: #2c3e50; z-index: 10; display: none; border: 2px solid #3498db; }
        .p-value-display.active { display: block; }
        .p-value-display .p-label { font-size: 20px; color: #6c757d; margin-right: 8px; }
        .p-value-display.maximum { background: rgba(46, 204, 113, 0.95); border-color: #27ae60; color: white; animation: pulse 0.5s ease-in-out; }
        @keyframes pulse { 0%, 100% { transform: translateX(-50%) scale(1); } 50% { transform: translateX(-50%) scale(1.1); } }
        .right-panel { grid-column: 3; grid-row: 1 / span 3; background: white; border-radius: 10px; padding: 20px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); display: flex; flex-direction: column; gap: 24px; font-size: 17px; }
        .panel-section { flex: 1; }
        .panel-title { color: #2c3e50; font-size: 20px; font-weight: 600; margin-bottom: 14px; display: flex; align-items: center; gap: 10px; }
        .shading-controls { display: flex; flex-direction: column; gap: 12px; padding: 14px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef; font-size: 17px; }
        .example-list { display: flex; flex-direction: column; gap: 12px; }
        .example-btn { background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; padding: 14px; cursor: pointer; transition: all 0.2s; text-align: left; font-size: 16px; }
        .example-btn:hover { background: #e9ecef; border-color: #ccc; }
        .example-title { font-weight: 600; color: #2c3e50; font-size: 18px; margin-bottom: 4px; }
        .example-desc { color: #6c757d; font-size: 15px; line-height: 1.4; }
        .controls { display: flex; flex-direction: column; gap: 12px; }
        .action-btn { padding: 14px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 17px; transition: all 0.2s; }
        #update-plot { background: #3498db; color: white; }
        #update-plot:hover { background: #2980b9; }
        #play-sweep { background: #9b59b6; color: white; }
        #play-sweep:hover { background: #8e44ad; }
        #play-sweep:disabled { background: #bdc3c7; cursor: not-allowed; }
        #clear-all { background: #f8f9fa; color: #495057; border: 1px solid #e9ecef; }
        #clear-all:hover { background: #e9ecef; }
        .corner-points-section { flex: 1; display: flex; flex-direction: column; }
        .corner-points-title { color: #2c3e50; font-size: 20px; font-weight: 600; margin-bottom: 14px; display: flex; align-items: center; gap: 10px; }
        #corner-points-table { width: 100%; border-collapse: collapse; border-radius: 6px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1); font-size: 16px; }
        #corner-points-table th { background: #f8f9fa; padding: 12px; text-align: left; font-weight: 600; color: #2c3e50; border-bottom: 2px solid #e9ecef; }
        #corner-points-table td { padding: 12px; border-bottom: 1px solid #e9ecef; }
        #corner-points-table tr:last-child td { border-bottom: none; }
        .corner-label { font-weight: 700; color: #2c3e50; }
        .corner-coordinates, .objective-value { font-family: monospace; color: #495057; }
        .input-section { grid-column: 1 / span 2; grid-row: 3; background: white; border-radius: 10px; padding: 20px; box-shadow: 0 2px 6px rgba(0,0,0,0.08); display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
        .constraints-section, .objective-section { display: flex; flex-direction: column; }
        .input-header { display: flex; align-items: center; gap: 12px; margin-bottom: 18px; flex-wrap: wrap; }
        .input-title { color: #2c3e50; font-size: 20px; font-weight: 600; }
        #add-inequality, #add-non-negativity { background: #2ecc71; color: white; border: none; border-radius: 5px; padding: 10px 18px; font-weight: 600; cursor: pointer; font-size: 16px; transition: background 0.2s; }
        #add-inequality:hover, #add-non-negativity:hover { background: #27ae60; }
        .inequality-inputs { display: flex; flex-direction: column; gap: 12px; }
        .ineq-row { display: flex; align-items: center; gap: 10px; padding: 10px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef; }
        .lhs-input, .rhs-input, .objective-input { padding: 10px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 17px; transition: border-color 0.2s; }
        .lhs-input { flex: 1; min-width: 0; }
        .rhs-input { width: 200px; }
        .objective-input { width: 240px; }
        .relation-select { width: 70px; padding: 10px; border: 1px solid #dee2e6; border-radius: 4px; background: white; cursor: pointer; font-size: 17px; }
        .remove-btn { background: #e74c3c; color: white; border: none; border-radius: 4px; width: 36px; height: 36px; cursor: pointer; font-size: 18px; transition: background 0.2s; flex-shrink: 0; }
        .remove-btn:hover { background: #c0392b; }
        .help-text { color: #6c757d; font-size: 15px; margin-top: 10px; font-style: italic; }
        .objective-row { display: flex; align-items: center; gap: 12px; }
        .objective-row span { font-size: 20px; font-weight: 600; }

        footer {
            text-align: center;
            padding: 2rem;
            border-top: 1px solid #e5e7eb;
            color: #6b7280;
            font-size: 0.875rem;
            margin-top: 3rem;
        }

        @media (max-width: 1200px) {
            .container { grid-template-columns: 1fr; grid-template-rows: auto auto auto auto; gap: 16px; }
            .right-panel { grid-column: 1; grid-row: 2; }
            .plot-area { grid-row: 3; height: 500px; }
            .input-section { grid-column: 1; grid-row: 4; grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <!-- Header with navigation -->
    <header>
        <div class="max-w-6xl mx-auto">
            <h1 class="header-title">
                <a href="index.html">Shelvean Kapita</a>
            </h1>
            <nav>
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="teaching.html">Teaching</a></li>
                    <li><a href="projects.html">Diff Eq</a></li>
                    <li><a href="linear.html">Linear Algebra</a></li>
                    <li><a href="optim.html">Linear Programming</a></li>
                    <li><a href="numerical.html">Numerical Methods</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <h1>Linear Programming: Method of Corners</h1>

    <div class="container">
        <div class="inequalities-display" id="inequalities-display">
            <span style="color: #adb5bd;">Add inequalities below</span>
        </div>

        <div class="plot-area">
            <div class="p-value-display" id="p-value-display">
                <span class="p-label">Objective Value:</span>
                <span id="p-value-text">P = 0</span>
            </div>
            <div id="plot"></div>
        </div>

        <div class="right-panel">
            <div class="panel-section">
                <div class="panel-title">Examples</div>
                <div class="example-list">
                    <button class="example-btn" data-example="feasible-region">
                        <div class="example-title">Bounded Region</div>
                        <div class="example-desc">x ≥ 0, y ≥ 0, 2x + y ≤ 10, x + 2y ≤ 8<br>P = 3x + 4y</div>
                    </button>
                    <button class="example-btn" data-example="unbounded">
                        <div class="example-title">Unbounded Region</div>
                        <div class="example-desc">x ≥ 0, y ≥ 0, 2x + y ≥ 10, x + 2y ≥ 8<br>P = x + y</div>
                    </button>
                    <button class="example-btn" data-example="single-halfplane">
                        <div class="example-title">Single Half-Plane</div>
                        <div class="example-desc">x + y ≥ 3</div>
                    </button>
                </div>
            </div>

            <div class="shading-controls">
                <div class="panel-title" style="margin-bottom:10px;font-size:18px;">Shading Mode</div>
                <label><input type="radio" name="shading-mode" value="true"> True Shading (feasible side)</label>
                <label><input type="radio" name="shading-mode" value="reverse" checked> Reverse Shading (infeasible side)</label>
            </div>

            <div class="shading-controls">
                <div class="panel-title" style="margin-bottom:10px;font-size:18px;">Sweep Settings</div>
                <label style="margin-bottom: 8px;">
                    <span style="display: block; margin-bottom: 4px; font-weight: 600;">Optimization Type:</span>
                    <select id="optimization-type" style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 16px;">
                        <option value="maximize">Maximize</option>
                        <option value="minimize">Minimize</option>
                        <option value="auto">Auto-detect</option>
                    </select>
                </label>
                <label>
                    <span style="display: block; margin-bottom: 4px; font-weight: 600;">Animation Speed:</span>
                    <select id="animation-speed" style="width: 100%; padding: 8px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 16px;">
                        <option value="5000">Fast (5s)</option>
                        <option value="8000" selected>Normal (8s)</option>
                        <option value="12000">Slow (12s)</option>
                        <option value="18000">Very Slow (18s)</option>
                    </select>
                </label>
            </div>

            <div class="controls">
                <button class="action-btn" id="update-plot">Update Plot</button>
                <button class="action-btn" id="play-sweep">▶ Play Sweep Animation</button>
                <button class="action-btn" id="clear-all">Clear All</button>
            </div>

            <div class="corner-points-section">
                <div class="corner-points-title">Corner Points & Objective Values</div>
                <table id="corner-points-table">
                    <thead>
                        <tr>
                            <th>Label</th>
                            <th>Coordinates (x, y)</th>
                            <th>P Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td colspan="3" style="text-align: center; color: #adb5bd; font-style: italic;">
                                Corner points will appear here for bounded regions
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="input-section">
            <div class="constraints-section">
                <div class="input-header">
                    <div class="input-title">Enter Constraints (Inequalities)</div>
                    <div>
                        <button id="add-inequality">+ Add Inequality</button>
                        <button id="add-non-negativity">+ Add Non-Negativity</button>
                    </div>
                </div>
                <div class="inequality-inputs" id="inequality-inputs"></div>
                <div class="help-text">Examples: "2x+3y", "x-y", "y", "0.5x+2y", "(1/2)x+(3/5)y"</div>
            </div>

            <div class="objective-section">
                <div class="input-header">
                    <div class="input-title">Enter Objective Function</div>
                </div>
                <div class="objective-row">
                    <span>P =</span>
                    <input type="text" class="objective-input" id="objective-function" placeholder="e.g., 3x+4y" value="3x+4y">
                </div>
                <div style="margin-top: 20px;">
                    <label for="display-mode" style="font-weight: 600; color: #2c3e50; display: block; margin-bottom: 8px;">Coordinates Display Format:</label>
                    <select id="display-mode" class="relation-select" style="width: 100%; padding: 10px;">
                        <option value="decimal">Decimals</option>
                        <option value="fraction">Fractions</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <footer class="text-center py-8 border-t border-gray-200 text-gray-600 text-sm mt-16">
        <p>© <span id="current-year"></span> Shelvean Kapita. All rights reserved.</p>
        <p class="mt-2">
            This interactive tool is licensed under the 
            <a href="https://opensource.org/licenses/MIT" target="_blank" rel="noopener noreferrer" 
               class="text-indigo-600 hover:text-indigo-800 underline">
                MIT License
            </a>.
        </p>
        <p class="mt-4 text-xs text-gray-500">Last modified on January 15, 2026.</p>
    </footer>

    <script>
        // Update copyright year dynamically
        document.getElementById('current-year').textContent = new Date().getFullYear();

        class InequalityPlotter {
            constructor() {
                this.colors = ['#E41A1C', '#377EB8', '#4DAF4A', '#984EA3', '#FF7F00', '#A65628', '#F781BF', '#999999'];
                this.plotInitialized = false;
                this.cornerLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
                this.sweepAnimationRunning = false;
                this.sweepAnimationId = null;
                this.bindEvents();
                setTimeout(() => {
                    this.updatePlot();
                    this.loadExample('feasible-region');
                }, 100);
            }

            bindEvents() {
                document.getElementById('add-inequality').addEventListener('click', () => this.addInequality());
                document.getElementById('add-non-negativity').addEventListener('click', () => this.addNonNegativity());
                document.getElementById('update-plot').addEventListener('click', () => this.updatePlot());
                document.getElementById('play-sweep').addEventListener('click', () => this.playSweepAnimation());
                document.getElementById('clear-all').addEventListener('click', () => this.clearAll());
                document.getElementById('objective-function').addEventListener('input', () => this.updatePlot());

                // Add event listener for display mode dropdown
                setTimeout(() => {
                    const displayModeSelect = document.getElementById('display-mode');
                    if (displayModeSelect) {
                        displayModeSelect.addEventListener('change', () => this.updatePlot());
                    }
                }, 200);

                document.querySelectorAll('.example-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const example = e.currentTarget.dataset.example;
                        this.loadExample(example);
                    });
                });

                document.querySelectorAll('input[name="shading-mode"]').forEach(radio => {
                    radio.addEventListener('change', () => this.updatePlot());
                });

                window.addEventListener('resize', () => {
                    if (this.plotInitialized) {
                        this.updatePlot();
                    }
                });
            }

            addNonNegativity() {
                let hasX = false;
                document.querySelectorAll('.ineq-row').forEach(row => {
                    const lhs = row.querySelector('.lhs-input').value.trim().toLowerCase();
                    if (lhs === 'x') hasX = true;
                });
                if (!hasX) {
                    this.addInequality({ lhs: "x", relation: '≥', rhs: 0 });
                }
                let hasY = false;
                document.querySelectorAll('.ineq-row').forEach(row => {
                    const lhs = row.querySelector('.lhs-input').value.trim().toLowerCase();
                    if (lhs === 'y') hasY = true;
                });
                if (!hasY) {
                    this.addInequality({ lhs: "y", relation: '≥', rhs: 0 });
                }
                if (hasX && hasY) {
                    alert('Non-negativity constraints x ≥ 0 and y ≥ 0 are already present.');
                }
            }

            getShadingMode() {
                const selected = document.querySelector('input[name="shading-mode"]:checked');
                return selected ? selected.value : 'reverse';
            }

            createInequalityRow(data = { lhs: "x", relation: '≥', rhs: 0 }) {
                const row = document.createElement('div');
                row.className = 'ineq-row';
                row.innerHTML = `
                    <input type="text" class="lhs-input" placeholder="e.g., 2x+3y" value="${data.lhs}">
                    <select class="relation-select">
                        <option value="≤" ${data.relation === '≤' ? 'selected' : ''}>≤</option>
                        <option value="≥" ${data.relation === '≥' ? 'selected' : ''}>≥</option>
                        <option value="<" ${data.relation === '<' ? 'selected' : ''}>&lt;</option>
                        <option value=">" ${data.relation === '>' ? 'selected' : ''}>&gt;</option>
                    </select>
                    <input type="text" class="rhs-input" placeholder="10 or 10/3" value="${data.rhs}">
                    <button class="remove-btn" title="Remove">×</button>
                `;
                row.querySelector('.remove-btn').addEventListener('click', () => {
                    row.remove();
                    this.updatePlot();
                });
                row.querySelectorAll('input, select').forEach(el => {
                    el.addEventListener('input', () => this.updatePlot());
                    el.addEventListener('change', () => this.updatePlot());
                });
                return row;
            }

            addInequality(data) {
                const container = document.getElementById('inequality-inputs');
                const row = this.createInequalityRow(data);
                container.appendChild(row);
                this.updatePlot();
            }

            evaluateFraction(fractionStr) {
                // Handle fractions like "1/2", "-3/4", etc.
                const parts = fractionStr.split('/');
                if (parts.length === 2) {
                    const numerator = parseFloat(parts[0]);
                    const denominator = parseFloat(parts[1]);
                    if (!isNaN(numerator) && !isNaN(denominator) && denominator !== 0) {
                        return numerator / denominator;
                    }
                }
                return parseFloat(fractionStr);
            }

            parseCoefficient(coeffStr) {
                if (coeffStr === '' || coeffStr === '+') return 1;
                if (coeffStr === '-') return -1;

                // Check if it contains a fraction
                if (coeffStr.includes('/')) {
                    // Handle cases like (-1/2) or -1/2
                    coeffStr = coeffStr.replace(/[()]/g, '');
                    return this.evaluateFraction(coeffStr);
                }

                return parseFloat(coeffStr);
            }

            parseLHS(lhsString) {
                let str = lhsString.replace(/\s+/g, '').toLowerCase();
                str = str.replace(/\*/g, '');
                let a = 0;
                let b = 0;

                if (str === '') return { a: 0, b: 0 };
                if (str === 'x') return { a: 1, b: 0 };
                if (str === 'y') return { a: 0, b: 1 };
                if (str === '-x') return { a: -1, b: 0 };
                if (str === '-y') return { a: 0, b: -1 };

                // Match x terms with various coefficient formats
                // Handles: 2x, -3x, (1/2)x, (-1/2)x, 0.5x, etc.
                const xPatterns = [
                    /(\([+-]?\d+\/\d+\))x/,           // (1/2)x or (-1/2)x
                    /([+-]?\d*\.?\d*)x/                // 2x, -3x, 0.5x
                ];

                for (const pattern of xPatterns) {
                    const xMatch = str.match(pattern);
                    if (xMatch) {
                        const coeff = xMatch[1];
                        a = this.parseCoefficient(coeff);
                        str = str.replace(xMatch[0], '');
                        break;
                    }
                }

                // Match y terms with various coefficient formats
                const yPatterns = [
                    /(\([+-]?\d+\/\d+\))y/,           // (1/2)y or (-3/5)y
                    /([+-]?\d*\.?\d*)y/                // 2y, -3y, 0.5y
                ];

                for (const pattern of yPatterns) {
                    const yMatch = str.match(pattern);
                    if (yMatch) {
                        const coeff = yMatch[1];
                        b = this.parseCoefficient(coeff);
                        str = str.replace(yMatch[0], '');
                        break;
                    }
                }

                // Check for remaining constant term
                if (str !== '' && !isNaN(parseFloat(str))) {
                    b = parseFloat(str);
                }

                if (isNaN(a)) a = 0;
                if (isNaN(b)) b = 0;
                return { a, b };
            }

            getInequalities() {
                const inequalities = [];
                const rows = document.querySelectorAll('.ineq-row');
                rows.forEach((row, i) => {
                    const lhs = row.querySelector('.lhs-input').value || '';
                    const relation = row.querySelector('.relation-select').value;
                    const rhsString = row.querySelector('.rhs-input').value || '0';
                    const rhs = this.evaluateFraction(rhsString);
                    const coefficients = this.parseLHS(lhs);
                    inequalities.push({
                        a: coefficients.a,
                        b: coefficients.b,
                        c: rhs,
                        relation: relation,
                        color: this.colors[i % this.colors.length],
                        lhsString: lhs,
                        rhsString: rhsString.trim()
                    });
                });
                return inequalities;
            }

            getObjective() {
                const expr = document.getElementById('objective-function').value.trim().toLowerCase() || '0';
                const coeffs = this.parseLHS(expr);
                return { px: coeffs.a, py: coeffs.b };
            }

            updateInequalitiesDisplay(inequalities) {
                const display = document.getElementById('inequalities-display');
                if (inequalities.length === 0) {
                    display.innerHTML = '<span style="color: #adb5bd;">Add inequalities below</span>';
                    return;
                }
                display.innerHTML = '';
                inequalities.forEach((ineq, i) => {
                    const container = document.createElement('div');
                    container.className = 'inequality-item';
                    const latex = this.generateLatex(ineq, i);
                    const latexSpan = document.createElement('span');
                    latexSpan.className = 'inequality-katex';
                    container.appendChild(latexSpan);
                    try {
                        katex.render(latex, latexSpan, { throwOnError: false });
                    } catch (error) {
                        latexSpan.textContent = `${this.formatLHS(ineq)} ${ineq.relation} ${ineq.c}`;
                    }
                    display.appendChild(container);
                });
            }

            formatRHSForLatex(rhsString, rhsValue) {
                // Check if the input is in fraction format
                if (rhsString.includes('/')) {
                    const parts = rhsString.split('/');
                    if (parts.length === 2) {
                        const num = parts[0].trim();
                        const den = parts[1].trim();
                        if (!isNaN(parseFloat(num)) && !isNaN(parseFloat(den))) {
                            return `\\dfrac{${num}}{${den}}`;
                        }
                    }
                }
                // Otherwise, try to convert to fraction if it's not an integer
                if (!Number.isInteger(rhsValue)) {
                    const frac = this.toFraction(rhsValue);
                    if (frac.denominator !== 1) {
                        return `\\dfrac{${frac.numerator}}{${frac.denominator}}`;
                    }
                }
                // Return as regular number
                return this.formatNumber(rhsValue);
            }

            generateLatex(ineq, index) {
                const a = this.formatCoefficient(ineq.a, false);
                const b = this.formatCoefficient(ineq.b, true);
                const relation = this.getLatexRelation(ineq.relation);
                const c = this.formatRHSForLatex(ineq.rhsString, ineq.c);
                let latex = '';
                if (a === '0' && b === '0') {
                    latex = `0 ${relation} ${c}`;
                } else if (a === '0') {
                    latex = `${b} ${relation} ${c}`;
                } else if (b === '0') {
                    latex = `${a} ${relation} ${c}`;
                } else {
                    const bSign = ineq.b < 0 ? '-' : '+';
                    const bAbs = this.formatCoefficient(Math.abs(ineq.b), true);
                    latex = `${a} ${bSign} ${bAbs} ${relation} ${c}`;
                }
                return `\\color{${this.colors[index % this.colors.length]}}{${latex}}`;
            }

            formatLHS(ineq) {
                const a = this.formatCoefficient(ineq.a, false);
                const b = this.formatCoefficient(ineq.b, true);
                if (a === '0' && b === '0') return '0';
                if (a === '0') return b;
                if (b === '0') return a;
                const bSign = ineq.b < 0 ? '-' : '+';
                const bAbs = this.formatCoefficient(Math.abs(ineq.b), true);
                return `${a} ${bSign} ${bAbs}`;
            }

            hexToRgb(hex) {
                const bigint = parseInt(hex.slice(1), 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return { r, g, b };
            }

            calculateBounds(inequalities) {
                if (inequalities.length === 0) {
                    return { xMin: -5, xMax: 5, yMin: -5, yMax: 5 };
                }

                // Calculate initial bounds from intercepts
                let xMin = -10, xMax = 10, yMin = -10, yMax = 10;
                inequalities.forEach(ineq => {
                    if (Math.abs(ineq.a) > 0.001) {
                        const xInt = ineq.c / ineq.a;
                        xMin = Math.min(xMin, xInt);
                        xMax = Math.max(xMax, xInt);
                    }
                    if (Math.abs(ineq.b) > 0.001) {
                        const yInt = ineq.c / ineq.b;
                        yMin = Math.min(yMin, yInt);
                        yMax = Math.max(yMax, yInt);
                    }
                });

                // Check if we have corner points (bounded region)
                const cornerPoints = this.findCornerPoints(inequalities, { xMin, xMax, yMin, yMax });
                const isBounded = cornerPoints.length > 0;

                let paddingFactor, minPadding;
                if (isBounded) {
                    // For bounded regions, use corner points to determine bounds
                    const xCoords = cornerPoints.map(p => p[0]);
                    const yCoords = cornerPoints.map(p => p[1]);
                    xMin = Math.min(...xCoords);
                    xMax = Math.max(...xCoords);
                    yMin = Math.min(...yCoords);
                    yMax = Math.max(...yCoords);

                    // Smaller padding for bounded regions (15-20% instead of 40%)
                    paddingFactor = 0.2;
                    minPadding = 1;
                } else {
                    // Larger padding for unbounded regions
                    paddingFactor = 0.4;
                    minPadding = 4;
                }

                const rangeX = xMax - xMin || 10;
                const rangeY = yMax - yMin || 10;
                const padding = Math.max(rangeX * paddingFactor, rangeY * paddingFactor, minPadding);

                xMin -= padding;
                xMax += padding;
                yMin -= padding;
                yMax += padding;

                return { xMin, xMax, yMin, yMax };
            }

            intersectLines(ineq1, ineq2) {
                const det = ineq1.a * ineq2.b - ineq2.a * ineq1.b;
                if (Math.abs(det) < 1e-8) return null;
                const x = (ineq1.c * ineq2.b - ineq2.c * ineq1.b) / det;
                const y = (ineq1.a * ineq2.c - ineq2.a * ineq1.c) / det;
                return [x, y];
            }

            pointSatisfiesAll(point, inequalities) {
                const [x, y] = point;
                for (const ineq of inequalities) {
                    const val = ineq.a * x + ineq.b * y;
                    const tol = 1e-6;
                    if ((ineq.relation === '≤' || ineq.relation === '<') && val > ineq.c + tol) return false;
                    if ((ineq.relation === '≥' || ineq.relation === '>') && val < ineq.c - tol) return false;
                }
                return true;
            }

            findCornerPoints(inequalities, bounds) {
                if (inequalities.length < 2) return [];
                const points = [];
                for (let i = 0; i < inequalities.length; i++) {
                    for (let j = i + 1; j < inequalities.length; j++) {
                        const p = this.intersectLines(inequalities[i], inequalities[j]);
                        if (p && this.pointSatisfiesAll(p, inequalities)) {
                            points.push(p);
                        }
                    }
                }
                return points.filter((p, idx) => points.findIndex(q => Math.abs(q[0]-p[0])<1e-6 && Math.abs(q[1]-p[1])<1e-6) === idx);
            }

            sortPointsClockwise(points) {
                if (points.length < 3) return points;
                const cx = points.reduce((s,p) => s + p[0], 0) / points.length;
                const cy = points.reduce((s,p) => s + p[1], 0) / points.length;
                return points.sort((a,b) => Math.atan2(a[1]-cy, a[0]-cx) - Math.atan2(b[1]-cy, b[0]-cx));
            }

            evaluateObjective(point, obj) {
                return obj.px * point[0] + obj.py * point[1];
            }

            toFraction(decimal, tolerance = 1e-6) {
                // Handle integers
                if (Math.abs(decimal - Math.round(decimal)) < tolerance) {
                    return { numerator: Math.round(decimal), denominator: 1 };
                }

                // Handle negative numbers
                const sign = decimal < 0 ? -1 : 1;
                decimal = Math.abs(decimal);

                // Use continued fractions algorithm
                let numerator = 1;
                let denominator = 1;
                let bestNumerator = Math.round(decimal);
                let bestDenominator = 1;
                let bestError = Math.abs(decimal - bestNumerator);

                for (let d = 2; d <= 10000; d++) {
                    numerator = Math.round(decimal * d);
                    const error = Math.abs(decimal - numerator / d);

                    if (error < bestError) {
                        bestNumerator = numerator;
                        bestDenominator = d;
                        bestError = error;
                    }

                    if (error < tolerance) {
                        break;
                    }
                }

                // Simplify the fraction
                const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
                const divisor = gcd(bestNumerator, bestDenominator);

                return {
                    numerator: sign * (bestNumerator / divisor),
                    denominator: bestDenominator / divisor
                };
            }

            formatNumberAsLatex(num, useLatex = true) {
                const displayMode = document.getElementById('display-mode')?.value || 'decimal';

                if (displayMode === 'fraction') {
                    const frac = this.toFraction(num);
                    if (frac.denominator === 1) {
                        return useLatex ? frac.numerator.toString() : frac.numerator.toString();
                    } else {
                        return useLatex ? `\\dfrac{${frac.numerator}}{${frac.denominator}}` : `${frac.numerator}/${frac.denominator}`;
                    }
                } else {
                    // Decimal mode
                    if (Number.isInteger(num)) return num.toString();
                    return (Math.round(num * 100) / 100).toString();
                }
            }

            isRegionUnbounded(inequalities) {
                // A region is unbounded if it's not completely enclosed
                // Check if we have constraints in all directions
                let hasUpperX = false, hasLowerX = false, hasUpperY = false, hasLowerY = false;

                inequalities.forEach(ineq => {
                    // x <= c or x < c (upper bound on x)
                    if (Math.abs(ineq.a - 1) < 0.001 && Math.abs(ineq.b) < 0.001 && (ineq.relation === '≤' || ineq.relation === '<')) {
                        hasUpperX = true;
                    }
                    // x >= c or x > c (lower bound on x)
                    if (Math.abs(ineq.a - 1) < 0.001 && Math.abs(ineq.b) < 0.001 && (ineq.relation === '≥' || ineq.relation === '>')) {
                        hasLowerX = true;
                    }
                    // y <= c or y < c (upper bound on y)
                    if (Math.abs(ineq.b - 1) < 0.001 && Math.abs(ineq.a) < 0.001 && (ineq.relation === '≤' || ineq.relation === '<')) {
                        hasUpperY = true;
                    }
                    // y >= c or y > c (lower bound on y)
                    if (Math.abs(ineq.b - 1) < 0.001 && Math.abs(ineq.a) < 0.001 && (ineq.relation === '≥' || ineq.relation === '>')) {
                        hasLowerY = true;
                    }
                    // Mixed constraints can also bound
                    if (ineq.a > 0 && ineq.b > 0 && (ineq.relation === '≤' || ineq.relation === '<')) {
                        hasUpperX = true;
                        hasUpperY = true;
                    }
                });

                return !(hasUpperX && hasLowerX && hasUpperY && hasLowerY);
            }

            hasMaximum(inequalities, objective) {
                // Check if the objective function is bounded above
                // If the feasible region is unbounded in the direction of the gradient, there's no maximum
                const unbounded = this.isRegionUnbounded(inequalities);
                if (!unbounded) return true; // Bounded region always has max

                // Check if we can increase the objective indefinitely
                // The gradient direction is (px, py)
                // We need to check if the constraints prevent unbounded growth in this direction

                // Simple heuristic: if most constraints are ≤, likely bounded above
                const upperBounds = inequalities.filter(ineq => ineq.relation === '≤' || ineq.relation === '<').length;
                const lowerBounds = inequalities.filter(ineq => ineq.relation === '≥' || ineq.relation === '>').length;

                // If objective coefficients are positive and we have upper bound constraints, likely has max
                if (objective.px >= 0 && objective.py >= 0 && upperBounds > 0) return true;
                // If objective coefficients are negative and we have lower bound constraints, likely has max
                if (objective.px <= 0 && objective.py <= 0 && lowerBounds > 0) return true;

                // Mixed case - be conservative and say it might not have max
                return upperBounds > lowerBounds;
            }

            hasMinimum(inequalities, objective) {
                // Check if the objective function is bounded below
                const unbounded = this.isRegionUnbounded(inequalities);
                if (!unbounded) return true; // Bounded region always has min

                const upperBounds = inequalities.filter(ineq => ineq.relation === '≤' || ineq.relation === '<').length;
                const lowerBounds = inequalities.filter(ineq => ineq.relation === '≥' || ineq.relation === '>').length;

                // If objective coefficients are positive and we have lower bound constraints, likely has min
                if (objective.px >= 0 && objective.py >= 0 && lowerBounds > 0) return true;
                // If objective coefficients are negative and we have upper bound constraints, likely has min
                if (objective.px <= 0 && objective.py <= 0 && upperBounds > 0) return true;

                return lowerBounds > upperBounds;
            }

            updateCornerPointsTable(cornerPoints, obj) {
                const tbody = document.querySelector('#corner-points-table tbody');
                tbody.innerHTML = '';
                if (cornerPoints.length === 0) {
                    tbody.innerHTML = `<tr><td colspan="3" style="text-align: center; color: #adb5bd; font-style: italic;">No corner points (unbounded or empty region)</td></tr>`;
                    return;
                }

                // Calculate all P values
                const pValues = cornerPoints.map(p => this.evaluateObjective(p, obj));
                const minP = Math.min(...pValues);
                const maxP = Math.max(...pValues);
                const tolerance = 1e-6;

                // Find all corners with min/max values
                const minIndices = pValues.map((v, i) => Math.abs(v - minP) < tolerance ? i : -1).filter(i => i >= 0);
                const maxIndices = pValues.map((v, i) => Math.abs(v - maxP) < tolerance ? i : -1).filter(i => i >= 0);

                cornerPoints.forEach((p, i) => {
                    const val = this.evaluateObjective(p, obj);
                    const label = this.cornerLabels[i] || String.fromCharCode(65 + i);
                    const tr = document.createElement('tr');

                    // Highlight if this is optimal
                    const isMin = minIndices.includes(i);
                    const isMax = maxIndices.includes(i);
                    if (isMin || isMax) {
                        tr.style.backgroundColor = '#e8f5e9';
                        tr.style.fontWeight = '600';
                    }

                    // Create cells
                    const labelCell = document.createElement('td');
                    labelCell.className = 'corner-label';
                    labelCell.textContent = label;

                    const coordCell = document.createElement('td');
                    coordCell.className = 'corner-coordinates';
                    const xLatex = this.formatNumberAsLatex(p[0], true);
                    const yLatex = this.formatNumberAsLatex(p[1], true);
                    const coordLatex = `\\left(${xLatex}, ${yLatex}\\right)`;
                    try {
                        katex.render(coordLatex, coordCell, { throwOnError: false });
                    } catch (error) {
                        coordCell.textContent = `(${this.formatNumber(p[0])}, ${this.formatNumber(p[1])})`;
                    }

                    const valueCell = document.createElement('td');
                    valueCell.className = 'objective-value';
                    const valLatex = this.formatNumberAsLatex(val, true);
                    try {
                        katex.render(valLatex, valueCell, { throwOnError: false });
                    } catch (error) {
                        valueCell.textContent = this.formatNumber(val);
                    }

                    tr.appendChild(labelCell);
                    tr.appendChild(coordCell);
                    tr.appendChild(valueCell);
                    tbody.appendChild(tr);
                });

                // Add summary row for edge optimals or unbounded
                const inequalities = this.getInequalities();
                const hasMax = this.hasMaximum(inequalities, obj);
                const hasMin = this.hasMinimum(inequalities, obj);

                if (minIndices.length > 1 || maxIndices.length > 1 || !hasMax || !hasMin) {
                    const tr = document.createElement('tr');
                    tr.style.borderTop = '2px solid #2c3e50';
                    tr.style.fontStyle = 'italic';
                    const td = document.createElement('td');
                    td.colSpan = 3;
                    td.style.padding = '12px';
                    td.style.textAlign = 'center';

                    let msg = '';

                    // Edge optimal messages
                    if (maxIndices.length > 1) {
                        const labels = maxIndices.map(i => this.cornerLabels[i]).join(', ');
                        msg += `<span style="color: #27ae60; font-weight: 600;">Maximum occurs along edge: ${labels}</span>`;
                    }
                    if (minIndices.length > 1) {
                        const labels = minIndices.map(i => this.cornerLabels[i]).join(', ');
                        if (msg) msg += '<br>';
                        msg += `<span style="color: #27ae60; font-weight: 600;">Minimum occurs along edge: ${labels}</span>`;
                    }

                    // Unbounded messages
                    if (!hasMax) {
                        if (msg) msg += '<br>';
                        msg += `<span style="color: #e74c3c; font-weight: 600;">⚠ No maximum (unbounded above)</span>`;
                    }
                    if (!hasMin) {
                        if (msg) msg += '<br>';
                        msg += `<span style="color: #e74c3c; font-weight: 600;">⚠ No minimum (unbounded below)</span>`;
                    }

                    td.innerHTML = msg;
                    tr.appendChild(td);
                    tbody.appendChild(tr);
                }
            }

            extendLineToEdges(ineq, bounds) {
                const extension = 0.5 * (bounds.xMax - bounds.xMin);
                const x1 = bounds.xMin - extension;
                const x2 = bounds.xMax + extension;
                let y1, y2;
                if (Math.abs(ineq.b) > 0.001) {
                    y1 = (ineq.c - ineq.a * x1) / ineq.b;
                    y2 = (ineq.c - ineq.a * x2) / ineq.b;
                } else {
                    return null;
                }
                return { x: [x1, x2], y: [y1, y2] };
            }

            updatePlot() {
                const inequalities = this.getInequalities();
                const objective = this.getObjective();
                this.updateInequalitiesDisplay(inequalities);
                const bounds = this.calculateBounds(inequalities);
                const rawCornerPoints = this.findCornerPoints(inequalities, bounds);
                const cornerPoints = this.sortPointsClockwise(rawCornerPoints);
                this.updateCornerPointsTable(cornerPoints, objective);

                const data = [];
                const isReverse = this.getShadingMode() === 'reverse';

                inequalities.forEach((ineq, i) => {
                    const isStrict = ineq.relation === '<' || ineq.relation === '>';
                    const dash = isStrict ? 'dash' : 'solid';
                    const rgb = this.hexToRgb(ineq.color);
                    const shadeColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.15)`;

                    // Line trace (over-extended)
                    if (Math.abs(ineq.b) > 0.001) {
                        const extended = this.extendLineToEdges(ineq, bounds);
                        if (extended) {
                            data.push({
                                x: extended.x,
                                y: extended.y,
                                mode: 'lines',
                                line: { color: ineq.color, width: 3, dash: dash },
                                showlegend: false,
                                hoverinfo: 'none'
                            });
                        }
                    } else if (Math.abs(ineq.a) > 0.001) {
                        const xVal = ineq.c / ineq.a;
                        data.push({
                            x: [xVal, xVal],
                            y: [bounds.yMin - 10, bounds.yMax + 10],
                            mode: 'lines',
                            line: { color: ineq.color, width: 3, dash: dash },
                            showlegend: false,
                            hoverinfo: 'none'
                        });
                    }

                    // Shading polygons
                    let x = [], y = [];
                    let shadeAbove = (ineq.relation === '≥' || ineq.relation === '>') && ineq.b > 0 ||
                                    (ineq.relation === '≤' || ineq.relation === '<') && ineq.b < 0;
                    if (isReverse) shadeAbove = !shadeAbove;

                    if (Math.abs(ineq.b) > 0.001) {
                        const yLeft = (ineq.c - ineq.a * bounds.xMin) / ineq.b;
                        const yRight = (ineq.c - ineq.a * bounds.xMax) / ineq.b;
                        if (shadeAbove) {
                            x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
                            y = [yLeft, yRight, bounds.yMax, bounds.yMax];
                        } else {
                            x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
                            y = [yLeft, yRight, bounds.yMin, bounds.yMin];
                        }
                    } else if (Math.abs(ineq.a) > 0.001) {
                        const xVal = ineq.c / ineq.a;
                        let shadeRight = (ineq.relation === '≥' || ineq.relation === '>') && ineq.a > 0 ||
                                        (ineq.relation === '≤' || ineq.relation === '<') && ineq.a < 0;
                        if (isReverse) shadeRight = !shadeRight;
                        if (shadeRight) {
                            x = [xVal, bounds.xMax, bounds.xMax, xVal];
                            y = [bounds.yMin, bounds.yMin, bounds.yMax, bounds.yMax];
                        } else {
                            x = [bounds.xMin, xVal, xVal, bounds.xMin];
                            y = [bounds.yMin, bounds.yMin, bounds.yMax, bounds.yMax];
                        }
                    } else {
                        return;
                    }

                    data.push({
                        x: x,
                        y: y,
                        fill: 'toself',
                        fillcolor: shadeColor,
                        line: { width: 0 },
                        mode: 'lines',
                        showlegend: false,
                        hoverinfo: 'none'
                    });
                });

                if (cornerPoints.length > 0) {
                    cornerPoints.forEach((point, i) => {
                        const label = this.cornerLabels[i] || String.fromCharCode(65 + i);
                        data.push({
                            x: [point[0]],
                            y: [point[1]],
                            mode: 'markers+text',
                            marker: { size: 14, color: '#2c3e50', line: { color: 'white', width: 3 } },
                            text: [label],
                            textposition: 'top center',
                            textfont: { size: 18, family: 'Arial', weight: 'bold', color: '#2c3e50' },
                            showlegend: false,
                            hoverinfo: 'none'
                        });
                    });
                }

                const layout = {
                    plot_bgcolor: 'white',
                    paper_bgcolor: 'white',
                    xaxis: {
                        title: { text: 'x', font: { size: 20 } },
                        range: [bounds.xMin, bounds.xMax],
                        showgrid: true,
                        gridcolor: 'rgba(220, 220, 220, 0.6)',
                        gridwidth: 1,
                        zeroline: true,
                        zerolinecolor: '#333',
                        zerolinewidth: 2,
                        showline: true,
                        linecolor: '#333',
                        linewidth: 2,
                        tickfont: { size: 16 }
                    },
                    yaxis: {
                        title: { text: 'y', font: { size: 20 } },
                        range: [bounds.yMin, bounds.yMax],
                        showgrid: true,
                        gridcolor: 'rgba(220, 220, 220, 0.6)',
                        gridwidth: 1,
                        zeroline: true,
                        zerolinecolor: '#333',
                        zerolinewidth: 2,
                        showline: true,
                        linecolor: '#333',
                        linewidth: 2,
                        scaleanchor: "x",
                        scaleratio: 1,
                        tickfont: { size: 16 }
                    },
                    margin: { l: 60, r: 30, t: 30, b: 60 },
                    hovermode: false,
                    dragmode: 'pan',
                    showlegend: false
                };

                const config = {
                    responsive: true,
                    displayModeBar: true,
                    displaylogo: false,
                    modeBarButtonsToRemove: ['lasso2d', 'select2d']
                };

                if (this.plotInitialized) {
                    Plotly.react('plot', data, layout, config);
                } else {
                    Plotly.newPlot('plot', data, layout, config);
                    this.plotInitialized = true;
                }
            }

            formatCoefficient(coeff, isY) {
                if (Math.abs(coeff) < 0.0001) return '0';
                if (Math.abs(coeff - 1) < 0.0001) return isY ? 'y' : 'x';
                if (Math.abs(coeff + 1) < 0.0001) return isY ? '-y' : '-x';
                const formatted = Number.isInteger(coeff) ? coeff.toString() : coeff.toFixed(2);
                return formatted + (isY ? 'y' : 'x');
            }

            formatNumber(num) {
                if (Number.isInteger(num)) return num.toString();
                return Math.round(num * 100) / 100;
            }

            getLatexRelation(relation) {
                switch (relation) {
                    case '<': return '\\lt';
                    case '>': return '\\gt';
                    case '≤': return '\\le';
                    case '≥': return '\\ge';
                    default: return relation;
                }
            }

            clearAll() {
                if (confirm('Clear all inequalities?')) {
                    document.getElementById('inequality-inputs').innerHTML = '';
                    document.getElementById('objective-function').value = '';
                    this.updatePlot();
                }
            }

            loadExample(exampleName) {
                const examples = {
                    'feasible-region': [
                        { lhs: "x", relation: '≥', rhs: 0 },
                        { lhs: "y", relation: '≥', rhs: 0 },
                        { lhs: "2x+y", relation: '≤', rhs: 10 },
                        { lhs: "x+2y", relation: '≤', rhs: 8 }
                    ],
                    'unbounded': [
                        { lhs: "x", relation: '≥', rhs: 0 },
                        { lhs: "y", relation: '≥', rhs: 0 },
                        { lhs: "2x+y", relation: '≥', rhs: 10 },
                        { lhs: "x+2y", relation: '≥', rhs: 8 }
                    ],
                    'single-halfplane': [
                        { lhs: "x+y", relation: '≥', rhs: 3 }
                    ]
                };
                const example = examples[exampleName];
                if (!example) return;

                const container = document.getElementById('inequality-inputs');
                container.innerHTML = '';
                example.forEach(ineqData => {
                    this.addInequality(ineqData);
                });

                if (exampleName === 'feasible-region') {
                    document.getElementById('objective-function').value = '3x+4y';
                } else if (exampleName === 'unbounded') {
                    document.getElementById('objective-function').value = 'x+y';
                } else {
                    document.getElementById('objective-function').value = '';
                }

                this.updatePlot();
            }

            async playSweepAnimation() {
                // Check if we have corner points
                const inequalities = this.getInequalities();
                const objective = this.getObjective();
                const bounds = this.calculateBounds(inequalities);
                const rawCornerPoints = this.findCornerPoints(inequalities, bounds);
                const cornerPoints = this.sortPointsClockwise(rawCornerPoints);

                if (cornerPoints.length === 0) {
                    alert('No corner points found! Please ensure you have a bounded feasible region.');
                    return;
                }

                if (objective.px === 0 && objective.py === 0) {
                    alert('Please enter a valid objective function (e.g., 3x+4y)');
                    return;
                }

                // Determine optimization type
                const optType = document.getElementById('optimization-type').value;
                let isMaximize = true;

                if (optType === 'auto') {
                    // Auto-detect: check if we have max/min
                    const hasMax = this.hasMaximum(inequalities, objective);
                    const hasMin = this.hasMinimum(inequalities, objective);

                    if (!hasMax && !hasMin) {
                        alert('Cannot determine optimization type. The region appears to be unbounded in both directions.');
                        return;
                    }

                    isMaximize = hasMax;
                } else {
                    isMaximize = optType === 'maximize';
                }

                // Check if the requested optimization is possible
                if (isMaximize && !this.hasMaximum(inequalities, objective)) {
                    alert('No maximum exists! The objective function is unbounded above for this feasible region.\n\nTry minimizing instead.');
                    return;
                }
                if (!isMaximize && !this.hasMinimum(inequalities, objective)) {
                    alert('No minimum exists! The objective function is unbounded below for this feasible region.\n\nTry maximizing instead.');
                    return;
                }

                // Disable the button during animation
                const button = document.getElementById('play-sweep');
                button.disabled = true;
                button.textContent = '⏸ Animation Running...';

                // Calculate P values at all corner points
                const pValues = cornerPoints.map(p => this.evaluateObjective(p, objective));
                const minP = Math.min(...pValues);
                const maxP = Math.max(...pValues);
                const optimalP = isMaximize ? maxP : minP;
                const tolerance = 1e-6;

                // Find all corners with optimal value
                const optimalIndices = pValues.map((v, i) => Math.abs(v - optimalP) < tolerance ? i : -1).filter(i => i >= 0);

                // Calculate sweep range (extend beyond min and max for better visualization)
                const range = maxP - minP;
                const startP = isMaximize ? (minP - range * 0.3) : (maxP + range * 0.3);
                const endP = isMaximize ? (maxP + range * 0.1) : (minP - range * 0.1);

                // Show P value display
                const display = document.getElementById('p-value-display');
                display.classList.add('active');
                display.classList.remove('maximum');

                // Animation parameters
                const duration = parseInt(document.getElementById('animation-speed').value) || 3000;
                const fps = 30;
                const frames = Math.floor(duration / 1000 * fps);
                let currentFrame = 0;

                const animate = () => {
                    if (currentFrame >= frames) {
                        // Animation complete - highlight optimal
                        display.classList.add('maximum');
                        const optType = isMaximize ? 'Maximum' : 'Minimum';

                        let message;
                        if (optimalIndices.length === 1) {
                            const optimalLabel = this.cornerLabels[optimalIndices[0]];
                            message = `<strong>${optType}: P = ${this.formatNumberAsLatex(optimalP, false)} at point ${optimalLabel}</strong>`;
                        } else {
                            // Multiple corners with same optimal value
                            const labels = optimalIndices.map(i => this.cornerLabels[i]).join(', ');
                            message = `<strong>${optType}: P = ${this.formatNumberAsLatex(optimalP, false)}<br>Along edge: ${labels}</strong>`;
                        }
                        document.getElementById('p-value-text').innerHTML = message;

                        // Re-enable button after a delay
                        setTimeout(() => {
                            button.disabled = false;
                            button.textContent = '▶ Play Sweep Animation';
                            display.classList.remove('active', 'maximum');
                            this.updatePlot(); // Restore original plot
                        }, 2000);
                        return;
                    }

                    // Calculate current P value (ease-in-out for smoother animation)
                    const t = currentFrame / frames;
                    const easeT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    const currentP = startP + (endP - startP) * easeT;

                    // Update display
                    document.getElementById('p-value-text').textContent = `P = ${this.formatNumberAsLatex(currentP, false)}`;

                    // Check if we're at or near the optimal
                    const atOptimal = isMaximize ? (currentP >= optimalP - range * 0.05) : (currentP <= optimalP + range * 0.05);
                    if (atOptimal) {
                        display.style.borderColor = '#f39c12';
                        display.style.background = 'rgba(243, 156, 18, 0.95)';
                        display.style.color = 'white';
                    } else {
                        display.style.borderColor = '#3498db';
                        display.style.background = 'rgba(255, 255, 255, 0.95)';
                        display.style.color = '#2c3e50';
                    }

                    // Update plot with sweep line
                    const reachedOptimal = isMaximize ? (currentP >= optimalP) : (currentP <= optimalP);
                    this.updatePlotWithSweepLine(currentP, objective, bounds, inequalities, cornerPoints, optimalIndices, reachedOptimal);

                    currentFrame++;
                    requestAnimationFrame(animate);
                };

                animate();
            }

            updatePlotWithSweepLine(pValue, objective, bounds, inequalities, cornerPoints, optimalIndices, atOptimal) {
                const data = [];
                const isReverse = this.getShadingMode() === 'reverse';

                // Draw all inequality lines and shading
                inequalities.forEach((ineq, i) => {
                    const isStrict = ineq.relation === '<' || ineq.relation === '>';
                    const dash = isStrict ? 'dash' : 'solid';
                    const rgb = this.hexToRgb(ineq.color);
                    const shadeColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.15)`;

                    // Line trace
                    if (Math.abs(ineq.b) > 0.001) {
                        const extended = this.extendLineToEdges(ineq, bounds);
                        if (extended) {
                            data.push({
                                x: extended.x,
                                y: extended.y,
                                mode: 'lines',
                                line: { color: ineq.color, width: 3, dash: dash },
                                showlegend: false,
                                hoverinfo: 'none'
                            });
                        }
                    } else if (Math.abs(ineq.a) > 0.001) {
                        const xVal = ineq.c / ineq.a;
                        data.push({
                            x: [xVal, xVal],
                            y: [bounds.yMin - 10, bounds.yMax + 10],
                            mode: 'lines',
                            line: { color: ineq.color, width: 3, dash: dash },
                            showlegend: false,
                            hoverinfo: 'none'
                        });
                    }

                    // Shading
                    let x = [], y = [];
                    let shadeAbove = (ineq.relation === '≥' || ineq.relation === '>') && ineq.b > 0 ||
                                    (ineq.relation === '≤' || ineq.relation === '<') && ineq.b < 0;
                    if (isReverse) shadeAbove = !shadeAbove;

                    if (Math.abs(ineq.b) > 0.001) {
                        const yLeft = (ineq.c - ineq.a * bounds.xMin) / ineq.b;
                        const yRight = (ineq.c - ineq.a * bounds.xMax) / ineq.b;
                        if (shadeAbove) {
                            x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
                            y = [yLeft, yRight, bounds.yMax, bounds.yMax];
                        } else {
                            x = [bounds.xMin, bounds.xMax, bounds.xMax, bounds.xMin];
                            y = [yLeft, yRight, bounds.yMin, bounds.yMin];
                        }
                    } else if (Math.abs(ineq.a) > 0.001) {
                        const xVal = ineq.c / ineq.a;
                        let shadeRight = (ineq.relation === '≥' || ineq.relation === '>') && ineq.a > 0 ||
                                        (ineq.relation === '≤' || ineq.relation === '<') && ineq.a < 0;
                        if (isReverse) shadeRight = !shadeRight;
                        if (shadeRight) {
                            x = [xVal, bounds.xMax, bounds.xMax, xVal];
                            y = [bounds.yMin, bounds.yMin, bounds.yMax, bounds.yMax];
                        } else {
                            x = [bounds.xMin, xVal, xVal, bounds.xMin];
                            y = [bounds.yMin, bounds.yMin, bounds.yMax, bounds.yMax];
                        }
                    } else {
                        return;
                    }

                    data.push({
                        x: x,
                        y: y,
                        fill: 'toself',
                        fillcolor: shadeColor,
                        line: { width: 0 },
                        mode: 'lines',
                        showlegend: false,
                        hoverinfo: 'none'
                    });
                });

                // Draw objective function line: px*x + py*y = P
                // Rearrange to y = (P - px*x) / py
                if (Math.abs(objective.py) > 0.001) {
                    const extension = 0.5 * (bounds.xMax - bounds.xMin);
                    const x1 = bounds.xMin - extension;
                    const x2 = bounds.xMax + extension;
                    const y1 = (pValue - objective.px * x1) / objective.py;
                    const y2 = (pValue - objective.px * x2) / objective.py;

                    // Determine line color and width
                    const lineColor = atOptimal ? '#27ae60' : '#e74c3c';
                    const lineWidth = atOptimal ? 5 : 4;

                    data.push({
                        x: [x1, x2],
                        y: [y1, y2],
                        mode: 'lines',
                        line: { color: lineColor, width: lineWidth, dash: 'dashdot' },
                        name: 'Objective Line',
                        showlegend: false,
                        hoverinfo: 'none'
                    });
                } else if (Math.abs(objective.px) > 0.001) {
                    // Vertical line case: x = P / px
                    const xVal = pValue / objective.px;
                    const lineColor = atOptimal ? '#27ae60' : '#e74c3c';
                    const lineWidth = atOptimal ? 5 : 4;

                    data.push({
                        x: [xVal, xVal],
                        y: [bounds.yMin - 10, bounds.yMax + 10],
                        mode: 'lines',
                        line: { color: lineColor, width: lineWidth, dash: 'dashdot' },
                        name: 'Objective Line',
                        showlegend: false,
                        hoverinfo: 'none'
                    });
                }

                // Draw optimal edge if multiple optimal points
                if (atOptimal && optimalIndices.length > 1) {
                    // Check if optimal points are adjacent (form an edge)
                    const sortedIndices = [...optimalIndices].sort((a, b) => a - b);
                    for (let i = 0; i < sortedIndices.length - 1; i++) {
                        const idx1 = sortedIndices[i];
                        const idx2 = sortedIndices[i + 1];

                        // Check if adjacent (consecutive or wraps around)
                        const areAdjacent = (idx2 - idx1 === 1) ||
                                          (idx1 === 0 && idx2 === cornerPoints.length - 1);

                        if (areAdjacent) {
                            const p1 = cornerPoints[idx1];
                            const p2 = cornerPoints[idx2];
                            data.push({
                                x: [p1[0], p2[0]],
                                y: [p1[1], p2[1]],
                                mode: 'lines',
                                line: { color: '#27ae60', width: 6 },
                                showlegend: false,
                                hoverinfo: 'none'
                            });
                        }
                    }
                    // Check wrap-around case
                    if (sortedIndices.includes(0) && sortedIndices.includes(cornerPoints.length - 1)) {
                        const p1 = cornerPoints[0];
                        const p2 = cornerPoints[cornerPoints.length - 1];
                        data.push({
                            x: [p1[0], p2[0]],
                            y: [p1[1], p2[1]],
                            mode: 'lines',
                            line: { color: '#27ae60', width: 6 },
                            showlegend: false,
                            hoverinfo: 'none'
                        });
                    }
                }

                // Draw corner points
                if (cornerPoints.length > 0) {
                    cornerPoints.forEach((point, i) => {
                        const label = this.cornerLabels[i] || String.fromCharCode(65 + i);
                        const isOptimalPoint = optimalIndices.includes(i) && atOptimal;

                        data.push({
                            x: [point[0]],
                            y: [point[1]],
                            mode: 'markers+text',
                            marker: {
                                size: isOptimalPoint ? 20 : 14,
                                color: isOptimalPoint ? '#27ae60' : '#2c3e50',
                                line: { color: 'white', width: 3 }
                            },
                            text: [label],
                            textposition: 'top center',
                            textfont: {
                                size: isOptimalPoint ? 22 : 18,
                                family: 'Arial',
                                weight: 'bold',
                                color: isOptimalPoint ? '#27ae60' : '#2c3e50'
                            },
                            showlegend: false,
                            hoverinfo: 'none'
                        });
                    });
                }

                const layout = {
                    plot_bgcolor: 'white',
                    paper_bgcolor: 'white',
                    xaxis: {
                        title: { text: 'x', font: { size: 20 } },
                        range: [bounds.xMin, bounds.xMax],
                        showgrid: true,
                        gridcolor: 'rgba(220, 220, 220, 0.6)',
                        gridwidth: 1,
                        zeroline: true,
                        zerolinecolor: '#333',
                        zerolinewidth: 2,
                        showline: true,
                        linecolor: '#333',
                        linewidth: 2,
                        tickfont: { size: 16 }
                    },
                    yaxis: {
                        title: { text: 'y', font: { size: 20 } },
                        range: [bounds.yMin, bounds.yMax],
                        showgrid: true,
                        gridcolor: 'rgba(220, 220, 220, 0.6)',
                        gridwidth: 1,
                        zeroline: true,
                        zerolinecolor: '#333',
                        zerolinewidth: 2,
                        showline: true,
                        linecolor: '#333',
                        linewidth: 2,
                        scaleanchor: "x",
                        scaleratio: 1,
                        tickfont: { size: 16 }
                    },
                    margin: { l: 60, r: 30, t: 30, b: 60 },
                    hovermode: false,
                    dragmode: 'pan',
                    showlegend: false
                };

                const config = {
                    responsive: true,
                    displayModeBar: true,
                    displaylogo: false,
                    modeBarButtonsToRemove: ['lasso2d', 'select2d']
                };

                Plotly.react('plot', data, layout, config);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new InequalityPlotter();
        });
    </script>
</body>
</html>

