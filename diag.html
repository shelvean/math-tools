<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="description" content="A web-based tool to compute the eigenvalues, eigenvectors, and if diagonalizable, the matrices P, D, P^{-1} such that P^{-1} A P = D for a square matrix A, with a live preview of the matrix." />
  <meta name="keywords" content="diagonalization, eigenvalues, eigenvectors, matrix calculator, linear algebra, math tool" />
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LEQE004C92"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LEQE004C92');
</script>
  <title>Matrix Diagonalization Solver with Preview</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" />
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjs@14.6.0/lib/browser/math.js"></script>
  <style>
    .katex-display { margin: 1em 0; overflow-x: auto; }
    body { padding-left: 12.5vw; padding-right: 12.5vw; }
    @media (max-width: 900px) { body { padding-left: 3vw; padding-right: 3vw; }}
    .matrix-cell { width: 4rem; padding: 0.5rem; text-align: center; border: 2px solid #d1d5db; border-radius: 0.375rem; }
    .matrix-cell:hover { border-color: #3b82f6; border-width: 3px; }
    .matrix-cell:focus { outline: none; border-color: #3b82f6; }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center">
  <nav class="fixed top-0 left-0 w-full z-10 bg-white shadow-md">
    <div class="max-w-4xl mx-auto px-4 py-2">
      <ul class="flex justify-center space-x-4">
        <li><a href="index.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Home</a></li>
        <li><a href="teaching.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Teaching</a></li>
        <li><a href="projects.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Diff Eq</a></li>
        <li><a href="linear.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Linear Algebra</a></li>
        <li><a href="numerical.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Numerical Methods</a></li>
      </ul>
    </div>
  </nav>
  <div class="bg-white p-6 rounded-lg shadow-md max-w-4xl w-full mt-16 mx-auto">
    <h2 class="text-2xl font-bold mb-4 text-center text-gray-800">Matrix Diagonalization & Similarity Transform</h2>
    <p class="text-center text-gray-600 mb-4">This calculator finds the <strong>eigenvalues</strong> and <strong>eigenvectors</strong> of a square matrix $A$, and determines if $A$ is <strong>diagonalizable</strong>.<br>
    <span class="text-sm">Matrix entries can be real, complex, fractions, or expressions like $\pi$, $e$, $\sqrt{2}$, etc.</span></p>

    <!-- About Diagonalization - Collapsible -->
    <div class="bg-blue-50 border border-blue-300 rounded-lg mb-6 overflow-hidden">
      <button onclick="toggleDiagConcepts()" class="w-full p-4 text-left flex items-center justify-between hover:bg-blue-100 transition duration-200">
        <h3 class="font-bold text-lg text-blue-800">About Diagonalization & Similarity</h3>
        <span id="diagToggleIcon" class="text-blue-800 font-bold text-xl">−</span>
      </button>
      <div id="diagContent" class="px-4 pb-4">
        <p class="text-gray-700 mb-2 text-sm">If $A$ is diagonalizable, we find matrices $P$ (whose columns are eigenvectors), $D$ (diagonal matrix of eigenvalues), and $P^{-1}$ such that:</p>
        <p class="text-center mb-3">$ A = P D P^{-1} \quad \text{or equivalently} \quad D = P^{-1} A P $</p>
        <p class="text-gray-700 mb-2"><strong>Similarity Transformation:</strong></p>
        <p class="text-gray-700 mb-3 text-sm">Matrices $A$ and $D$ are <strong>similar</strong>, meaning they represent the same linear transformation in different bases.</p>
        <p class="text-gray-700 mb-2"><strong>When is $A$ diagonalizable?</strong></p>
        <ul class="text-gray-700 text-sm mb-3 ml-6 list-disc">
          <li>If $A$ has $n$ linearly independent eigenvectors (always true if eigenvalues are distinct)</li>
          <li>If $A$ is symmetric (or Hermitian), it's always orthogonally diagonalizable</li>
          <li>Algebraic multiplicity = geometric multiplicity for all eigenvalues</li>
        </ul>
        <p class="text-gray-700 mb-2"><strong>Applications:</strong></p>
        <ul class="text-gray-700 text-sm ml-6 list-disc">
          <li>Computing matrix powers: $A^k = PD^kP^{-1}$</li>
          <li>Solving systems of differential equations</li>
          <li>Principal component analysis (PCA)</li>
        </ul>
      </div>
    </div>

    <div class="bg-gray-50 p-4 rounded-lg mb-6 flex justify-center items-center space-x-4">
      <span class="text-gray-700">Matrix size:</span>
      <input type="number" id="n" min="1" required class="w-12 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
      <button type="button" onclick="generateMatrix()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 transition duration-300">Generate Matrix</button>
      <button type="button" onclick="loadExample()" class="bg-purple-500 text-white px-4 py-2 rounded hover:bg-purple-600 transition duration-300">Load Example</button>
    </div>
    <div id="matrixInput" class="mb-6 overflow-x-auto"></div>
    <div id="matrixPreview" class="mb-6 overflow-x-auto"></div>
    <div class="flex justify-center space-x-4 mb-6">
      <button id="calcBtn" type="button" class="bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-600 transition duration-300 w-1/3">Compute Diagonalization</button>
      <button id="clearBtn" type="button" class="bg-gray-500 text-white px-6 py-2 rounded hover:bg-gray-600 transition duration-300 w-1/3">Clear All</button>
    </div>
    <div id="result" class="mt-6 p-4 bg-gray-50 rounded-lg"></div>
    <div class="mt-6 border-t pt-4 text-center text-gray-500 text-sm">
    © 2025 Shelvean Kapita: kapita@tamu.edu <br>
    All code released under the MIT License. <br>
    Last modified: September 7, 2025
</div>
  </div>
  <script>
    // Initialize KaTeX rendering after scripts are loaded
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false }
        ],
        throwOnError: false,
        strict: false,
        errorCallback: function(err) {
          console.error("KaTeX rendering error:", err);
        }
      });
    });

    function toggleDiagConcepts() {
      var content = document.getElementById("diagContent");
      var icon = document.getElementById("diagToggleIcon");
      if (content.style.display === "none") {
        content.style.display = "block";
        icon.textContent = "−";
      } else {
        content.style.display = "none";
        icon.textContent = "+";
      }
    }

    function generateMatrix() {
      var n = parseInt(document.getElementById("n").value, 10);
      if (isNaN(n) || n <= 0) {
        alert("Please enter a valid positive integer for n.");
        return;
      }
      var matrixDiv = document.getElementById("matrixInput");
      matrixDiv.innerHTML = "";
      var statementDiv = document.createElement("div");
      statementDiv.className = "text-center mb-4";
      var statement = document.createElement("div");
      statement.className = "latex";
      statement.textContent = `$$ \\text{Compute the Diagonalization of } A $$`;
      statementDiv.appendChild(statement);
      var emptyStatement = document.createElement("div");
      emptyStatement.className = "latex";
      emptyStatement.textContent = `$$ \\text{(empty spaces are treated as 0)} $$`;
      statementDiv.appendChild(emptyStatement);
      matrixDiv.appendChild(statementDiv);
      var aDiv = document.createElement("div");
      aDiv.className = "flex flex-col items-center";
      var aLabel = document.createElement("p");
      aLabel.className = "text-center font-semibold latex";
      aLabel.textContent = "Matrix $A$";
      aDiv.appendChild(aLabel);
      var aTable = document.createElement("table");
      aTable.className = "border-collapse";
      for (var i = 0; i < n; i++) {
        var tr = document.createElement("tr");
        for (var j = 0; j < n; j++) {
          var td = document.createElement("td");
          td.className = "p-1";
          var input = document.createElement("input");
          input.type = "text";
          input.className = "matrix-cell";
          input.id = "A_" + i + "_" + j;
          input.addEventListener("input", updatePreview);
          td.appendChild(input);
          tr.appendChild(td);
        }
        aTable.appendChild(tr);
      }
      aDiv.appendChild(aTable);
      matrixDiv.appendChild(aDiv);
      renderMathInElement(matrixDiv, {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false }
        ],
        throwOnError: false
      });
      updatePreview();
    }

    function updatePreview() {
      var A = readMatrix(true);
      var previewDiv = document.getElementById("matrixPreview");
      previewDiv.innerHTML = "";
      if (!A) {
        previewDiv.innerHTML = `<div class="text-red-700 text-center">Invalid matrix size, please generate a valid matrix.</div>`;
        return;
      }
      try {
        var matrixLatex = matrixToLatex(A, false);
        var matrixDiv = document.createElement("div");
        matrixDiv.className = "latex";
        matrixDiv.textContent = `$$ \\text{Preview of Matrix } A: ${matrixLatex} $$`;
        previewDiv.appendChild(matrixDiv);
        renderMathInElement(previewDiv, {
          delimiters: [{ left: "$$", right: "$$", display: true }],
          throwOnError: false,
          errorCallback: function(err) {
            console.error("KaTeX rendering error in preview:", err);
            previewDiv.innerHTML = `<div class="text-red-700 text-center">Error rendering matrix preview, please check entries.</div>`;
          }
        });
      } catch (e) {
        console.error("Error generating matrix preview:", e);
        previewDiv.innerHTML = `<div class="text-red-700 text-center">Invalid input in matrix, please check entries: ${e.message}</div>`;
      }
    }

    function clearAll() {
      document.getElementById("n").value = "";
      document.getElementById("matrixInput").innerHTML = "";
      document.getElementById("matrixPreview").innerHTML = "";
      document.getElementById("result").innerHTML = "";
    }

    function parseComplex(str, allowPartial = false) {
      str = str.trim();
      if (str === '') return allowPartial ? null : math.complex(0, 0);
      if (str === 'i') return math.complex(0, 1);
      if (str === '-i') return math.complex(0, -1);
      if (str === '+i') return math.complex(0, 1);
      if (str.includes('i')) {
        if (!str.includes('+') && !str.includes('-', 1)) {
          let imagPart = str.replace('i', '');
          if (imagPart === '' || imagPart === '+') imagPart = '1';
          if (imagPart === '-') imagPart = '-1';
          try {
            const imagValue = math.evaluate(imagPart);
            return math.complex(0, imagValue);
          } catch (e) {
            if (allowPartial) {
              console.warn("Error parsing imaginary part for preview, treating as null:", str, e);
              return null;
            }
            console.error("Error parsing imaginary part:", str, e);
          }
        } else {
          const complexRegex = /^([+-]?\d*\.?\d*)([+-]\d*\.?\d*)i$/;
          const match = str.match(complexRegex);
          if (match) {
            let realPart = match[1] || '0';
            let imagPart = match[2] || '+1';
            if (realPart === '+' || realPart === '-') realPart += '0';
            if (imagPart === '+' || imagPart === '-') imagPart += '1';
            try {
              const realValue = math.evaluate(realPart);
              const imagValue = math.evaluate(imagPart);
              return math.complex(realValue, imagValue);
            } catch (e) {
              if (allowPartial) {
                console.warn("Error parsing complex number for preview, treating as null:", str, e);
                return null;
              }
              console.error("Error parsing complex number:", str, e);
            }
          }
        }
      }
      try {
        let evaluated = math.evaluate(str);
        if (typeof evaluated === 'number') {
          return math.complex(evaluated, 0);
        } else if (evaluated.re !== undefined && evaluated.im !== undefined) {
          return evaluated;
        } else {
          if (allowPartial) {
            console.warn("Invalid matrix entry for preview, treating as null:", str);
            return null;
          }
          throw new Error("Invalid matrix entry: " + str);
        }
      } catch (e) {
        if (allowPartial) {
          console.warn("Error parsing matrix entry for preview, treating as null:", str, e);
          return null;
        }
        console.error("Error parsing matrix entry:", str, e);
        throw e;
      }
    }

    function readMatrix(allowPartial = false) {
      var n = parseInt(document.getElementById("n").value, 10);
      if (isNaN(n) || n <= 0) {
        return null;
      }
      var A = [];
      for (var i = 0; i < n; i++) {
        var row = [];
        for (var j = 0; j < n; j++) {
          var cell = document.getElementById("A_" + i + "_" + j);
          if (!cell) {
            console.error(`Matrix input element A_${i}_${j} not found`);
            return null;
          }
          var value = cell.value.trim();
          var num = parseComplex(value, allowPartial);
          if (num === null && allowPartial) {
            row.push(math.complex(0, 0));
          } else {
            row.push(num);
          }
        }
        A.push(row);
      }
      return A;
    }

    function cloneMatrix(matrix) {
      if (!matrix || !Array.isArray(matrix)) {
        console.error("Invalid matrix for cloning:", matrix);
        return [];
      }
      return matrix.map(row => row.slice());
    }

    function computeRREF(origMatrix) {
      if (!origMatrix || origMatrix.length === 0) {
        console.error("Empty matrix in computeRREF");
        return { result: [], pivotRows: [], zeroRows: 0 };
      }
      var matrix = cloneMatrix(origMatrix);
      var m = matrix.length;
      var n = matrix[0].length;
      var lead = 0;
      var pivotRows = [];
      var type = typeof matrix[0][0];
      var isComplex = type !== 'number';
      var zero = isComplex ? math.complex(0, 0) : 0;
      for (var r = 0; r < m; r++) {
        if (lead >= n) break;
        var i = r;
        while (math.abs(matrix[i][lead]) < 1e-7) {
          i++;
          if (i === m) {
            i = r;
            lead++;
            if (lead === n) break;
          }
        }
        if (lead === n) break;
        if (i !== r) {
          var temp = matrix[r];
          matrix[r] = matrix[i];
          matrix[i] = temp;
        }
        var pivotValue = matrix[r][lead];
        if (math.abs(pivotValue) > 1e-7) {
          for (var j = 0; j < n; j++) {
            try {
              matrix[r][j] = math.divide(matrix[r][j], pivotValue);
            } catch (e) {
              console.error(`Error in RREF division at row ${r}, col ${j}:`, e);
              matrix[r][j] = zero;
            }
            if (typeof matrix[r][j] === 'number') {
              matrix[r][j] = Math.abs(matrix[r][j]) < 1e-10 ? 0 : matrix[r][j];
            } else {
              if (Math.abs(matrix[r][j].re) < 1e-10) matrix[r][j].re = 0;
              if (Math.abs(matrix[r][j].im) < 1e-10) matrix[r][j].im = 0;
            }
          }
        }
        for (var i = 0; i < m; i++) {
          if (i !== r) {
            var factor = matrix[i][lead];
            for (var j = 0; j < n; j++) {
              try {
                matrix[i][j] = math.subtract(matrix[i][j], math.multiply(factor, matrix[r][j]));
                if (math.abs(matrix[i][j]) < 1e-7) matrix[i][j] = zero;
              } catch (e) {
                console.error(`Error in RREF subtraction at row ${i}, col ${j}:`, e);
                matrix[i][j] = zero;
              }
              if (typeof matrix[i][j] === 'number') {
                matrix[i][j] = Math.abs(matrix[i][j]) < 1e-10 ? 0 : matrix[i][j];
              } else {
                if (Math.abs(matrix[i][j].re) < 1e-10) matrix[i][j].re = 0;
                if (Math.abs(matrix[i][j].im) < 1e-10) matrix[i][j].im = 0;
              }
            }
          }
        }
        pivotRows.push(r);
        lead++;
      }
      var zeroRows = 0;
      for (var r = 0; r < m; r++) {
        var isZeroRow = true;
        for (var j = 0; j < n; j++) {
          if (math.abs(matrix[r][j]) > 1e-7) {
            isZeroRow = false;
            break;
          }
        }
        if (isZeroRow) zeroRows++;
      }
      return { result: matrix, pivotRows: pivotRows, zeroRows: zeroRows };
    }

    function getPivotColumns(rref) {
      var m = rref.length;
      if (m === 0) return [];
      var n = rref[0].length;
      var pivots = [];
      var col = 0;
      for (var row = 0; row < m; row++) {
        while (col < n && math.abs(rref[row][col]) < 1e-7) {
          col++;
        }
        if (col < n) {
          pivots.push(col);
          col++;
        }
      }
      return pivots;
    }

    function computeNullSpace(A) {
      if (!A || A.length === 0) {
        console.error("Empty matrix in computeNullSpace");
        return { basis: [], zeroRows: 0 };
      }
      var computation = computeRREF(A);
      var rref = computation.result;
      var pivotCols = getPivotColumns(rref);
      var rank = pivotCols.length;
      var n = A[0].length;
      var freeColumns = [];
      for (var j = 0; j < n; j++) {
        if (!pivotCols.includes(j)) {
          freeColumns.push(j);
        }
      }
      var nullSpaceBasis = [];
      var type = typeof A[0][0];
      var isComplex = type !== 'number';
      var zero = isComplex ? math.complex(0, 0) : 0;
      var one = isComplex ? math.complex(1, 0) : 1;
      for (var k = 0; k < freeColumns.length; k++) {
        var j = freeColumns[k];
        var vec = new Array(n).fill(zero);
        vec[j] = one;
        for (var i = 0; i < rank; i++) {
          var p = pivotCols[i];
          vec[p] = math.multiply(rref[i][j], -1);
        }
        nullSpaceBasis.push(vec);
      }
      return { basis: nullSpaceBasis, zeroRows: computation.zeroRows };
    }

    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      while (b !== 0) {
        let temp = b;
        b = a % b;
        a = temp;
      }
      return a;
    }

    function lcm(a, b) {
      return Math.abs(a * b) / gcd(a, b);
    }

    function isShortDecimal(num) {
      if (Math.abs(num) < 1e-12) return false;
      let str = num.toFixed(10).replace(/\.?0+$/, '');
      let decimalPart = str.split('.')[1];
      if (!decimalPart) return false;
      let nonZeroCount = (decimalPart.match(/[1-9]/g) || []).length;
      return nonZeroCount <= 4;
    }

    function floatToFraction(num, tolerance = 1e-6, maxIter = 30) {
      if (Math.abs(num) < 1e-12) return { numer: 0, denom: 1 };
      let sign = Math.sign(num);
      num = Math.abs(num);
      let a = Math.floor(num);
      let h = a;
      let k = 1;
      let hPrev = 1;
      let kPrev = 0;
      let x = num - a;
      let iter = 0;
      while (x > tolerance && iter < maxIter) {
        x = 1 / x;
        a = Math.floor(x);
        let hTemp = a * h + hPrev;
        let kTemp = a * k + kPrev;
        hPrev = h;
        kPrev = k;
        h = hTemp;
        k = kTemp;
        x -= a;
        iter++;
        if (Math.abs(num - h / k) < tolerance) break;
      }
      return { numer: sign * h, denom: k };
    }

    function isPerfectSquare(n) {
      let sqrt = Math.floor(Math.sqrt(n));
      return sqrt * sqrt === n ? sqrt : null;
    }

    function decimalToSurd(num, tolerance = 1e-6) {
      if (Math.abs(num) < 1e-12) return null;
      let sign = Math.sign(num);
      num = Math.abs(num);
      const maxB = 100;
      const coefficients = [1, 0.5, 2, 0.25, 0.3333333333, 0.6666666667, 1.5];
      for (let a of coefficients) {
        for (let b = 1; b <= maxB; b++) {
          let sqrtB = isPerfectSquare(b);
          let value = sqrtB ? a * sqrtB : a * Math.sqrt(b);
          if (Math.abs(num - value) < tolerance) {
            if (sqrtB) {
              let newA = a * sqrtB;
              let frac = floatToFraction(newA);
              if (Math.abs(frac.numer) < 10 && frac.denom < 10) {
                return { coef: sign * frac.numer, denom: frac.denom, radicand: null };
              }
              return { coef: sign * newA, denom: 1, radicand: null };
            }
            if (a === 1) return { coef: sign, radicand: b };
            let frac = floatToFraction(a);
            if (Math.abs(frac.numer) < 10 && frac.denom < 10) {
              return { coef: sign * frac.numer, denom: frac.denom, radicand: b };
            }
          }
        }
      }
      return null;
    }

    function formatForLatex(val, isEigenvalueOrVector = false) {
      if (typeof val === 'number') {
        if (Math.abs(val) < 1e-12) return "0";
        if (Math.abs(val - Math.round(val)) < 1e-12) return Math.round(val).toString();
        if (isEigenvalueOrVector) {
          let surd = decimalToSurd(val);
          if (surd) {
            if (surd.radicand === null) {
              if (surd.denom === 1) return surd.coef.toString();
              return `${surd.coef}/${surd.denom}`;
            }
            let coefStr = Math.abs(surd.coef) === 1 ? (surd.coef === -1 ? '-' : '') : Math.abs(surd.coef);
            if (surd.denom) {
              return `${coefStr === '' ? 1 : coefStr}\\sqrt{${surd.radicand}}/${surd.denom}`;
            }
            return `${coefStr === '' ? '' : coefStr}\\sqrt{${surd.radicand}}`;
          }
        }
        let fraction = floatToFraction(val);
        let isFraction = Math.abs(val - fraction.numer / fraction.denom) < 1e-6;
        if ((isShortDecimal(val) || isFraction) && Math.abs(fraction.numer) < 10 && fraction.denom < 10) {
          if (fraction.denom === 1) return fraction.numer.toString();
          return `${fraction.numer}/${fraction.denom}`;
        } else {
          return val.toFixed(4).replace(/\.?0+$/, '');
        }
      } else if (val.re !== undefined && val.im !== undefined) {
        let re = Math.abs(val.re) < 1e-12 ? 0 : val.re;
        let im = Math.abs(val.im) < 1e-12 ? 0 : val.im;
        let reFrac = floatToFraction(re);
        let imFrac = floatToFraction(Math.abs(im));
        let isReFraction = Math.abs(re - reFrac.numer / reFrac.denom) < 1e-6 && Math.abs(reFrac.numer) < 10 && reFrac.denom < 10;
        let isImFraction = Math.abs(Math.abs(im) - imFrac.numer / imFrac.denom) < 1e-6 && Math.abs(imFrac.numer) < 10 && imFrac.denom < 10;
        let rePart, imPart;
        if (isEigenvalueOrVector) {
          let reSurd = decimalToSurd(re);
          let imSurd = decimalToSurd(Math.abs(im));
          rePart = re === 0 ? "0" : (reSurd ? (reSurd.radicand === null ? (reSurd.denom === 1 ? reSurd.coef.toString() : `${reSurd.coef}/${reSurd.denom}`) : (reSurd.denom ? `${Math.abs(reSurd.coef) === 1 ? (reSurd.coef === -1 ? '-' : '') : Math.abs(reSurd.coef)}\\sqrt{${reSurd.radicand}}/${reSurd.denom}` : `${reSurd.coef === -1 ? '-' : reSurd.coef === 1 ? '' : reSurd.coef}\\sqrt{${reSurd.radicand}}`)) : (isReFraction ? (reFrac.denom === 1 ? reFrac.numer.toString() : `${reFrac.numer}/${reFrac.denom}`) : re.toFixed(4).replace(/\.?0+$/, '')));
          imPart = im === 0 ? "0" : (imSurd ? (imSurd.radicand === null ? (imSurd.denom === 1 ? imSurd.coef.toString() : `${imSurd.coef}/${imSurd.denom}`) : (imSurd.denom ? `${Math.abs(imSurd.coef) === 1 ? (imSurd.coef === -1 ? '-' : '') : imSurd.coef}\\sqrt{${imSurd.radicand}}/${imSurd.denom}` : `${imSurd.coef === 1 ? '' : imSurd.coef}\\sqrt{${imSurd.radicand}}`)) : (isImFraction ? (imFrac.denom === 1 ? imFrac.numer.toString() : `${imFrac.numer}/${imFrac.denom}`) : Math.abs(im).toFixed(4).replace(/\.?0+$/, '')));
        } else {
          rePart = re === 0 ? "0" : (isReFraction ? (reFrac.denom === 1 ? reFrac.numer.toString() : `${reFrac.numer}/${reFrac.denom}`) : re.toFixed(4).replace(/\.?0+$/, ''));
          imPart = im === 0 ? "0" : (isImFraction ? (imFrac.denom === 1 ? imFrac.numer.toString() : `${imFrac.numer}/${imFrac.denom}`) : Math.abs(im).toFixed(4).replace(/\.?0+$/, ''));
        }
        if (rePart === "0" && imPart === "0") return "0";
        if (imPart === "0") return rePart;
        let imSign = im < 0 ? '-' : '+';
        if (imPart === "1") imPart = '';
        let imStr = imPart ? `${imPart}i` : 'i';
        if ((isImFraction || (isEigenvalueOrVector && decimalToSurd(Math.abs(im)))) && imStr.includes('i')) {
          let [numer, denom] = imStr.replace('i', '').split('/').map(s => s.trim());
          if (numer === '' || numer === '1') {
            imStr = 'i' + (denom ? `/${denom}` : '');
          } else {
            imStr = `${numer}i` + (denom ? `/${denom}` : '');
          }
          imStr = denom && denom !== '1' ? `${numer === '' || numer === '1' ? '' : numer}i/${denom}` : (numer === '' || numer === '1' ? 'i' : `${numer}i`);
        }
        if (rePart === "0") {
          return im < 0 ? `-${imStr}` : imStr;
        }
        return `${rePart} ${imSign} ${imStr}`;
      }
      return val.toString();
    }

    function matrixToLatex(M, isEigenvalueOrVector = false) {
      if (!M || M.length === 0) return '';
      const rows = M.length;
      const cols = M[0].length;
      if (rows === 1 && cols === 1) return formatForLatex(M[0][0], isEigenvalueOrVector);
      let hasFractions = M.some(row => row.some(val => {
        if (typeof val === 'number') {
          return isShortDecimal(val) || (Math.abs(val - Math.round(val)) > 1e-12 && Math.abs(val - floatToFraction(val).numer / floatToFraction(val).denom) < 1e-6);
        } else {
          let re = Math.abs(val.re) < 1e-12 ? 0 : val.re;
          let im = Math.abs(val.im) < 1e-12 ? 0 : val.im;
          if (Math.abs(im) < 1e-12) return false;
          let reFrac = floatToFraction(re);
          let imFrac = floatToFraction(im);
          let isReFraction = Math.abs(re - reFrac.numer / reFrac.denom) < 1e-6 && Math.abs(reFrac.numer) < 10 && reFrac.denom < 10;
          let isImFraction = Math.abs(Math.abs(im) - imFrac.numer / imFrac.denom) < 1e-6 && Math.abs(imFrac.numer) < 10 && imFrac.denom < 10;
          return isReFraction || isImFraction;
        }
      }));
      let latex = "\\begin{bmatrix}";
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          latex += formatForLatex(M[i][j], isEigenvalueOrVector);
          if (j < cols - 1) latex += " & ";
        }
        if (i < rows - 1) {
          latex += hasFractions ? " \\\\[0.5em] " : " \\\\ ";
        }
      }
      latex += "\\end{bmatrix}";
      return latex;
    }

    function vectorToLatex(v) {
      if (!v || v.length === 0) {
        console.error("Empty or invalid vector in vectorToLatex");
        return { latex: '\\begin{bmatrix} 0 \\end{bmatrix}', scaledVector: [0] };
      }
      const rows = v.length;
      let isComplexVector = v.some(x => typeof x !== 'number' && Math.abs(x.im) > 1e-12);
      let scaleEntry;
      if (isComplexVector) {
        let nonZero = [];
        v.forEach(x => {
          let mag = math.abs(x);
          if (mag > 1e-12) {
            nonZero.push({ mag, entry: x });
          }
        });
        if (nonZero.length === 0) {
          console.warn("Zero vector encountered in vectorToLatex");
          return { latex: matrixToLatex([v]), scaledVector: v };
        }
        let minItem = nonZero.reduce((min, item) => item.mag < min.mag ? item : min, nonZero[0]);
        scaleEntry = minItem.entry;
      } else {
        let nonPositive = [];
        v.forEach(x => {
          let realVal = typeof x === 'number' ? x : x.re;
          if (Math.abs(realVal) > 1e-12 && realVal <= 0) {
            nonPositive.push({ val: realVal, mag: Math.abs(realVal) });
          }
        });
        if (nonPositive.length === 0) {
          let nonZero = [];
          v.forEach(x => {
            let realVal = typeof x === 'number' ? x : x.re;
            if (Math.abs(realVal) > 1e-12) {
              nonZero.push({ val: realVal, mag: Math.abs(realVal) });
            }
          });
          if (nonZero.length === 0) {
            console.warn("Zero vector encountered in vectorToLatex");
            return { latex: matrixToLatex([v]), scaledVector: v };
          }
          let minItem = nonZero.reduce((min, item) => item.mag < min.mag ? item : min, nonZero[0]);
          scaleEntry = minItem.val;
        } else {
          let minItem = nonPositive.reduce((min, item) => item.mag < min.mag ? item : min, nonPositive[0]);
          scaleEntry = minItem.val;
        }
      }
      let adjustedV = [];
      try {
        adjustedV = v.map(x => math.divide(x, scaleEntry));
      } catch (e) {
        console.error("Error scaling vector in vectorToLatex:", e);
        return { latex: matrixToLatex([v]), scaledVector: v };
      }
      let denoms = [];
      adjustedV.forEach(x => {
        let re = typeof x === 'number' ? x : x.re;
        let im = typeof x === 'number' ? 0 : x.im;
        if (Math.abs(re - Math.round(re)) > 1e-12 && (isShortDecimal(re) || Math.abs(re - floatToFraction(re).numer / floatToFraction(re).denom) < 1e-6)) {
          let frac = floatToFraction(re);
          if (Math.abs(frac.numer) < 10 && frac.denom < 10) {
            denoms.push(frac.denom);
          }
        }
        if (Math.abs(im - Math.round(im)) > 1e-12 && (isShortDecimal(im) || Math.abs(im - floatToFraction(im).numer / floatToFraction(im).denom) < 1e-6)) {
          let frac = floatToFraction(im);
          if (Math.abs(frac.numer) < 10 && frac.denom < 10) {
            denoms.push(frac.denom);
          }
        }
      });
      if (denoms.length > 0) {
        let lcmDenom = denoms.reduce((a, b) => lcm(a, b), 1);
        try {
          adjustedV = adjustedV.map(x => math.multiply(x, lcmDenom));
          let gcdVal = 0;
          adjustedV.forEach(x => {
            let re = Math.round(typeof x === 'number' ? x : x.re);
            let im = Math.round(typeof x === 'number' ? 0 : x.im);
            if (Math.abs(re) > 0.5) gcdVal = gcd(gcdVal, Math.abs(re));
            if (Math.abs(im) > 0.5) gcdVal = gcd(gcdVal, Math.abs(im));
          });
          if (gcdVal > 1) {
            adjustedV = adjustedV.map(x => math.divide(x, gcdVal));
          }
        } catch (e) {
          console.error("Error in fraction conversion in vectorToLatex:", e);
        }
      }
      let positiveCount = 0;
      let negativeCount = 0;
      adjustedV.forEach(x => {
        let re = typeof x === 'number' ? x : x.re;
        let im = typeof x === 'number' ? 0 : x.im;
        if (Math.abs(re) > 1e-12) {
          if (re > 0) positiveCount++;
          if (re < 0) negativeCount++;
        }
        if (Math.abs(im) > 1e-12) {
          if (im > 0) positiveCount++;
          if (im < 0) negativeCount++;
        }
      });
      if (negativeCount > positiveCount) {
        adjustedV = adjustedV.map(x => math.multiply(x, -1));
      }
      let canNegate = adjustedV.every(x => {
        let re = typeof x === 'number' ? x : x.re;
        let im = typeof x === 'number' ? 0 : x.im;
        return (Math.abs(re) < 1e-12 || re <= 0) && (Math.abs(im) < 1e-12 || im <= 0);
      });
      if (canNegate) {
        adjustedV = adjustedV.map(x => math.multiply(x, -1));
      }
      let hasFractions = adjustedV.some(val => {
        if (typeof val === 'number') {
          return isShortDecimal(val) || (Math.abs(val - Math.round(val)) > 1e-12 && Math.abs(val - floatToFraction(val).numer / floatToFraction(val).denom) < 1e-6);
        } else {
          let re = Math.abs(val.re) < 1e-12 ? 0 : val.re;
          let im = Math.abs(val.im) < 1e-12 ? 0 : val.im;
          if (Math.abs(im) < 1e-12) return false;
          let reFrac = floatToFraction(re);
          let imFrac = floatToFraction(im);
          let isReFraction = Math.abs(re - reFrac.numer / reFrac.denom) < 1e-6 && Math.abs(reFrac.numer) < 10 && reFrac.denom < 10;
          let isImFraction = Math.abs(Math.abs(im) - imFrac.numer / imFrac.denom) < 1e-6 && Math.abs(imFrac.numer) < 10 && imFrac.denom < 10;
          return isReFraction || isImFraction;
        }
      });
      let latex = "\\begin{bmatrix}";
      for (let i = 0; i < rows; i++) {
        latex += formatForLatex(adjustedV[i], true);
        if (i < rows - 1) {
          latex += hasFractions ? " \\\\[0.5em] " : " \\\\ ";
        }
      }
      latex += "\\end{bmatrix}";
      return { latex, scaledVector: adjustedV };
    }

    function getKey(val) {
      if (typeof val === 'number') {
        return Math.abs(val) < 1e-7 ? '0' : val.toFixed(10);
      } else {
        let re = Math.abs(val.re) < 1e-7 ? 0 : val.re;
        let im = Math.abs(val.im) < 1e-7 ? 0 : val.im;
        return re.toFixed(10) + ',' + im.toFixed(10);
      }
    }

    function isZeroValue(val) {
      if (typeof val === 'number') {
        return Math.abs(val) < 1e-7;
      } else {
        return Math.abs(val.re) < 1e-7 && Math.abs(val.im) < 1e-7;
      }
    }

    function computeEigenvectors(A, lambda, algMultiplicity, isComplex) {
      const n = A.length;
      let eigenvectors = [];
      let geometricMultiplicity = 0;
      if (isComplex) {
        try {
          const A_math = math.matrix(A);
          const result = math.eigs(A_math);
          const evs = result.eigenvectors;
          for (let ev of evs) {
            if (Math.abs(math.subtract(ev.value, lambda).re) < 1e-7 && Math.abs(math.subtract(ev.value, lambda).im) < 1e-7) {
              let vec = ev.vector.toArray().flat();
              if (vec.every(v => isZeroValue(v))) {
                console.warn("Zero eigenvector skipped for eigenvalue:", lambda);
                continue;
              }
              eigenvectors.push(vec);
            }
          }
          geometricMultiplicity = eigenvectors.length;
        } catch (e) {
          console.error(`Failed to compute eigenvectors for complex eigenvalue ${lambda}:`, e);
          return { vectors: [], geometricMultiplicity: 0 };
        }
      } else {
        let currentMatrix = math.identity(n);
        for (let k = 1; k <= algMultiplicity; k++) {
          let A_minus_lambdaI = A.map((row, i) => row.map((val, j) => {
            let result = i === j ? math.subtract(val, lambda) : val;
            return typeof result === 'number' ? result : math.complex(result.re, result.im);
          }));
          let tempMatrix;
          try {
            tempMatrix = k === 1 ? math.matrix(A_minus_lambdaI) : math.multiply(currentMatrix, math.matrix(A_minus_lambdaI));
          } catch (e) {
            console.error(`Matrix multiplication failed at k=${k}:`, e);
            return { vectors: eigenvectors, geometricMultiplicity };
          }
          currentMatrix = tempMatrix.toArray ? tempMatrix.toArray() : tempMatrix;
          let nullspaceResult = computeNullSpace(currentMatrix);
          let newVectors = nullspaceResult.basis;
          newVectors.forEach(vec => {
            let isIndependent = true;
            if (eigenvectors.length > 0) {
              let testMatrix = eigenvectors.map(ev => ev.slice());
              testMatrix.push(vec.slice());
              let rank = computeRREF(testMatrix).pivotRows.length;
              if (rank <= eigenvectors.length) isIndependent = false;
            }
            if (isIndependent) eigenvectors.push(vec);
          });
          if (k === 1) geometricMultiplicity = eigenvectors.length;
          if (eigenvectors.length >= algMultiplicity) break;
        }
      }
      return { vectors: eigenvectors.slice(0, algMultiplicity), geometricMultiplicity };
    }

    function computeInverse(mat) {
      const n = mat.length;
      let augmented = mat.map((row, i) => row.slice().concat(Array.from({length: n}, (_, j) => i === j ? math.complex(1,0) : math.complex(0,0))));
      for (let r = 0; r < n; r++) {
        let maxRow = r;
        let maxVal = math.abs(augmented[r][r]);
        for (let k = r + 1; k < n; k++) {
          let val = math.abs(augmented[k][r]);
          if (val > maxVal) {
            maxVal = val;
            maxRow = k;
          }
        }
        if (maxVal < 1e-7) {
          return null;
        }
        if (maxRow !== r) {
          let temp = augmented[r];
          augmented[r] = augmented[maxRow];
          augmented[maxRow] = temp;
        }
        let pivot = augmented[r][r];
        for (let j = 0; j < 2*n; j++) {
          augmented[r][j] = math.divide(augmented[r][j], pivot);
        }
        for (let k = 0; k < n; k++) {
          if (k !== r) {
            let factor = augmented[k][r];
            for (let j = 0; j < 2*n; j++) {
              augmented[k][j] = math.subtract(augmented[k][j], math.multiply(factor, augmented[r][j]));
            }
          }
        }
      }
      let inv = augmented.map(row => row.slice(n));
      return inv;
    }

    document.getElementById("clearBtn").addEventListener("click", clearAll);
    document.getElementById("calcBtn").addEventListener("click", function () {
      var A = readMatrix();
      if (A === null) {
        document.getElementById("result").innerHTML = `<div class="text-red-700 text-center font-bold">Error: Invalid matrix input</div>`;
        return;
      }
      var resultDiv = document.getElementById("result");
      var n = A.length;
      try {
        const A_math = math.matrix(A);
        let result;
        try {
          result = math.eigs(A_math);
        } catch (e) {
          console.error("Error in eigenvalue computation:", e);
          throw new Error("Failed to compute eigenvalues: " + e.message);
        }
        const eigenvalues = result.values.toArray();
        if (!eigenvalues || eigenvalues.length === 0) {
          throw new Error("No eigenvalues computed");
        }
        const evGroups = new Map();
        for (let val of eigenvalues) {
          let key = getKey(val);
          if (!evGroups.has(key)) evGroups.set(key, []);
          evGroups.get(key).push(val);
        }
        const algMultMap = new Map();
        const distinctLambdas = [];
        for (let [key, list] of evGroups) {
          let sum = list.reduce((acc, v) => math.add(math.complex(v), acc), math.complex(0, 0));
          let avg = math.divide(sum, list.length);
          if (Math.abs(avg.im) < 1e-7) avg.im = 0;
          if (Math.abs(avg.re) < 1e-7) avg.re = 0;
          if (avg.im === 0) avg = avg.re;
          distinctLambdas.push(avg);
          let newKey = getKey(avg);
          algMultMap.set(newKey, list.length);
        }
        const eigenMap = new Map();
        let hasGeneralizedEigenvectors = false;
        for (let lambda of distinctLambdas) {
          const key = getKey(lambda);
          const algMultiplicity = algMultMap.get(key) || 1;
          const isComplex = typeof lambda !== 'number' && Math.abs(lambda.im) > 1e-7;
          let evResult;
          try {
            evResult = computeEigenvectors(A, lambda, algMultiplicity, isComplex);
          } catch (e) {
            console.error(`Error computing eigenvectors for lambda ${lambda}:`, e);
            throw new Error(`Failed to compute eigenvectors for eigenvalue ${lambda}: ${e.message}`);
          }
          if (evResult.vectors.length > 0) {
            eigenMap.set(key, { value: lambda, vectors: evResult.vectors, geometricMultiplicity: evResult.geometricMultiplicity });
            if (!isComplex && evResult.vectors.length > evResult.geometricMultiplicity) {
              hasGeneralizedEigenvectors = true;
            }
          }
        }
        let sortedPairs = Array.from(eigenMap.values()).sort((a, b) => math.abs(a.value) - math.abs(b.value));
        const A_latex = matrixToLatex(A);
        let align_content = sortedPairs.map((pair, index) => {
          const lambda_latex = formatForLatex(pair.value, true);
          const key = getKey(pair.value);
          const algMultiplicity = algMultMap.get(key) || pair.vectors.length;
          const mult_latex = algMultiplicity >= 2 ? `(\\text{multiplicity } ${algMultiplicity})` : '';
          const vecs_latex = pair.vectors.map((vec, vecIndex) => {
            try {
              const { latex } = vectorToLatex(vec);
              if (vecIndex < pair.geometricMultiplicity) {
                return latex;
              } else {
                return `\\textcolor{blue}{${latex}}`;
              }
            } catch (e) {
              console.error(`Error formatting vector ${vecIndex} for eigenvalue ${pair.value}:`, e);
              return "\\text{error}";
            }
          }).join(', \\quad ');
          return `\\lambda_{${index + 1}} = ${lambda_latex}${mult_latex ? '\\,' : ''}${mult_latex}, \\quad ${vecs_latex}`;
        }).join(' \\\\ ');
        let resultHtml = `
          <div class="latex text-center">$$ \\text{Matrix Diagonalization } P^{-1}AP = D $$</div>
          <div class="latex">$$ A = ${A_latex} $$</div>
          <div class="latex">$$ \\text{Eigenvalues and Eigenvectors:} $$</div>
          <div class="latex">$$ \\begin{align*} ${align_content} \\end{align*} $$</div>
        `;
        if (hasGeneralizedEigenvectors) {
          resultHtml += `
            <div class="latex">$$ \\text{Eigenvectors}, \\quad \\textcolor{blue}{\\text{Generalized Eigenvectors}} $$</div>
            <div class="latex text-center">$$ \\textcolor{red}{\\text{Matrix cannot be diagonalized - not enough eigenvectors}} $$</div>
          `;
        } else {
          let total_vecs = sortedPairs.reduce((sum, pair) => sum + pair.vectors.length, 0);
          if (total_vecs === n) {
            let allScaledVectors = [];
            let lambdas = [];
            for (let pair of sortedPairs) {
              for (let vec of pair.vectors) {
                let { scaledVector } = vectorToLatex(vec);
                allScaledVectors.push(scaledVector);
              }
              for (let i = 0; i < pair.vectors.length; i++) {
                lambdas.push(pair.value);
              }
            }
            let P = Array.from({length: n}, () => Array(n).fill(math.complex(0,0)));
            for (let col = 0; col < n; col++) {
              for (let row = 0; row < n; row++) {
                P[row][col] = allScaledVectors[col][row];
              }
            }
            let D = Array.from({length: n}, () => Array(n).fill(math.complex(0,0)));
            for (let i = 0; i < n; i++) {
              D[i][i] = lambdas[i];
            }
            let Pinv = computeInverse(P);
            if (Pinv) {
              let P_latex = matrixToLatex(P);
              let D_latex = matrixToLatex(D, true);
              let Pinv_latex = matrixToLatex(Pinv, false);
              resultHtml += `
                <div class="latex text-center">$$ P^{-1}AP = D $$</div>
                <div class="latex">$$ P = ${P_latex}, \\quad D = ${D_latex}, \\quad P^{-1} = ${Pinv_latex} $$</div>
              `;
            } else {
              resultHtml += `
                <div class="latex text-center">$$ \\text{Matrix cannot be diagonalized - P is singular} $$</div>
              `;
            }
          } else {
            resultHtml += `
              <div class="latex text-center">$$ \\text{Matrix cannot be diagonalized - not enough eigenvectors} $$</div>
            `;
          }
        }
        resultDiv.innerHTML = resultHtml;
        renderMathInElement(resultDiv, {
          delimiters: [{ left: "$$", right: "$$", display: true }],
          throwOnError: false
        });
      } catch (e) {
        console.error("Detailed error in computation:", e);
        resultDiv.innerHTML = `<div class="text-red-700 text-center font-bold">Error: ${e.message || "Computation failed, please check matrix input"}</div>`;
      }
    });

    function loadExample() {
      // Set size to 4 and generate matrix
      document.getElementById("n").value = "4";
      generateMatrix();

      // Wait for matrix to be generated, then populate with example values
      setTimeout(() => {
        // Block diagonal matrix with complex eigenvalues
        document.getElementById("A_0_0").value = "1";
        document.getElementById("A_0_1").value = "-2";
        document.getElementById("A_0_2").value = "0";
        document.getElementById("A_0_3").value = "0";
        document.getElementById("A_1_0").value = "2";
        document.getElementById("A_1_1").value = "1";
        document.getElementById("A_1_2").value = "0";
        document.getElementById("A_1_3").value = "0";
        document.getElementById("A_2_0").value = "0";
        document.getElementById("A_2_1").value = "0";
        document.getElementById("A_2_2").value = "3";
        document.getElementById("A_2_3").value = "0";
        document.getElementById("A_3_0").value = "0";
        document.getElementById("A_3_1").value = "0";
        document.getElementById("A_3_2").value = "0";
        document.getElementById("A_3_3").value = "-1";

        // Trigger preview update
        updatePreview();

        // Add example explanation
        const resultDiv = document.getElementById("result");
        resultDiv.innerHTML = `
          <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
            <h3 class="font-bold text-lg mb-2 text-blue-800">Example Loaded:</h3>
            <p class="text-gray-700 mb-2">This example diagonalizes the block diagonal matrix:</p>
            <p class="text-center">$$ A = \\begin{pmatrix} 1 & -2 & 0 & 0 \\\\ 2 & 1 & 0 & 0 \\\\ 0 & 0 & 3 & 0 \\\\ 0 & 0 & 0 & -1 \\end{pmatrix} $$</p>
            <p class="text-gray-700 mt-2">This matrix has eigenvalues $\\lambda = 1 \\pm 2i$ (complex conjugate pair from the upper-left 2×2 block), $\\lambda = 3$, and $\\lambda = -1$.</p>
            <p class="text-gray-700 mt-2">The diagonalization will show $A = PDP^{-1}$ where $D$ is the diagonal matrix of eigenvalues and $P$ contains the eigenvectors as columns.</p>
            <p class="text-gray-700 mt-3 text-sm italic">Click "Compute Diagonalization" to see the complete similarity transformation.</p>
          </div>
        `;
        renderMathInElement(resultDiv, {
          delimiters: [{ left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }],
          throwOnError: false
        });
      }, 100);
    }
  </script>
</body>

</html>

