<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="description" content="A web-based tool to compute the Least Squares Solution of a matrix system Ax ≈ b using QR Decomposition. Input the matrix dimensions, values for matrix A and vector b (empty spaces treated as 0), and calculate the solution with options for decimal or fraction output." />
  <meta name="keywords" content="Least Squares, QR Decomposition, Matrix Solver, System of Equations, Ax=b, Compute Least Squares Solution online" />
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5B8PRB2WZT"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-5B8PRB2WZT');
  </script>
  <title>Least Squares Solver (QR Decomposition)</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" />
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjs@14.6.0/lib/browser/math.js"></script>
  <style>
    .katex-display { margin: 1em 0; overflow-x: auto; }
    body { padding-left: 12.5vw; padding-right: 12.5vw; }
    @media (max-width: 900px) { body { padding-left: 3vw; padding-right: 3vw; } }
    .matrix-cell { width: 4rem; padding: 0.5rem; text-align: center; border: 2px solid #d1d5db; border-radius: 0.375rem; }
    .matrix-cell:hover { border-color: #3b82f6; border-width: 3px; }
    .matrix-cell:focus { outline: none; border-color: #3b82f6; }
    #result, #result * { color: #080808; }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center">
  <div class="nav-container w-full fixed top-0 z-10 bg-white shadow-md">
    <nav class="max-w-4xl mx-auto py-4">
      <ul class="flex justify-center gap-8">
        <li><a href="index.html" class="text-indigo-500 hover:text-blue-600 transition-colors font-bold text-xl">Home</a></li>
        <li><a href="teaching.html" class="text-indigo-500 hover:text-blue-600 transition-colors font-bold text-xl">Teaching</a></li>
        <li><a href="projects.html" class="text-indigo-500 hover:text-blue-600 transition-colors font-bold text-xl">Diff Eq</a></li>
        <li><a href="linear.html" class="text-indigo-500 hover:text-blue-600 transition-colors font-bold text-xl">Linear Algebra</a></li>
        <li><a href="numerical.html" class="text-indigo-500 hover:text-blue-600 transition-colors font-bold text-xl">Numerical Methods</a></li>
      </ul>
    </nav>
  </div>

  <div class="bg-white p-6 rounded-lg shadow-md max-w-4xl w-full mt-16">
    <h2 class="text-2xl font-bold mb-4 text-center text-gray-800">Least Squares Solver using QR Decomposition</h2>
    <p class="text-center text-gray-600 mb-6">
      Enter the number of equations <span class="latex">\( m \)</span> and variables <span class="latex">\( n \)</span>,
      generate the input fields, fill in the matrix \( A \) and vector \( \mathbf{b} \), and then compute the least squares solution for \( A \mathbf{x} \approx \mathbf{b} \).
    </p>

    <div class="bg-gray-50 p-4 rounded-lg mb-6 flex justify-center items-center space-x-4">
      <span class="text-gray-700">Number of equations <span class="latex">\( m \)</span>:</span>
      <input type="number" id="m" min="1" required class="w-16 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
      <span class="text-gray-700">Number of variables <span class="latex">\( n \)</span>:</span>
      <input type="number" id="n" min="1" required class="w-16 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
      <button type="button" onclick="generateMatrix()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 transition duration-300">Generate Matrix</button>
    </div>

    <div class="flex justify-center mb-6 space-x-6">
      <span class="text-gray-700">Final Output as:</span>
      <label class="flex items-center">
        <input type="radio" name="displayMode" value="decimal" class="mr-2">
        <span>Decimal</span>
      </label>
      <label class="flex items-center">
        <input type="radio" name="displayMode" value="fraction" checked class="mr-2">
        <span>Fraction</span>
      </label>
    </div>

    <div id="matrixInput" class="mb-6 overflow-x-auto"></div>

    <div class="flex justify-center space-x-4 mb-6">
      <button id="calcBtn" type="button" class="bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-600 transition duration-300 w-1/3">Solve</button>
      <button id="clearBtn" type="button" class="bg-gray-500 text-white px-6 py-2 rounded hover:bg-gray-600 transition duration-300 w-1/3">Clear All</button>
    </div>

    <div id="result" class="mt-6 p-4 bg-gray-50 rounded-lg"></div>

    <div class="mt-6 border-t pt-4 text-center text-gray-500 text-sm">
      © 2025 Shelvean Kapita: kapita@tamu.edu <br>
      All code released under the MIT License. <br>
      Last modified: December 18, 2025
    </div>
  </div>

  <script>
    // Render KaTeX for initial page elements
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          { left: "\\[", right: "\\]", display: true },
          { left: "\\(", right: "\\)", display: false }
        ]
      });
    });

    let currentDisplayMode = "fraction";
    document.querySelectorAll('input[name="displayMode"]').forEach(function(radio) {
      radio.addEventListener("change", function () {
        currentDisplayMode = this.value;
      });
    });

    // Generate input fields for matrix A (m x n) and vector b (m x 1)
    function generateMatrix() {
      const m = parseInt(document.getElementById("m").value, 10);
      const n = parseInt(document.getElementById("n").value, 10);
      if (isNaN(m) || m <= 0 || isNaN(n) || n <= 0) {
        alert("Please enter valid positive integers for m and n.");
        return;
      }
      const matrixDiv = document.getElementById("matrixInput");
      matrixDiv.innerHTML = "";

      const statementDiv = document.createElement("div");
      statementDiv.className = "text-center mb-4";
      const statement = document.createElement("div");
      statement.className = "latex";
      statement.textContent = `\\[ \\text{Minimize } \\| A \\mathbf{x} - \\mathbf{b} \\|_2 \\text{ using QR decomposition} \\]`;
      statementDiv.appendChild(statement);
      const emptyStatement = document.createElement("div");
      emptyStatement.className = "latex";
      emptyStatement.textContent = `\\[ \\text{(empty spaces are treated as 0)} \\]`;
      statementDiv.appendChild(emptyStatement);
      matrixDiv.appendChild(statementDiv);

      const flexDiv = document.createElement("div");
      flexDiv.className = "flex justify-center space-x-8";

      // Matrix A
      const aDiv = document.createElement("div");
      aDiv.className = "flex flex-col items-center";
      const aLabel = document.createElement("p");
      aLabel.className = "text-center font-semibold latex";
      aLabel.textContent = "Matrix \\( A \\)";
      aDiv.appendChild(aLabel);
      const aTable = document.createElement("table");
      aTable.className = "border-collapse";
      for (let i = 0; i < m; i++) {
        const tr = document.createElement("tr");
        for (let j = 0; j < n; j++) {
          const td = document.createElement("td");
          td.className = "p-1";
          const input = document.createElement("input");
          input.type = "text";
          input.className = "matrix-cell";
          input.id = "A_" + i + "_" + j;
          td.appendChild(input);
          tr.appendChild(td);
        }
        aTable.appendChild(tr);
      }
      aDiv.appendChild(aTable);
      flexDiv.appendChild(aDiv);

      // Vector b
      const bDiv = document.createElement("div");
      bDiv.className = "flex flex-col items-center";
      const bLabel = document.createElement("p");
      bLabel.className = "text-center font-semibold latex";
      bLabel.textContent = "Vector \\( \\mathbf{b} \\)";
      bDiv.appendChild(bLabel);
      const bTable = document.createElement("table");
      bTable.className = "border-collapse";
      for (let i = 0; i < m; i++) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.className = "p-1";
        const input = document.createElement("input");
        input.type = "text";
        input.className = "matrix-cell";
        input.id = "b_" + i;
        td.appendChild(input);
        tr.appendChild(td);
        bTable.appendChild(tr);
      }
      bDiv.appendChild(bTable);
      flexDiv.appendChild(bDiv);

      matrixDiv.appendChild(flexDiv);
      renderMathInElement(matrixDiv, {
        delimiters: [
          { left: "\\[", right: "\\]", display: true },
          { left: "\\(", right: "\\)", display: false }
        ]
      });
    }

    // Clear all inputs and outputs
    function clearAll() {
      document.getElementById("m").value = "";
      document.getElementById("n").value = "";
      const matrixDiv = document.getElementById("matrixInput");
      if (matrixDiv) matrixDiv.innerHTML = "";
      const resultDiv = document.getElementById("result");
      if (resultDiv) resultDiv.innerHTML = "";
      document.querySelector('input[name="displayMode"][value="fraction"]').checked = true;
      currentDisplayMode = "fraction";
    }
    document.getElementById("clearBtn").addEventListener("click", clearAll);

    // Parse input as fraction or decimal
    function parseFraction(str) {
      str = str.trim();
      if (str === '') return 0;
      try {
        const evaluated = math.evaluate(str);
        if (typeof evaluated === 'number') return evaluated;
        else return 0;
      } catch (e) {
        alert("Please enter valid numbers, fractions, or mathematical expressions in all cells.");
        return null;
      }
    }

    // Read matrix A and vector b from input fields
    function readMatrix() {
      const m = parseInt(document.getElementById("m").value, 10);
      const n = parseInt(document.getElementById("n").value, 10);
      if (isNaN(m) || m <= 0 || isNaN(n) || n <= 0) {
        alert("Please enter valid positive integers for m and n.");
        return null;
      }
      const A = [];
      for (let i = 0; i < m; i++) {
        const row = [];
        for (let j = 0; j < n; j++) {
          const cell = document.getElementById("A_" + i + "_" + j);
          if (!cell) {
            alert("Error: Matrix input field A_" + i + "_" + j + " not found.");
            return null;
          }
          const value = cell.value.trim();
          const num = parseFraction(value);
          if (num === null) return null;
          row.push(num);
        }
        A.push(row);
      }
      const b = [];
      for (let i = 0; i < m; i++) {
        const cell = document.getElementById("b_" + i);
        if (!cell) {
          alert("Error: Vector input field b_" + i + " not found.");
          return null;
        }
        const value = cell.value.trim();
        const num = parseFraction(value);
        if (num === null) return null;
        b.push(num);
      }
      return { A: A, b: b, m: m, n: n };
    }

    // GCD and LCM helpers
    function gcd(a, b) {
      a = Math.abs(a); b = Math.abs(b);
      while (b) { const temp = b; b = a % b; a = temp; }
      return a;
    }
    function lcm(a, b) { return (a * b) / gcd(a, b); }
    function lcmArray(numbers) {
      if (numbers.length === 0) return 1;
      return numbers.reduce((a, b) => lcm(a, b), numbers[0]);
    }

    // Convert number to fraction for display
    function toFraction(x, tolerance = 1e-6, maxIterations = 50) {
      if (Math.abs(x) < 1e-12) return "0";
      const sign = x < 0 ? "-" : "";
      x = Math.abs(x);
      let h1 = 1, h2 = 0, k1 = 0, k2 = 1, b = x;
      for (let i = 0; i < maxIterations; i++) {
        const a = Math.floor(b);
        const h = a * h1 + h2;
        const k = a * k1 + k2;
        if (Math.abs(x - h / k) < tolerance) {
          if (k === 1) return sign + h;
          else return sign + h + "/" + k;
        }
        h2 = h1; h1 = h;
        k2 = k1; k1 = k;
        b = 1 / (b - a);
      }
      if (k1 === 1) return sign + h1;
      else return sign + h1 + "/" + k1;
    }

    // Parse fraction string
    function getFractionParts(str) {
      str = str.trim();
      let sign = 1;
      if (str.startsWith('-')) { sign = -1; str = str.slice(1); }
      if (str === "0" || str === "") return { sign: 1, num: 0, den: 1 };
      if (!str.includes('/')) return { sign, num: parseInt(str) || 0, den: 1 };
      const [numStr, denStr] = str.split('/');
      return { sign, num: parseInt(numStr) || 0, den: parseInt(denStr) || 1 };
    }

    // Format numbers based on display mode
    function formatNumber(num, forceDecimal = false) {
      const epsilon = 1e-10;
      if (Math.abs(num - Math.round(num)) < epsilon) return Math.round(num).toString();
      if (forceDecimal || currentDisplayMode === "decimal") {
        return parseFloat(num.toFixed(6)).toString();
      }
      return toFraction(num);
    }

    // Clone matrix
    function cloneMatrix(matrix) {
      return matrix.map(row => row.slice());
    }

    // Matrix to LaTeX
    function matrixToLatex(matrix, augmented = false, numColsBeforeLine = 0, forceDecimal = false) {
      if (matrix.length === 0 || matrix[0].length === 0) return "";
      const cols = matrix[0].length;
      if (augmented) {
        const colSpec = "c".repeat(numColsBeforeLine) + "|c".repeat(cols - numColsBeforeLine);
        const content = matrix.map(row => row.map(num => formatNumber(num, forceDecimal)).join(" & ")).join(" \\\\ ");
        return "\\left[\\begin{array}{" + colSpec + "}" + content + "\\end{array}\\right]";
      } else {
        const content = matrix.map(row => row.map(num => formatNumber(num, forceDecimal)).join(" & ")).join(" \\\\ ");
        return "\\begin{bmatrix}" + content + "\\end{bmatrix}";
      }
    }

    // Compute RREF with steps
    function computeRREF(matrix, forceDecimal = false) {
      const m = matrix.length;
      if (m === 0) return { matrix: matrix, steps: [] };
      const n = matrix[0].length;
      const steps = [];
      let currentMatrix = cloneMatrix(matrix);
      steps.push({ matrix: cloneMatrix(currentMatrix), description: "\\text{Initial augmented matrix}" });
      let lead = 0;
      for (let r = 0; r < m; r++) {
        if (lead >= n) break;
        let i = r;
        while (Math.abs(currentMatrix[i][lead]) < 1e-10) {
          i++;
          if (i === m) { i = r; lead++; if (lead === n) break; }
        }
        if (lead === n) break;
        if (i !== r) {
          const temp = currentMatrix[r];
          currentMatrix[r] = currentMatrix[i];
          currentMatrix[i] = temp;
          steps.push({ matrix: cloneMatrix(currentMatrix), description: "R_{" + (r+1) + "} \\leftrightarrow R_{" + (i+1) + "}" });
        }
        const pivotValue = currentMatrix[r][lead];
        if (Math.abs(pivotValue) > 1e-10) {
          const reciprocal = 1 / pivotValue;
          const scale_op = reciprocal >= 0 ? "" : "-";
          const abs_reciprocal = Math.abs(reciprocal);
          const scale_desc = scale_op + formatNumber(abs_reciprocal, forceDecimal) + " R_{" + (r+1) + "} \\to R_{" + (r+1) + "}";
          for (let j = 0; j < n; j++) currentMatrix[r][j] *= reciprocal;
          steps.push({ matrix: cloneMatrix(currentMatrix), description: scale_desc });
        }
        for (let i = 0; i < m; i++) {
          if (i !== r) {
            const factor = currentMatrix[i][lead];
            if (Math.abs(factor) > 1e-10) {
              const op = factor >= 0 ? "-" : "+";
              const abs_factor = Math.abs(factor);
              const elim_desc = "R_{" + (i+1) + "} " + op + " " + formatNumber(abs_factor, forceDecimal) + " R_{" + (r+1) + "} \\to R_{" + (i+1) + "}";
              for (let j = 0; j < n; j++) currentMatrix[i][j] -= factor * currentMatrix[r][j];
              steps.push({ matrix: cloneMatrix(currentMatrix), description: elim_desc });
            }
          }
        }
        lead++;
      }
      return { matrix: currentMatrix, steps: steps };
    }

    // Solve linear system (used for min-norm when needed)
    function solveLinearSystem(A, b) {
      const n = A.length;
      const augmented = A.map((row, i) => row.concat(b[i]));
      const rrefResult = computeRREF(augmented, false);
      const rref = rrefResult.matrix;
      const x = new Array(n).fill(0);
      const pivotColumns = [];
      const pivotRowMap = {};
      let currentCol = 0;
      for (let row = 0; row < n; row++) {
        while (currentCol < n && Math.abs(rref[row][currentCol]) < 1e-10) currentCol++;
        if (currentCol < n && Math.abs(rref[row][currentCol] - 1) < 1e-10) {
          pivotColumns.push(currentCol);
          pivotRowMap[currentCol] = row;
          x[currentCol] = rref[row][n];
          currentCol++;
        }
      }
      return x;
    }

    // Extract solution from RREF
    function extractSolution(rref, n, forceDecimal = false) {
      const m = rref.length;
      let hasNoSolution = false;
      for (let i = 0; i < m; i++) {
        let isZeroRow = true;
        for (let j = 0; j < n; j++) {
          if (Math.abs(rref[i][j]) > 1e-10) { isZeroRow = false; break; }
        }
        if (isZeroRow && Math.abs(rref[i][n]) > 1e-10) { hasNoSolution = true; break; }
      }
      if (hasNoSolution) return { type: "no_solution" };

      const pivotColumns = [];
      const pivotRowMap = {};
      let currentCol = 0;
      for (let row = 0; row < m; row++) {
        while (currentCol < n && Math.abs(rref[row][currentCol]) < 1e-10) currentCol++;
        if (currentCol < n && Math.abs(rref[row][currentCol] - 1) < 1e-10) {
          pivotColumns.push(currentCol);
          pivotRowMap[currentCol] = row;
          currentCol++;
        }
      }
      const r = pivotColumns.length;
      const x_p = new Array(n).fill(0);
      let generalLatex = "";
      const nullSpaceBasis = [];
      const minNormSteps = [];

      if (r < n) {
        const freeVars = [];
        for (let j = 0; j < n; j++) if (!pivotColumns.includes(j)) freeVars.push(j);
        freeVars.sort((a, b) => a - b);

        // Particular solution
        for (let j = 0; j < n; j++) {
          if (pivotColumns.includes(j)) x_p[j] = rref[pivotRowMap[j]][n];
        }
        minNormSteps.push({
          description: "\\text{Particular solution (free variables set to 0):}",
          latex: "\\mathbf{x}_p = \\begin{bmatrix} " + x_p.map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}"
        });

        // Null space basis
        for (let k = 0; k < freeVars.length; k++) {
          const v = new Array(n).fill(0);
          const freeVarIndex = freeVars[k];
          v[freeVarIndex] = 1;
          for (let j = 0; j < pivotColumns.length; j++) {
            const pivotCol = pivotColumns[j];
            const row = pivotRowMap[pivotCol];
            v[pivotCol] = -rref[row][freeVarIndex];
          }
          nullSpaceBasis.push(v);
        }
        const greekLetters = ["\\alpha", "\\beta", "\\gamma", "\\delta", "\\epsilon", "\\zeta", "\\eta", "\\theta"];
        let nullSpaceLatex = "\\text{Basis vectors for the null space (as columns of N):}";
        nullSpaceBasis.forEach((v, k) => {
          nullSpaceLatex += " \\\\ \\mathbf{v}_{" + (k+1) + "} = \\begin{bmatrix} " + v.map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}";
        });
        minNormSteps.push({ description: nullSpaceLatex });

        // Minimum-norm solution
        const k_free = freeVars.length;
        const NTN = [];
        for (let i = 0; i < k_free; i++) {
          const row = [];
          for (let j = 0; j < k_free; j++) {
            let sum = 0;
            for (let l = 0; l < n; l++) sum += nullSpaceBasis[i][l] * nullSpaceBasis[j][l];
            row.push(sum);
          }
          NTN.push(row);
        }
        const NT_xp = [];
        for (let i = 0; i < k_free; i++) {
          let sum = 0;
          for (let l = 0; l < n; l++) sum += nullSpaceBasis[i][l] * x_p[l];
          NT_xp.push(-sum);
        }
        const alpha = solveLinearSystem(NTN, NT_xp);
        const x = x_p.map((val, i) => val);
        for (let i = 0; i < n; i++) {
          for (let kk = 0; kk < k_free; kk++) x[i] += nullSpaceBasis[kk][i] * alpha[kk];
        }

        const NTN_latex = matrixToLatex(NTN, false, 0, forceDecimal);
        minNormSteps.push({ description: "\\text{Compute } N^T N:", latex: "N^T N = " + NTN_latex });
        const NT_xp_latex = "\\begin{bmatrix} " + NT_xp.map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}";
        minNormSteps.push({ description: "\\text{Compute } -N^T \\mathbf{x}_p:", latex: "-N^T \\mathbf{x}_p = " + NT_xp_latex });
        const alpha_latex = "\\begin{bmatrix} " + alpha.map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}";
        minNormSteps.push({ description: "\\text{Solve } N^T N \\boldsymbol{\\alpha} = -N^T \\mathbf{x}_p:", latex: "\\boldsymbol{\\alpha} = " + alpha_latex });

        const terms = alpha.map((a, kk) => {
          const sign = a >= 0 ? "+" : "-";
          return sign + " " + formatNumber(Math.abs(a), forceDecimal) + " \\begin{bmatrix} " + nullSpaceBasis[kk].map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}";
        }).join(" ");
        minNormSteps.push({
          description: "\\text{Minimum-norm solution } \\mathbf{x}^* = \\mathbf{x}_p + N \\boldsymbol{\\alpha}:",
          latex: "\\mathbf{x}^* = \\begin{bmatrix} " + x_p.map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix} " + terms + " = \\begin{bmatrix} " + x.map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}"
        });

        // General solution
        generalLatex = "\\begin{align*} \\text{General solution:} & \\ \\mathbf{x} = ";
        const isZeroVector = x.every(val => Math.abs(val) < 1e-10);
        if (!isZeroVector) {
          generalLatex += "\\begin{bmatrix} " + x.map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}";
        }
        freeVars.forEach((freeVar, kk) => {
          if (!isZeroVector || kk > 0) generalLatex += " + ";
          const param = (kk < greekLetters.length ? greekLetters[kk] : "t_{" + (kk - greekLetters.length + 1) + "}");
          generalLatex += param + " \\begin{bmatrix} " + nullSpaceBasis[kk].map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}";
        });
        generalLatex += " \\end{align*} \\text{where } ";
        const params = freeVars.map((_, kk) => kk < greekLetters.length ? greekLetters[kk] : "t_{" + (kk - greekLetters.length + 1) + "}");
        if (params.length === 1) generalLatex += params[0] + " \\in \\mathbb{R}.";
        else if (params.length >= 2) generalLatex += params.slice(0, -1).join(", ") + ", " + params[params.length - 1] + " \\in \\mathbb{R}.";

        return { type: "infinite_solutions", solution: x, generalLatex: generalLatex, minNormSteps: minNormSteps };
      } else {
        const x = new Array(n).fill(0);
        for (let j = 0; j < n; j++) {
          if (pivotRowMap[j] !== undefined) x[j] = rref[pivotRowMap[j]][n];
        }
        return { type: "unique", solution: x, generalLatex: "", minNormSteps: [] };
      }
    }

    // Transpose and Householder helpers
    function transpose(matrix) {
      return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
    }
    function dot(a, b) {
      let s = 0;
      for (let i = 0; i < a.length; i++) s += a[i] * b[i];
      return s;
    }
    function norm2(a) { return Math.sqrt(dot(a, a)); }
    function identityMatrix(size) {
      const I = Array(size).fill(null).map(() => Array(size).fill(0));
      for (let i = 0; i < size; i++) I[i][i] = 1;
      return I;
    }

    // Householder QR (economy size)
    function computeQR(A) {
      const m = A.length;
      const n = A[0].length;
      let R = A.map(row => row.slice());
      let Q = identityMatrix(m);
      for (let k = 0; k < Math.min(m, n); k++) {
        let x = [];
        for (let i = k; i < m; i++) x.push(R[i][k]);
        let normx = norm2(x);
        if (normx < 1e-14) continue;
        let v = x.slice();
        v[0] += (x[0] >= 0 ? normx : -normx);
        let vnorm = norm2(v);
        if (vnorm < 1e-14) continue;
        for (let i = 0; i < v.length; i++) v[i] /= vnorm;

        // Apply to R
        for (let j = k; j < n; j++) {
          let dotprod = 0;
          for (let i = 0; i < v.length; i++) dotprod += v[i] * R[k + i][j];
          for (let i = 0; i < v.length; i++) {
            R[k + i][j] -= 2 * v[i] * dotprod;
            if (Math.abs(R[k + i][j]) < 1e-14) R[k + i][j] = 0;
          }
        }
        // Apply to Q
        for (let i = 0; i < m; i++) {
          let dotprod = 0;
          for (let j = 0; j < v.length; j++) dotprod += Q[i][k + j] * v[j];
          for (let j = 0; j < v.length; j++) {
            Q[i][k + j] -= 2 * v[j] * dotprod;
            if (Math.abs(Q[i][k + j]) < 1e-14) Q[i][k + j] = 0;
          }
        }
      }
      // Sign convention
      for (let i = 0; i < Math.min(m, n); i++) {
        if (R[i][i] < 0) {
          for (let j = 0; j < n; j++) R[i][j] = -R[i][j];
          for (let j = 0; j < m; j++) Q[j][i] = -Q[j][i];
        }
      }
      let rank = 0;
      for (let i = 0; i < Math.min(m, n); i++) if (Math.abs(R[i][i]) > 1e-14) rank++;
      let thinQ = Q.map(row => row.slice(0, rank));
      let thinR = R.slice(0, rank);
      return { thinQ: thinQ, thinR: thinR, rank: rank };
    }

    // Matrix multiplication
    function matrixMultiply(A, B) {
      const m = A.length;
      const n = B[0].length;
      const p = B.length;
      const C = [];
      for (let i = 0; i < m; i++) {
        const row = [];
        for (let j = 0; j < n; j++) {
          let sum = 0;
          for (let k = 0; k < p; k++) sum += A[i][k] * B[k][j];
          row.push(sum);
        }
        C.push(row);
      }
      return C;
    }

    // Solve button
    document.getElementById("calcBtn").addEventListener("click", function () {
      const input = readMatrix();
      if (input === null) return;
      const A = input.A;
      const b = input.b;
      const m = input.m;
      const n = input.n;

      const resultDiv = document.getElementById("result");
      resultDiv.innerHTML = "";

      // QR decomposition
      const { thinQ, thinR } = computeQR(A);
      const QT = transpose(thinQ);
      const b_col = b.map(v => [v]);
      const c_col = matrixMultiply(QT, b_col);
      const c = c_col.map(row => row[0]);

      // Back substitution
      const augmented = thinR.map((row, i) => [...row, c[i]]);
      const rrefResult = computeRREF(augmented, true);
      const steps = rrefResult.steps;
      steps[0].description = "\\text{Initial augmented matrix } [R | c]";

      const solution = extractSolution(rrefResult.matrix, n, true);

      // === Display Least Squares Solution first ===
      if (solution.type === "no_solution") {
        resultDiv.innerHTML += '<p class="font-semibold text-center text-red-600">The overdetermined system is inconsistent — no least squares solution exists.</p>';
      } else {
        const x = solution.solution;
        const components = x.map(val => formatNumber(val, false));
        let latex;
        if (currentDisplayMode === "fraction") {
          const fracs = components.map(str => getFractionParts(str));
          const dens = fracs.map(f => f.den).filter(d => d > 0);
          const commonDen = lcmArray(dens);
          if (commonDen > 1 && commonDen < 500) {
            const nums = fracs.map(f => {
              const scale = commonDen / f.den;
              return f.sign * f.num * scale;
            });
            const vectorLatex = "\\begin{bmatrix} " + nums.join(" \\\\ ") + " \\end{bmatrix}";
            latex = "\\mathbf{x} = \\dfrac{1}{" + commonDen + "} " + vectorLatex;
          } else {
            latex = "\\mathbf{x} = \\begin{bmatrix} " + components.join(" \\\\ ") + " \\end{bmatrix}";
          }
        } else {
          latex = "\\mathbf{x} = \\begin{bmatrix} " + x.map(val => formatNumber(val, true)).join(" \\\\ ") + " \\end{bmatrix}";
        }
        resultDiv.innerHTML += '<p class="font-semibold text-center text-xl text-blue-700 mb-6">Least Squares Solution (minimum-norm when underdetermined):</p>';
        resultDiv.innerHTML += '<div class="latex text-center text-2xl mb-8">\\[ ' + latex + ' \\]</div>';

        if (solution.type === "infinite_solutions") {
          resultDiv.innerHTML += '<p class="font-semibold text-center mb-4">General Solution:</p>';
          resultDiv.innerHTML += '<div class="latex text-center mb-8">\\[ ' + solution.generalLatex + ' \\]</div>';
        }
      }

      // === Input matrices (A in LaTeX, b as plain text) ===
      resultDiv.innerHTML += '<p class="font-semibold text-center">Input Matrix A:</p><div class="latex text-center">\\[ ' + matrixToLatex(A, false, 0, true) + ' \\]</div>';
      resultDiv.innerHTML += '<p class="font-semibold text-center">Input Vector b:</p>';
      resultDiv.innerHTML += '<div class="text-center font-mono text-lg">[' + b.map(val => formatNumber(val, true)).join(', ') + ']<sup>T</sup></div>';

      // === QR decomposition details ===
      const thinQ_latex = matrixToLatex(thinQ, false, 0, true);
      const thinR_latex = matrixToLatex(thinR, false, 0, true);
      const c_latex = '\\begin{bmatrix} ' + c.map(val => formatNumber(val, true)).join(' \\\\ ') + ' \\end{bmatrix}';
      resultDiv.innerHTML += '<p class="font-semibold text-center mt-8">QR Decomposition (economy size):</p>';
      resultDiv.innerHTML += '<div class="latex text-center">\\[ Q = ' + thinQ_latex + ' \\]</div>';
      resultDiv.innerHTML += '<div class="latex text-center">\\[ R = ' + thinR_latex + ' \\]</div>';
      resultDiv.innerHTML += '<p class="font-semibold text-center mt-6">\\( c = Q^T \\mathbf{b} \\):</p>';
      resultDiv.innerHTML += '<div class="latex text-center">\\[ c = ' + c_latex + ' \\]</div>';
      resultDiv.innerHTML += '<p class="font-semibold text-center mt-6">Solve \\( R \\mathbf{x} = c \\):</p>';

      // === Back substitution steps ===
      if (steps.length > 0) {
        resultDiv.innerHTML += '<h3 class="text-lg font-semibold text-gray-800 mt-8 mb-4 text-center">Back Substitution Steps (Gaussian Elimination on [R | c]):</h3>';
        for (let idx = 0; idx < steps.length; idx++) {
          const step = steps[idx];
          const stepDiv = document.createElement("div");
          stepDiv.className = "mb-6 border-b pb-4";
          const descDiv = document.createElement("div");
          descDiv.className = "latex mb-2 text-center";
          descDiv.textContent = idx === 0 ? "\\[ " + step.description + " \\]" : "\\[ \\text{Step " + idx + ": } " + step.description + " \\]";
          stepDiv.appendChild(descDiv);
          const matDiv = document.createElement("div");
          matDiv.className = "latex text-center";
          matDiv.textContent = "\\[ " + matrixToLatex(step.matrix, true, n, true) + " \\]";
          stepDiv.appendChild(matDiv);
          resultDiv.appendChild(stepDiv);
        }
      }

      // === Minimum-norm details (only for underdetermined) ===
      if (solution.type === "infinite_solutions" && solution.minNormSteps.length > 0) {
        resultDiv.innerHTML += '<h3 class="text-lg font-semibold text-gray-800 mt-8 mb-4 text-center">Minimum-norm Solution Details:</h3>';
        solution.minNormSteps.forEach((step, idx) => {
          const stepDiv = document.createElement("div");
          stepDiv.className = "mb-6 border-b pb-4";
          const descDiv = document.createElement("div");
          descDiv.className = "latex mb-2 text-center";
          descDiv.textContent = "\\[ \\text{Step " + (idx + 1) + ": } " + step.description + " \\]";
          stepDiv.appendChild(descDiv);
          if (step.latex) {
            const mathDiv = document.createElement("div");
            mathDiv.className = "latex text-center";
            mathDiv.textContent = "\\[ " + step.latex + " \\]";
            stepDiv.appendChild(mathDiv);
          }
          resultDiv.appendChild(stepDiv);
        });
      }

      renderMathInElement(resultDiv, {
        delimiters: [
          { left: "\\[", right: "\\]", display: true },
          { left: "\\(", right: "\\)", display: false }
        ]
      });
    });
  </script>
</body>
</html>
