<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="description" content="A web-based tool to compute the Least Squares Solution of a matrix system Ax ≈ b using Normal Equations or QR Decomposition. Input the matrix dimensions, values for matrix A and vector b (empty spaces treated as 0), and calculate the solution with options for decimal or fraction output (short decimals or repeating decimals with numerator/denominator < 500). Solve and Clear All buttons appear after input fields." />
    <meta name="keywords" content="Least Squares, Normal Equations, QR Decomposition, Matrix Solver, System of Equations, Gauss-Jordan, Ax=b, Compute Least Squares Solution online" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5B8PRB2WZT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-5B8PRB2WZT');
    </script>
    <title>Least Squares Solver</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" />
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@14.6.0/lib/browser/math.js"></script>
    <style>
        .katex-display { margin: 1em 0; overflow-x: auto; }
        body { padding-left: 12.5vw; padding-right: 12.5vw; }
        @media (max-width: 900px) { body { padding-left: 3vw; padding-right: 3vw; } }
        .matrix-cell { width: 4rem; padding: 0.5rem; text-align: center; border: 2px solid #d1d5db; border-radius: 0.375rem; }
        .matrix-cell:hover { border-color: #3b82f6; border-width: 3px; }
        .matrix-cell:focus { outline: none; border-color: #3b82f6; }
        #result, #result * { color: #080808; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center">
    <div class="nav-container w-full fixed top-0 z-10 bg-white shadow-md">
        <nav class="max-w-4xl mx-auto py-4">
            <ul class="flex justify-center gap-8">
                <li><a href="index.html" class="text-indigo-500 hover:text-blue-600 transition-colors font-bold text-xl">Home</a></li>
                <li><a href="teaching.html" class="text-indigo-500 hover:text-blue-600 transition-colors font-bold text-xl">Teaching</a></li>
                <li><a href="projects.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Diff Eq</a></li>
                <li><a href="linear.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Linear Algebra</a></li>
                <li><a href="numerical.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Numerical Methods</a></li>
            </ul>
        </nav>
    </div>
    <div class="bg-white p-6 rounded-lg shadow-md max-w-4xl w-full mt-16">
        <h2 class="text-2xl font-bold mb-4 text-center text-gray-800">Least Squares Solver using Normal Equations or QR Decomposition</h2>
        <p class="text-center text-gray-600 mb-6">
            Enter the number of equations <span class="latex">\( m \)</span> and variables <span class="latex">\( n \)</span>, generate the input fields, fill in the matrix \( A \) and vector \( \mathbf{b} \), and then compute the least squares solution for \( A \mathbf{x} \approx \mathbf{b} \).
        </p>
        <div class="bg-gray-50 p-4 rounded-lg mb-6 flex justify-center items-center space-x-4">
            <span class="text-gray-700">Number of equations <span class="latex">\( m \)</span>:</span>
            <input type="number" id="m" min="1" required class="w-16 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
            <span class="text-gray-700">Number of variables <span class="latex">\( n \)</span>:</span>
            <input type="number" id="n" min="1" required class="w-16 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button type="button" onclick="generateMatrix()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 transition duration-300">Generate Matrix</button>
        </div>
        <div class="flex justify-center mb-6 space-x-6">
            <span class="text-gray-700">Method:</span>
            <label class="flex items-center">
                <input type="radio" name="method" value="normal" checked class="mr-2">
                <span>Normal Equations</span>
            </label>
            <label class="flex items-center">
                <input type="radio" name="method" value="qr" class="mr-2">
                <span>QR Decomposition</span>
            </label>
        </div>
        <div class="flex justify-center mb-6 space-x-6">
            <span class="text-gray-700">Final Output as:</span>
            <label class="flex items-center">
                <input type="radio" name="displayMode" value="decimal" class="mr-2">
                <span>Decimal</span>
            </label>
            <label class="flex items-center">
                <input type="radio" name="displayMode" value="fraction" checked class="mr-2">
                <span>Fraction</span>
            </label>
        </div>
        <div id="matrixInput" class="mb-6 overflow-x-auto"></div>
        <div class="flex justify-center space-x-4 mb-6">
            <button id="calcBtn" type="button" class="bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-600 transition duration-300 w-1/3">Solve</button>
            <button id="clearBtn" type="button" class="bg-gray-500 text-white px-6 py-2 rounded hover:bg-gray-600 transition duration-300 w-1/3">Clear All</button>
        </div>
        <div id="result" class="mt-6 p-4 bg-gray-50 rounded-lg"></div>
        <div class="mt-6 border-t pt-4 text-center text-gray-500 text-sm">
            © 2025 Shelvean Kapita: kapita@tamu.edu <br>
            All code released under the MIT License. <br>
            Last modified: August 5, 2025
        </div>
    </div>
    <script>
        // Render KaTeX for initial page elements
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "\\[", right: "\\]", display: true },
                    { left: "\\(", right: "\\)", display: false }
                ]
            });
        });

        let currentDisplayMode = "fraction";
        document.querySelectorAll('input[name="displayMode"]').forEach(function(radio) {
            radio.addEventListener("change", function () {
                currentDisplayMode = this.value;
            });
        });

        // Generate input fields for matrix A (m x n) and vector b (m x 1)
        function generateMatrix() {
            const m = parseInt(document.getElementById("m").value, 10);
            const n = parseInt(document.getElementById("n").value, 10);
            if (isNaN(m) || m <= 0 || isNaN(n) || n <= 0) {
                alert("Please enter valid positive integers for m and n.");
                return;
            }
            const matrixDiv = document.getElementById("matrixInput");
            if (!matrixDiv) {
                console.error("Error: Element with ID 'matrixInput' not found.");
                return;
            }
            matrixDiv.innerHTML = "";
            
            const statementDiv = document.createElement("div");
            statementDiv.className = "text-center mb-4";
            
            const statement = document.createElement("div");
            statement.className = "latex";
            statement.textContent = `\\[ \\text{Minimize } \\| A \\mathbf{x} - \\mathbf{b} \\|_2 \\text{ by solving } A^T A \\mathbf{x} = A^T \\mathbf{b} \\text{ or using QR} \\]`;
            statementDiv.appendChild(statement);
            
            const emptyStatement = document.createElement("div");
            emptyStatement.className = "latex";
            emptyStatement.textContent = `\\[ \\text{(empty spaces are treated as 0)} \\]`;
            statementDiv.appendChild(emptyStatement);
            matrixDiv.appendChild(statementDiv);
            
            const flexDiv = document.createElement("div");
            flexDiv.className = "flex justify-center space-x-8";
            
            // Matrix A
            const aDiv = document.createElement("div");
            aDiv.className = "flex flex-col items-center";
            const aLabel = document.createElement("p");
            aLabel.className = "text-center font-semibold latex";
            aLabel.textContent = "Matrix \\( A \\)";
            aDiv.appendChild(aLabel);
            
            const aTable = document.createElement("table");
            aTable.className = "border-collapse";
            for (let i = 0; i < m; i++) {
                const tr = document.createElement("tr");
                for (let j = 0; j < n; j++) {
                    const td = document.createElement("td");
                    td.className = "p-1";
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "matrix-cell";
                    input.id = "A_" + i + "_" + j;
                    td.appendChild(input);
                    tr.appendChild(td);
                }
                aTable.appendChild(tr);
            }
            aDiv.appendChild(aTable);
            flexDiv.appendChild(aDiv);
            
            // Vector b
            const bDiv = document.createElement("div");
            bDiv.className = "flex flex-col items-center";
            const bLabel = document.createElement("p");
            bLabel.className = "text-center font-semibold latex";
            bLabel.textContent = "Vector \\( \\mathbf{b} \\)";
            bDiv.appendChild(bLabel);
            
            const bTable = document.createElement("table");
            bTable.className = "border-collapse";
            for (let i = 0; i < m; i++) {
                const tr = document.createElement("tr");
                const td = document.createElement("td");
                td.className = "p-1";
                const input = document.createElement("input");
                input.type = "text";
                input.className = "matrix-cell";
                input.id = "b_" + i;
                td.appendChild(input);
                tr.appendChild(td);
                bTable.appendChild(tr);
            }
            bDiv.appendChild(bTable);
            flexDiv.appendChild(bDiv);
            
            matrixDiv.appendChild(flexDiv);
            renderMathInElement(matrixDiv, {
                delimiters: [
                    { left: "\\[", right: "\\]", display: true },
                    { left: "\\(", right: "\\)", display: false }
                ]
            });
        }

        // Clear all inputs and outputs
        function clearAll() {
            document.getElementById("m").value = "";
            document.getElementById("n").value = "";
            const matrixDiv = document.getElementById("matrixInput");
            if (matrixDiv) {
                matrixDiv.innerHTML = "";
            } else {
                console.error("Error: Element with ID 'matrixInput' not found in clearAll.");
            }
            const resultDiv = document.getElementById("result");
            if (resultDiv) {
                resultDiv.innerHTML = "";
            } else {
                console.error("Error: Element with ID 'result' not found in clearAll.");
            }
            document.querySelector('input[name="displayMode"][value="fraction"]').checked = true;
            document.querySelector('input[name="method"][value="normal"]').checked = true;
            currentDisplayMode = "fraction";
        }
        document.getElementById("clearBtn").addEventListener("click", clearAll);

        // Parse input as fraction or decimal
        function parseFraction(str) {
            str = str.trim();
            if (str === '') return 0;
            try {
                const evaluated = math.evaluate(str);
                if (typeof evaluated === 'number') {
                    return evaluated;
                } else {
                    return 0;
                }
            } catch (e) {
                alert("Please enter valid numbers, fractions, or mathematical expressions in all cells.");
                return null;
            }
        }

        // Read matrix A and vector b from input fields
        function readMatrix() {
            const m = parseInt(document.getElementById("m").value, 10);
            const n = parseInt(document.getElementById("n").value, 10);
            if (isNaN(m) || m <= 0 || isNaN(n) || n <= 0) {
                alert("Please enter valid positive integers for m and n.");
                return null;
            }
            
            const A = [];
            for (let i = 0; i < m; i++) {
                const row = [];
                for (let j = 0; j < n; j++) {
                    const cell = document.getElementById("A_" + i + "_" + j);
                    if (!cell) {
                        alert("Error: Matrix input field A_" + i + "_" + j + " not found.");
                        return null;
                    }
                    const value = cell.value.trim();
                    const num = parseFraction(value);
                    if (num === null) {
                        return null;
                    }
                    row.push(num);
                }
                A.push(row);
            }
            
            const b = [];
            for (let i = 0; i < m; i++) {
                const cell = document.getElementById("b_" + i);
                if (!cell) {
                    alert("Error: Vector input field b_" + i + " not found.");
                    return null;
                }
                const value = cell.value.trim();
                const num = parseFraction(value);
                if (num === null) {
                    return null;
                }
                b.push(num);
            }
            
            return { A: A, b: b, m: m, n: n };
        }

        // Compute GCD and LCM
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b) {
                const temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }

        function lcm(a, b) {
            return (a * b) / gcd(a, b);
        }

        function lcmArray(numbers) {
            if (numbers.length === 0) return 1;
            return numbers.reduce((a, b) => lcm(a, b), numbers[0]);
        }

        // Convert number to fraction for display
        function toFraction(x, tolerance, maxIterations) {
            tolerance = tolerance || 1e-6;
            maxIterations = maxIterations || 50;
            if (Math.abs(x) < 1e-12) return "0";
            const sign = x < 0 ? "-" : "";
            x = Math.abs(x);
            let h1 = 1, h2 = 0, k1 = 0, k2 = 1, b = x;
            for (let i = 0; i < maxIterations; i++) {
                const a = Math.floor(b);
                const h = a * h1 + h2;
                const k = a * k1 + k2;
                if (Math.abs(x - h / k) < tolerance) {
                    if (k === 1) {
                        return sign + h;
                    } else {
                        return sign + h + "/" + k;
                    }
                }
                h2 = h1; h1 = h;
                k2 = k1; k1 = k;
                b = 1 / (b - a);
            }
            if (k1 === 1) {
                return sign + h1;
            } else {
                return sign + h1 + "/" + k1;
            }
        }

        // Parse fraction string to get numerator and denominator
        function getFractionParts(str) {
            str = str.trim();
            let sign = 1;
            if (str.startsWith('-')) {
                sign = -1;
                str = str.slice(1);
            }
            if (str === "0" || str === "") {
                return { sign: 1, num: 0, den: 1 };
            }
            if (!str.includes('/')) {
                return { sign, num: parseInt(str) || 0, den: 1 };
            }
            const [numStr, denStr] = str.split('/');
            return { sign, num: parseInt(numStr) || 0, den: parseInt(denStr) || 1 };
        }

        // Format numbers based on display mode and forceDecimal option
        function formatNumber(num, forceDecimal = false) {
            const epsilon = 1e-10;
            if (Math.abs(num - Math.round(num)) < epsilon) {
                return Math.round(num).toString();
            }
            if (forceDecimal || currentDisplayMode === "decimal") {
                // Round to 6 decimal places
                return parseFloat(num.toFixed(6)).toString();
            }
            return toFraction(num);
        }

        // Clone matrix to avoid modifying original
        function cloneMatrix(matrix) {
            return matrix.map(row => row.slice());
        }

        // Matrix to LaTeX - FIXED to include brackets
        function matrixToLatex(matrix, augmented = false, numColsBeforeLine = 0, forceDecimal = false) {
            if (matrix.length === 0 || matrix[0].length === 0) return "";
            const cols = matrix[0].length;
            
            if (augmented) {
                const colSpec = "c".repeat(numColsBeforeLine) + "|c".repeat(cols - numColsBeforeLine);
                const content = matrix
                    .map(row => row.map(num => formatNumber(num, forceDecimal)).join(" & "))
                    .join(" \\\\ ");
                return "\\left[\\begin{array}{" + colSpec + "}" + content + "\\end{array}\\right]";
            } else {
                const content = matrix
                    .map(row => row.map(num => formatNumber(num, forceDecimal)).join(" & "))
                    .join(" \\\\ ");
                return "\\begin{bmatrix}" + content + "\\end{bmatrix}";
            }
        }

        // Matrix multiplication
        function matrixMultiply(A, B) {
            const m = A.length;
            const n = B[0].length;
            const p = B.length;
            const C = [];
            for (let i = 0; i < m; i++) {
                const row = [];
                for (let j = 0; j < n; j++) {
                    let sum = 0;
                    for (let k = 0; k < p; k++) {
                        sum += A[i][k] * B[k][j];
                    }
                    row.push(sum);
                }
                C.push(row);
            }
            return C;
        }

        // Compute RREF with steps
        function computeRREF(matrix, forceDecimal = false) {
            const m = matrix.length;
            if (m === 0) return { matrix: matrix, steps: [] };
            const n = matrix[0].length;
            const steps = [];
            let currentMatrix = cloneMatrix(matrix);
            
            steps.push({ matrix: cloneMatrix(currentMatrix), description: "\\text{Initial augmented matrix}" });
            
            let lead = 0;
            for (let r = 0; r < m; r++) {
                if (lead >= n) break;
                let i = r;
                while (Math.abs(currentMatrix[i][lead]) < 1e-10) {
                    i++;
                    if (i === m) {
                        i = r;
                        lead++;
                        if (lead === n) break;
                    }
                }
                if (lead === n) break;
                
                if (i !== r) {
                    const temp = currentMatrix[r];
                    currentMatrix[r] = currentMatrix[i];
                    currentMatrix[i] = temp;
                    steps.push({ matrix: cloneMatrix(currentMatrix), description: "R_{" + (r+1) + "} \\leftrightarrow R_{" + (i+1) + "}" });
                }
                
                const pivotValue = currentMatrix[r][lead];
                if (Math.abs(pivotValue) > 1e-10) {
                    const reciprocal = 1 / pivotValue;
                    const scale_op = reciprocal >= 0 ? "" : "-";
                    const abs_reciprocal = Math.abs(reciprocal);
                    const scale_desc = scale_op + formatNumber(abs_reciprocal, forceDecimal) + " R_{" + (r+1) + "} \\to R_{" + (r+1) + "}";
                    
                    for (let j = 0; j < n; j++) {
                        currentMatrix[r][j] *= reciprocal;
                    }
                    steps.push({ matrix: cloneMatrix(currentMatrix), description: scale_desc });
                }
                
                for (let i = 0; i < m; i++) {
                    if (i !== r) {
                        const factor = currentMatrix[i][lead];
                        if (Math.abs(factor) > 1e-10) {
                            const op = factor >= 0 ? "-" : "+";
                            const abs_factor = Math.abs(factor);
                            const elim_desc = "R_{" + (i+1) + "} " + op + " " + formatNumber(abs_factor, forceDecimal) + " R_{" + (r+1) + "} \\to R_{" + (i+1) + "}";
                            
                            for (let j = 0; j < n; j++) {
                                currentMatrix[i][j] -= factor * currentMatrix[r][j];
                            }
                            steps.push({ matrix: cloneMatrix(currentMatrix), description: elim_desc });
                        }
                    }
                }
                lead++;
            }
            
            return { matrix: currentMatrix, steps: steps };
        }

        // Solve linear system Ax = b using Gaussian elimination
        function solveLinearSystem(A, b) {
            const n = A.length;
            const augmented = A.map((row, i) => row.concat(b[i]));
            const rrefResult = computeRREF(augmented, false);
            const rref = rrefResult.matrix;
            const x = new Array(n).fill(0);
            const pivotColumns = [];
            const pivotRowMap = {};
            let currentCol = 0;
            
            for (let row = 0; row < n; row++) {
                while (currentCol < n && Math.abs(rref[row][currentCol]) < 1e-10) {
                    currentCol++;
                }
                if (currentCol < n && Math.abs(rref[row][currentCol] - 1) < 1e-10) {
                    pivotColumns.push(currentCol);
                    pivotRowMap[currentCol] = row;
                    x[currentCol] = rref[row][n];
                    currentCol++;
                }
            }
            return x;
        }

        // Extract solution from RREF
        function extractSolution(rref, n, forceDecimal = false) {
            const m = rref.length;
            
            // Check for inconsistency
            let hasNoSolution = false;
            for (let i = 0; i < m; i++) {
                let isZeroRow = true;
                for (let j = 0; j < n; j++) {
                    if (Math.abs(rref[i][j]) > 1e-10) {
                        isZeroRow = false;
                        break;
                    }
                }
                if (isZeroRow && Math.abs(rref[i][n]) > 1e-10) {
                    hasNoSolution = true;
                    break;
                }
            }
            
            if (hasNoSolution) {
                return { type: "no_solution" };
            }
            
            // Find pivot columns
            const pivotColumns = [];
            const pivotRowMap = {};
            let currentCol = 0;
            for (let row = 0; row < m; row++) {
                while (currentCol < n && Math.abs(rref[row][currentCol]) < 1e-10) {
                    currentCol++;
                }
                if (currentCol < n && Math.abs(rref[row][currentCol] - 1) < 1e-10) {
                    pivotColumns.push(currentCol);
                    pivotRowMap[currentCol] = row;
                    currentCol++;
                }
            }
            
            const r = pivotColumns.length;
            const x_p = new Array(n).fill(0);
            let generalLatex = "";
            const nullSpaceBasis = [];
            const minNormSteps = [];
            
            if (r < n) {
                // Infinite solutions: compute particular and null space
                const freeVars = [];
                for (let j = 0; j < n; j++) {
                    if (!pivotColumns.includes(j)) {
                        freeVars.push(j);
                    }
                }
                freeVars.sort((a, b) => a - b);
                
                // Particular solution (set free variables to 0)
                for (let j = 0; j < n; j++) {
                    if (pivotColumns.includes(j)) {
                        const row = pivotRowMap[j];
                        x_p[j] = rref[row][n];
                    }
                }
                
                minNormSteps.push({
                    description: "\\text{Particular solution (free variables set to 0):}",
                    latex: "\\mathbf{x}_p = \\begin{bmatrix} " + x_p.map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}"
                });
                
                // Null space basis
                for (let k = 0; k < freeVars.length; k++) {
                    const v = new Array(n).fill(0);
                    const freeVarIndex = freeVars[k];
                    v[freeVarIndex] = 1;
                    for (let j = 0; j < pivotColumns.length; j++) {
                        const pivotCol = pivotColumns[j];
                        const row = pivotRowMap[pivotCol];
                        v[pivotCol] = -rref[row][freeVarIndex];
                    }
                    nullSpaceBasis.push(v);
                }
                
                const greekLetters = ["\\alpha", "\\beta", "\\gamma", "\\delta", "\\epsilon", "\\zeta", "\\eta", "\\theta"];
                let nullSpaceLatex = "\\text{Basis vectors for the null space (as columns of N):}";
                nullSpaceBasis.forEach((v, k) => {
                    nullSpaceLatex += " \\\\ \\mathbf{v}_{" + (k+1) + "} = \\begin{bmatrix} " + v.map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}";
                });
                minNormSteps.push({ description: nullSpaceLatex });
                
                // Compute minimum-norm solution
                const k_free = freeVars.length;
                const NTN = [];
                for (let i = 0; i < k_free; i++) {
                    const row = [];
                    for (let j = 0; j < k_free; j++) {
                        let sum = 0;
                        for (let l = 0; l < n; l++) {
                            sum += nullSpaceBasis[i][l] * nullSpaceBasis[j][l];
                        }
                        row.push(sum);
                    }
                    NTN.push(row);
                }
                
                const NT_xp = [];
                for (let i = 0; i < k_free; i++) {
                    let sum = 0;
                    for (let l = 0; l < n; l++) {
                        sum += nullSpaceBasis[i][l] * x_p[l];
                    }
                    NT_xp.push(-sum);
                }
                
                const alpha = solveLinearSystem(NTN, NT_xp);
                const x = x_p.map((val, i) => val);
                for (let i = 0; i < n; i++) {
                    for (let kk = 0; kk < k_free; kk++) {
                        x[i] += nullSpaceBasis[kk][i] * alpha[kk];
                    }
                }
                
                // Add latex for minNormSteps
                const NTN_latex = matrixToLatex(NTN, false, 0, forceDecimal);
                minNormSteps.push({ description: "\\text{Compute } N^T N:", latex: "N^T N = " + NTN_latex });
                
                const NT_xp_latex = "\\begin{bmatrix} " + NT_xp.map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}";
                minNormSteps.push({ description: "\\text{Compute } -N^T \\mathbf{x}_p:", latex: "-N^T \\mathbf{x}_p = " + NT_xp_latex });
                
                const alpha_latex = "\\begin{bmatrix} " + alpha.map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}";
                minNormSteps.push({ description: "\\text{Solve } N^T N \\boldsymbol{\\alpha} = -N^T \\mathbf{x}_p \\text{ to get } \\boldsymbol{\\alpha}:", latex: "\\boldsymbol{\\alpha} = " + alpha_latex });
                
                const terms = alpha.map((a, kk) => {
                    const sign = a >= 0 ? "+" : "-";
                    return sign + " " + formatNumber(Math.abs(a), forceDecimal) + " \\begin{bmatrix} " + nullSpaceBasis[kk].map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}";
                }).join(" ");
                
                minNormSteps.push({
                    description: "\\text{Minimum-norm solution } \\mathbf{x}^* = \\mathbf{x}_p + N \\boldsymbol{\\alpha}:",
                    latex: "\\mathbf{x}^* = \\begin{bmatrix} " + x_p.map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix} " + terms + " = \\begin{bmatrix} " + x.map(val => formatNumber(val, forceDecimal)).join(" \\\\ ") + " \\end{bmatrix}"
                });
                
                // General solution with final mode
                generalLatex = "\\begin{align*} \\text{General solution:} & \\ \\mathbf{x} = ";
                const isZeroVector = x.every(val => Math.abs(val) < 1e-10);
                if (!isZeroVector) {
                    generalLatex += "\\begin{bmatrix} ";
                    x.forEach((val, idx) => {
                        generalLatex += formatNumber(val, forceDecimal);
                        if (idx < n - 1) generalLatex += " \\\\ ";
                    });
                    generalLatex += " \\end{bmatrix}";
                }
                
                freeVars.forEach((freeVar, kk) => {
                    if (!isZeroVector || kk > 0) {
                        generalLatex += " + ";
                    }
                    generalLatex += (kk < greekLetters.length ? greekLetters[kk] : "t_{" + (kk - greekLetters.length + 1) + "}") + " \\begin{bmatrix} ";
                    nullSpaceBasis[kk].forEach((val, idx) => {
                        generalLatex += formatNumber(val, forceDecimal);
                        if (idx < n - 1) generalLatex += " \\\\ ";
                    });
                    generalLatex += " \\end{bmatrix}";
                });
                
                generalLatex += " \\end{align*} \\text{where } ";
                const params = freeVars.map((_, kk) => kk < greekLetters.length ? greekLetters[kk] : "t_{" + (kk - greekLetters.length + 1) + "}");
                if (params.length === 1) {
                    generalLatex += params[0] + " \\in \\mathbb{R}.";
                } else if (params.length >= 2) {
                    generalLatex += params.slice(0, -1).join(", ") + ", " + params[params.length - 1] + " \\in \\mathbb{R}.";
                }
                
                return { type: "infinite_solutions", solution: x, generalLatex: generalLatex, minNormSteps: minNormSteps };
            } else {
                // Unique solution
                const x = new Array(n).fill(0);
                for (let j = 0; j < n; j++) {
                    if (pivotRowMap[j] !== undefined) {
                        const row = pivotRowMap[j];
                        x[j] = rref[row][n];
                    }
                }
                return { type: "unique", solution: x, generalLatex: "", minNormSteps: [] };
            }
        }

        // Transpose matrix
        function transpose(matrix) {
            return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
        }

        // Householder QR functions
        function dot(a, b) {
            let s = 0;
            for (let i = 0; i < a.length; i++) s += a[i] * b[i];
            return s;
        }

        function norm2(a) {
            return Math.sqrt(dot(a, a));
        }

        function identityMatrix(size) {
            const I = Array(size).fill(null).map(() => Array(size).fill(0));
            for (let i = 0; i < size; i++) {
                I[i][i] = 1;
            }
            return I;
        }

        function computeQR(A) {
            const m = A.length;
            const n = A[0].length;
            let R = A.map((row) => row.slice());
            let Q = identityMatrix(m);
            
            for (let k = 0; k < Math.min(m, n); k++) {
                let x = [];
                for (let i = k; i < m; i++) x.push(R[i][k]);
                let normx = norm2(x);
                if (normx < 1e-14) continue;
                
                let v = x.slice();
                v[0] += (x[0] >= 0 ? normx : -normx);
                let vnorm = norm2(v);
                if (vnorm < 1e-14) continue;
                
                for (let i = 0; i < v.length; i++) v[i] /= vnorm;
                
                for (let j = k; j < n; j++) {
                    let dotprod = 0;
                    for (let i = 0; i < v.length; i++) dotprod += v[i] * R[k + i][j];
                    for (let i = 0; i < v.length; i++) {
                        R[k + i][j] -= 2 * v[i] * dotprod;
                        if (Math.abs(R[k + i][j]) < 1e-14) R[k + i][j] = 0;
                    }
                }
                
                for (let i = 0; i < m; i++) {
                    let dotprod = 0;
                    for (let j = 0; j < v.length; j++) dotprod += Q[i][k + j] * v[j];
                    for (let j = 0; j < v.length; j++) {
                        Q[i][k + j] -= 2 * v[j] * dotprod;
                        if (Math.abs(Q[i][k + j]) < 1e-14) Q[i][k + j] = 0;
                    }
                }
            }
            
            for (let i = 0; i < Math.min(m, n); i++) {
                if (R[i][i] < 0) {
                    for (let j = 0; j < n; j++) R[i][j] = -R[i][j];
                    for (let j = 0; j < m; j++) Q[j][i] = -Q[j][i];
                }
            }
            
            let rank = 0;
            for (let i = 0; i < Math.min(m, n); i++) if (Math.abs(R[i][i]) > 1e-14) rank++;
            
            let thinQ = Q.map((row) => row.slice(0, rank));
            let thinR = R.slice(0, rank);
            
            return { fullQ: Q, fullR: R, thinQ: thinQ, thinR: thinR, rank: rank };
        }

        // Event listener to solve the least squares problem
        document.getElementById("calcBtn").addEventListener("click", function () {
            const input = readMatrix();
            if (input === null) return;
            
            const A = input.A;
            const b = input.b;
            const m = input.m;
            const n = input.n;
            const method = document.querySelector('input[name="method"]:checked').value;
            const resultDiv = document.getElementById("result");
            resultDiv.innerHTML = "";
            
            // Determine if we should force decimals in steps
            const forceDecSteps = (method === "qr"); // QR always uses decimals in steps
            
            // Common input display - use current display mode for Normal, force decimal for QR
            const forceDecInput = (method === "qr");
            
            resultDiv.innerHTML += '<p class="font-semibold text-center">Input Matrix A:</p><div class="latex text-center">\\[ ' + matrixToLatex(A, false, 0, forceDecInput) + ' \\]</div>';
            
            const b_latex = '\\begin{bmatrix} ' + b.map(val => formatNumber(val, forceDecInput)).join(' \\\\ ') + ' \\end{bmatrix}';
            resultDiv.innerHTML += '<p class="font-semibold text-center">Input Vector \\mathbf{b}:</p><div class="latex text-center">\\[ ' + b_latex + ' \\]</div>';
            
            let steps = [];
            let solution;
            
            if (method === "normal") {
                // Compute A^T A
                const ATA = [];
                for (let i = 0; i < n; i++) {
                    const row = [];
                    for (let j = 0; j < n; j++) {
                        let sum = 0;
                        for (let k = 0; k < m; k++) {
                            sum += A[k][i] * A[k][j];
                        }
                        row.push(sum);
                    }
                    ATA.push(row);
                }
                
                // Compute A^T b
                const ATb = [];
                for (let i = 0; i < n; i++) {
                    let sum = 0;
                    for (let k = 0; k < m; k++) {
                        sum += A[k][i] * b[k];
                    }
                    ATb.push(sum);
                }
                
                // Display normal equations
                const xVector = "\\begin{bmatrix} " + Array.from({length: n}, (_, i) => "x_{" + (i+1) + "}").join(" \\\\ ") + " \\end{bmatrix}";
                const ATA_latex = matrixToLatex(ATA, false, 0, forceDecSteps);
                const ATb_latex = '\\begin{bmatrix} ' + ATb.map(val => formatNumber(val, forceDecSteps)).join(' \\\\ ') + ' \\end{bmatrix}';
                
                resultDiv.innerHTML += '<p class="font-semibold text-center">Normal Equations: \\( A^T A \\mathbf{x} = A^T \\mathbf{b} \\)</p><div class="latex text-center">\\[ ' + ATA_latex + ' ' + xVector + ' = ' + ATb_latex + ' \\]</div>';
                
                // Form augmented [ATA | ATb]
                const augmented = ATA.map((row, i) => row.concat(ATb[i]));
                const rrefResult = computeRREF(augmented, forceDecSteps);
                steps = rrefResult.steps;
                steps[0].description = "\\text{Initial augmented matrix } [A^T A | A^T \\mathbf{b}]";
                solution = extractSolution(rrefResult.matrix, n, forceDecSteps);
            } else { // qr
                const { thinQ, thinR } = computeQR(A);
                const QT = transpose(thinQ);
                const b_col = b.map(v => [v]);
                const c_col = matrixMultiply(QT, b_col);
                const c = c_col.map(row => row[0]);
                
                // Display QR decomposition with forced decimals
                const thinQ_latex = matrixToLatex(thinQ, false, 0, true);
                const thinR_latex = matrixToLatex(thinR, false, 0, true);
                const c_latex = '\\begin{bmatrix} ' + c.map(val => formatNumber(val, true)).join(' \\\\ ') + ' \\end{bmatrix}';
                
                resultDiv.innerHTML += '<p class="font-semibold text-center">QR Decomposition (economy):</p><div class="latex text-center">\\[ Q = ' + thinQ_latex + ' \\]</div><div class="latex text-center">\\[ R = ' + thinR_latex + ' \\]</div>';
                resultDiv.innerHTML += '<p class="font-semibold text-center">\\( c = Q^T \\mathbf{b} \\):</p><div class="latex text-center">\\[ c = ' + c_latex + ' \\]</div>';
                resultDiv.innerHTML += '<p class="font-semibold text-center">Solve \\( R \\mathbf{x} = c \\) (where \\( c = Q^T \\mathbf{b} \\)):</p>';
                
                const augmented = thinR.map((row, i) => [...row, c[i]]);
                const rrefResult = computeRREF(augmented, true); // Force decimals for QR steps
                steps = rrefResult.steps;
                steps[0].description = "\\text{Initial augmented matrix } [R | c]";
                solution = extractSolution(rrefResult.matrix, n, true); // Force decimals for QR
            }
            
            // Display solution
            if (solution.type === "no_solution") {
                resultDiv.innerHTML += '<p class="font-semibold text-center">The system has no solutions.</p>';
            } else {
                const x = solution.solution;
                const components = x.map(val => formatNumber(val, false)); // Use current display mode for final solution
                let latex;
                
                if (currentDisplayMode === "fraction") {
                    const fracs = components.map(str => getFractionParts(str));
                    const dens = fracs.map(f => f.den).filter(d => d > 0);
                    const commonDen = lcmArray(dens);
                    
                    if (commonDen > 1 && commonDen < 500) { // Only use common denominator if reasonable
                        const nums = fracs.map(f => {
                            const scale = commonDen / f.den;
                            return f.sign * f.num * scale;
                        });
                        const vectorLatex = "\\begin{bmatrix} " + nums.join(" \\\\ ") + " \\end{bmatrix}";
                        latex = "\\mathbf{x} = \\dfrac{1}{" + commonDen + "} " + vectorLatex;
                    } else {
                        latex = "\\mathbf{x} = \\begin{bmatrix} " + components.join(" \\\\ ") + " \\end{bmatrix}";
                    }
                } else {
                    latex = "\\mathbf{x} = \\begin{bmatrix} " + x.map(val => formatNumber(val, true)).join(" \\\\ ") + " \\end{bmatrix}";
                }
                
                resultDiv.innerHTML += '<p class="font-semibold text-center">Least Squares Solution:</p><div class="latex text-center">\\[ ' + latex + ' \\]</div>';
                
                if (solution.type === "infinite_solutions") {
                    resultDiv.innerHTML += '<p class="font-semibold text-center">General Solution:</p><div class="latex text-center">\\[ ' + solution.generalLatex + ' \\]</div>';
                }
            }
            
            // Display steps
            if (steps.length > 0) {
                resultDiv.innerHTML += '<h3 class="text-lg font-semibold text-gray-800 mt-6 mb-4 text-center">Solution Steps:</h3>';
                
                for (let idx = 0; idx < steps.length; idx++) {
                    const step = steps[idx];
                    const stepDiv = document.createElement("div");
                    stepDiv.className = "mb-6 border-b pb-4";
                    
                    const stepDescriptionDiv = document.createElement("div");
                    stepDescriptionDiv.className = "latex mb-2 text-center";
                    
                    if (idx === 0) {
                        stepDescriptionDiv.textContent = "\\[ " + step.description + " \\]";
                    } else {
                        stepDescriptionDiv.textContent = "\\[ \\text{Step " + idx + ": } " + step.description + " \\]";
                    }
                    
                    stepDiv.appendChild(stepDescriptionDiv);
                    
                    const matrixMath = document.createElement("div");
                    matrixMath.className = "latex text-center";
                    const numCols = method === "normal" ? n : n;
                    matrixMath.textContent = "\\[ " + matrixToLatex(step.matrix, true, numCols, forceDecSteps) + " \\]";
                    stepDiv.appendChild(matrixMath);
                    resultDiv.appendChild(stepDiv);
                }
            }
            
            // Min-norm if infinite
            if (solution.type === "infinite_solutions" && solution.minNormSteps.length > 0) {
                resultDiv.innerHTML += '<h3 class="text-lg font-semibold text-gray-800 mt-6 mb-4 text-center">Minimum-norm solution steps for underdetermined system:</h3>';
                
                solution.minNormSteps.forEach((step, idx) => {
                    const stepDiv = document.createElement("div");
                    stepDiv.className = "mb-6 border-b pb-4";
                    
                    const stepDescriptionDiv = document.createElement("div");
                    stepDescriptionDiv.className = "latex mb-2 text-center";
                    stepDescriptionDiv.textContent = "\\[ \\text{Step " + (idx + 1) + ": } " + step.description + " \\]";
                    stepDiv.appendChild(stepDescriptionDiv);
                    
                    if (step.latex) {
                        const stepMath = document.createElement("div");
                        stepMath.className = "latex text-center";
                        stepMath.textContent = "\\[ " + step.latex + " \\]";
                        stepDiv.appendChild(stepMath);
                    }
                    
                    resultDiv.appendChild(stepDiv);
                });
            }
            
            renderMathInElement(resultDiv, {
                delimiters: [
                    { left: "\\[", right: "\\]", display: true },
                    { left: "\\(", right: "\\)", display: false }
                ]
            });
        });
    </script>
</body>
</html>
