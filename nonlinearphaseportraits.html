<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Nonlinear Phase Diagram, Phase Portrait, System Trajectories, Direction Fields">
  <meta name="keywords" content="Nonlinear, Direction Fields, Phase Portraits, Phase Diagrams, Phase Plane Plotter, Phase Spaces, Phase Portrait Plotter, 2D Phase Plane, Systems of Differential Equations, Trajectories, Limit Cycles, Nonlinear Systems">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5B8PRB2WZT"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments) }
    gtag('js', new Date());
    gtag('config', 'G-5B8PRB2WZT');
  </script>
  <title>Nonlinear Phase Plane Plotter</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f7fb; overflow-x: hidden; }
    .page-container { max-width: 1600px; margin: 0 auto; padding-top: 80px; }
    .main-content { display: flex; gap: 30px; flex-wrap: wrap; align-items: flex-start; }
    .container { background: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 6px 25px rgba(0, 0, 0, 0.08); flex: 1; min-width: 720px; max-width: 780px; display: flex; flex-direction: column; }
    .examples-column { width: 380px; background: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 6px 25px rgba(0, 0, 0, 0.08); height: fit-content; margin-top: 0; align-self: flex-start; }
    .example { margin-bottom: 0.8rem; cursor: pointer; padding: 12px; border-radius: 8px; transition: all 0.2s; border: 1px solid #e5e7eb; background: #f8fafc; }
    .example:hover { background-color: #f0f9ff; border-color: #3b82f6; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2); }
    .example h3 { margin-bottom: 0.5rem; color: #1e293b; font-weight: 600; font-size: 1rem; }
    .system-equations { font-size: 0.85rem; margin: 0.3rem 0; min-height: 30px; }
    .domain { font-size: 0.75rem; color: #6b7280; margin-top: 0.2rem; }
    h1 { color: #1e293b; text-align: center; margin-bottom: 1rem; font-size: 2rem; }
    /* Compact controls section */
    .controls-section { background: #f8fafc; border-radius: 10px; padding: 1.2rem; margin-bottom: 1rem; border: 1px solid #e5e7eb; }
    /* Input grid - reduced width */
    .input-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 1rem 0; max-width: 700px; }
    .input-group { display: flex; flex-direction: column; gap: 6px; }
    .input-group label { font-size: 0.9rem; color: #1e293b; font-weight: 500; white-space: nowrap; }
    .input-group input { width: 100%; max-width: 320px; padding: 0.6rem; border: 2px solid #d1d5db; border-radius: 6px; font-size: 0.95rem; transition: all 0.2s; }
    .input-group input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
    /* Range inputs row */
    .range-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 1rem 0; max-width: 700px; }
    .range-input { display: flex; flex-direction: column; gap: 4px; }
    .range-input label { font-size: 0.8rem; color: #6b7280; font-weight: 500; }
    .range-input input { width: 100%; padding: 0.4rem; border: 2px solid #d1d5db; border-radius: 6px; font-size: 0.9rem; text-align: center; }
    /* Controls row */
    .controls-row { display: flex; flex-wrap: wrap; gap: 15px; justify-content: flex-start; align-items: center; margin-top: 1rem; max-width: 700px; }
    .checkbox-group { display: flex; align-items: center; gap: 8px; white-space: nowrap; }
    .checkbox-group input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
    .checkbox-group label { font-size: 0.9rem; color: #1e293b; font-weight: 500; cursor: pointer; }
    /* Color selector styles */
    .color-selector { display: flex; align-items: center; gap: 8px; white-space: nowrap; }
    .color-selector label { font-size: 0.9rem; color: #1e293b; font-weight: 500; margin-right: 5px; }
    .color-selector select { padding: 0.4rem 0.6rem; border: 2px solid #d1d5db; border-radius: 6px; font-size: 0.9rem; background: white; cursor: pointer; min-width: 120px; }
    .color-selector select:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
    button { background: #3b82f6; color: white; border: none; padding: 0.6rem 1.2rem; border-radius: 8px; cursor: pointer; font-size: 0.95rem; font-weight: 600; transition: all 0.3s ease; }
    button:hover { background: #2563eb; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3); }
    .button-container { display: flex; gap: 12px; justify-content: center; margin: 1.5rem 0 0.5rem 0; }
    button.clear { background: #ef4444; }
    button.clear:hover { background: #dc2626; box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3); }
    button.download-btn { background: #10b981; }
    button.download-btn:hover { background: #059669; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); }
    /* Canvas containers - graph size unchanged */
    #plot-container { position: relative; width: 700px; height: 700px; margin: 0 auto; }
    #field-canvas, #traj-canvas { position: absolute; top: 0; left: 0; border: 1px solid #e5e7eb; border-radius: 8px; background: #fafafa; }
    #traj-canvas { pointer-events: none; background: transparent !important; }
    .canvas-wrapper { display: flex; flex-direction: column; align-items: center; gap: 10px; }
    /* Equation container */
    .equation-container { width: 700px; background: white; padding: 12px 20px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); border: 2px solid #3b82f6; text-align: center; margin-bottom: 10px; min-height: 50px; }
    /* Footer */
    .canvas-footer { margin-top: 15px; padding-top: 10px; text-align: center; color: #6b7280; font-size: 0.85rem; width: 700px; }
    /* Examples grid - no scrolling on desktop */
    .examples-grid { display: grid; grid-template-columns: 1fr; gap: 12px; max-height: none; overflow-y: visible; }
    /* Instruction box */
    .instruction { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(5px); width: calc(100% - 4rem); max-width: 40rem; padding: 0.6rem 1.5rem; border-radius: 30px; font-size: 0.85rem; font-weight: 600; color: #1e40af; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); z-index: 10; animation: float 3s ease-in-out infinite; border: 1px solid rgba(59, 130, 246, 0.3); text-align: center; }
    @keyframes float { 0%, 100% { transform: translateX(-50%) translateY(0); } 50% { transform: translateX(-50%) translateY(-3px); } }
    /* Responsive adjustments */
    @media (max-width: 1400px) { .container { min-width: 650px; } .examples-column { width: 350px; } }
    @media (max-width: 1200px) { .page-container { padding-top: 70px; } .main-content { flex-direction: column; align-items: center; } .container { min-width: 100%; max-width: 780px; } .examples-column { width: 100%; max-width: 700px; margin-top: 30px; } .examples-grid { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 768px) { body { padding: 10px; } .container { padding: 1rem; min-width: auto; } .input-grid { grid-template-columns: 1fr; } .range-row { grid-template-columns: repeat(2, 1fr); } .controls-row { flex-direction: column; align-items: flex-start; gap: 10px; } .instruction { font-size: 0.75rem; padding: 0.5rem 1rem; width: 90%; } .examples-grid { grid-template-columns: 1fr; } .equation-container, .canvas-footer, #plot-container { width: 100%; max-width: 500px; } }
    @media (max-width: 480px) { .range-row { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="nav-container w-full bg-white shadow-md fixed top-0 left-0 z-50">
    <nav class="max-w-5xl mx-auto px-4 py-3">
      <ul class="flex justify-center space-x-4 sm:space-x-6">
        <li><a href="index.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Home</a></li>
        <li><a href="teaching.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Teaching</a></li>
        <li><a href="projects.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Diff Eq</a></li>
        <li><a href="linear.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Linear Algebra</a></li>
        <li><a href="numerical.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Numerical Methods</a></li>
      </ul>
    </nav>
  </div>
  <div class="page-container">
    <div class="main-content">
      <div class="container">
        <h1>Phase Portraits of Nonlinear Systems</h1>
        <div class="controls-section">
          <!-- System equation -->
          <div class="system-equation" id="equation-display"></div>
          <!-- Input grid for functions -->
          <div class="input-grid">
            <div class="input-group">
              <label for="fInput">f(x, y) = dx/dt</label>
              <input type="text" id="fInput" placeholder="Enter expression for dx/dt" value="-x + y + x*y">
            </div>
            <div class="input-group">
              <label for="gInput">g(x, y) = dy/dt</label>
              <input type="text" id="gInput" placeholder="Enter expression for dy/dt" value="-x - y + y^2">
            </div>
          </div>
          <!-- Range inputs -->
          <div class="range-row">
            <div class="range-input">
              <label>X Min</label>
              <input type="number" id="xMin" value="-3">
            </div>
            <div class="range-input">
              <label>X Max</label>
              <input type="number" id="xMax" value="3">
            </div>
            <div class="range-input">
              <label>Y Min</label>
              <input type="number" id="yMin" value="-3">
            </div>
            <div class="range-input">
              <label>Y Max</label>
              <input type="number" id="yMax" value="3">
            </div>
          </div>
          <!-- Controls row -->
          <div class="controls-row">
            <div class="input-group" style="flex-direction: row; align-items: center; gap: 10px;">
              <label for="arrowCount" style="white-space: nowrap;">Arrows per axis:</label>
              <input type="number" id="arrowCount" value="30" min="10" max="40" style="width: 70px;">
            </div>
            <div class="input-group" style="flex-direction: row; align-items: center; gap: 10px;">
              <label for="arrowLength" style="white-space: nowrap;">Arrow Length:</label>
              <input type="number" id="arrowLength" value="20" min="5" max="50" step="1" style="width: 70px;">
            </div>
            <div class="input-group" style="flex-direction: row; align-items: center; gap: 10px;">
              <label for="arrowThickness" style="white-space: nowrap;">Arrow Thickness:</label>
              <input type="number" id="arrowThickness" value="0.75" min="0.5" max="3" step="0.1" style="width: 70px;">
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="variableArrows" checked>
              <label for="variableArrows">Variable length</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="showGrid" checked>
              <label for="showGrid">Show grid</label>
            </div>
            <!-- Color selector for trajectories -->
            <div class="color-selector">
              <label for="trajColor">Trajectory Color:</label>
              <select id="trajColor">
                <option value="multicolor">Multicolor</option>
                <option value="blue">Blue</option>
                <option value="black">Black</option>
              </select>
            </div>
          </div>
          <div class="button-container">
            <button onclick="drawPhasePlane(true)">Generate Phase Portrait</button>
            <button class="clear" onclick="clearTrajectories()">Clear Trajectories</button>
          </div>
        </div>
        <div class="canvas-wrapper">
          <!-- Equation container above the canvas -->
          <div class="equation-container" id="canvas-equation"></div>
          <!-- Canvas container (two canvases) -->
          <div id="plot-container">
            <canvas id="field-canvas" width="700" height="700"></canvas>
            <canvas id="traj-canvas" width="700" height="700"></canvas>
            <div id="instruction" class="instruction">✨ Click anywhere on the graph to add trajectories</div>
          </div>
          <!-- Footer with download button -->
          <div class="canvas-footer">
            <button class="download-btn" onclick="downloadImage()">Download Image</button>
            <p style="margin-top: 15px;">© 2025 Shelvean Kapita • kapita@tamu.edu • All code released under the <a href="https://opensource.org/licenses/MIT" target="_blank" class="text-blue-600 hover:underline">MIT License</a>. Last modified December 13, 2025</p>
          </div>
        </div>
      </div>
      <div class="examples-column">
        <h2 class="text-2xl font-bold mb-4">Example Systems (click)</h2>
        <div class="examples-grid">
          <div class="example" data-f="y" data-g="-0.1*y - sin(x)" data-xmin="-6.25" data-xmax="6.25" data-ymin="-5" data-ymax="5">
            <h3>Damped Pendulum</h3>
            <div class="system-equations">\begin{cases} \dot{x} = y \\ \dot{y} = -0.1 y - \sin(x) \end{cases}</div>
            <div class="domain">Domain: [-6.25, 6.25] × [-5, 5]</div>
          </div>
          <div class="example" data-f="y" data-g="(1 - x^2)*y - x" data-xmin="-3.75" data-xmax="3.75" data-ymin="-3" data-ymax="3">
            <h3>Van der Pol Oscillator</h3>
            <div class="system-equations">\begin{cases} \dot{x} = y \\ \dot{y} = (1 - x^2) y - x \end{cases}</div>
            <div class="domain">Domain: [-3.75, 3.75] × [-3, 3]</div>
          </div>
          <div class="example" data-f="1*x - 0.1*x*y" data-g="0.075*x*y - 1.5*y" data-xmin="0" data-xmax="50" data-ymin="0" data-ymax="30">
            <h3>Lotka-Volterra</h3>
            <div class="system-equations">\begin{cases} \dot{x} = x - 0.1 \cdot x y \\ \dot{y} = 0.075 \cdot x y - 1.5 \cdot y \end{cases}</div>
            <div class="domain">Domain: [0, 50] × [0, 30]</div>
          </div>
          <div class="example" data-f="y" data-g="x - x^3 - 0.15*y" data-xmin="-2" data-xmax="2" data-ymin="-2" data-ymax="2">
            <h3>Duffing Oscillator</h3>
            <div class="system-equations">\begin{cases} \dot{x} = y \\ \dot{y} = x - x^3 - 0.15 y \end{cases}</div>
            <div class="domain">Domain: [-2, 2] × [-2, 2]</div>
          </div>
          <div class="example" data-f="2*x-y+3*(x^2-y^2)+2*x*y" data-g="x-3*y-3*(x^2-y^2)+3*x*y" data-xmin="-5" data-xmax="5" data-ymin="-5" data-ymax="5">
            <h3>Simple Nonlinear</h3>
            <div class="system-equations">\begin{cases} \dot{x} = 2x-y+3(x^2-y^2)+2xy \\ \dot{y} = x-3y-3(x^2-y^2)+3xy \end{cases}</div>
            <div class="domain">Domain: [-5, 5] × [-5, 5]</div>
          </div>
          <div class="example" data-f="-y + x*(1 - x^2 - y^2)" data-g="x + y*(1 - x^2 - y^2)" data-xmin="-2.5" data-xmax="2.5" data-ymin="-2" data-ymax="2">
            <h3>Limit Cycle</h3>
            <div class="system-equations">\begin{cases} \dot{x} = -y + x(1 - x^2 - y^2) \\ \dot{y} = x + y(1 - x^2 - y^2) \end{cases}</div>
            <div class="domain">Domain: [-2.5, 2.5] × [-2, 2]</div>
          </div>
          <div class="example" data-f="y" data-g="-0.1*y-x*(1-x)" data-xmin="-2.5" data-xmax="2.5" data-ymin="-2" data-ymax="2">
            <h3>Escape Equation</h3>
            <div class="system-equations">\begin{cases} \dot{x} = y \\ \dot{y} = -0.1y - x(1-x) \end{cases}</div>
            <div class="domain">Domain: [-2.5, 2.5] × [-2, 2]</div>
          </div>
          <div class="example" data-f="-x + y + x*y" data-g="-x - y + y^2" data-xmin="-3" data-xmax="3" data-ymin="-3" data-ymax="3">
            <h3>Nonlinear Focus</h3>
            <div class="system-equations">\begin{cases} \dot{x} = -x + y + xy \\ \dot{y} = -x - y + y^2 \end{cases}</div>
            <div class="domain">Domain: [-3, 3] × [-3, 3]</div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.7.0/math.min.js"></script>
  <script>
    // ------------------------------------------------------------------
    // Globals
    // ------------------------------------------------------------------
    let userPoints = [];
    let fCompiled, gCompiled;
    const fieldCanvas = document.getElementById("field-canvas");
    const trajCanvas = document.getElementById("traj-canvas");
    const fieldCtx = fieldCanvas.getContext("2d");
    const trajCtx = trajCanvas.getContext("2d");
    let instruction = document.getElementById("instruction");
    let trajectories = [];

    // ------------------------------------------------------------------
    // Init
    // ------------------------------------------------------------------
    document.addEventListener("DOMContentLoaded", () => {
      katex.render('\\begin{cases}\n \\dot{x} = f(x, y) \\\\\n \\dot{y} = g(x, y)\n \\end{cases}', document.getElementById('equation-display'), { throwOnError: false, displayMode: true });

      document.querySelectorAll('.example').forEach(example => {
        example.addEventListener('click', () => {
          userPoints = [];
          trajectories = [];
          trajCtx.clearRect(0, 0, trajCanvas.width, trajCanvas.height);
          document.getElementById('fInput').value = example.dataset.f;
          document.getElementById('gInput').value = example.dataset.g;
          document.getElementById('xMin').value = example.dataset.xmin;
          document.getElementById('xMax').value = example.dataset.xmax;
          document.getElementById('yMin').value = example.dataset.ymin;
          document.getElementById('yMax').value = example.dataset.ymax;
          instruction.style.display = 'block';
          drawPhasePlane(true);
        });
        katex.render( example.querySelector('.system-equations').textContent, example.querySelector('.system-equations'), { throwOnError: false, displayMode: true } );
      });

      fieldCanvas.addEventListener("click", e => {
        const rect = fieldCanvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        const PADDING = 50;
        if (clickX < PADDING || clickX > fieldCanvas.width - PADDING || clickY < PADDING || clickY > fieldCanvas.height - PADDING) return;
        const xMin = +document.getElementById("xMin").value;
        const xMax = +document.getElementById("xMax").value;
        const yMin = +document.getElementById("yMin").value;
        const yMax = +document.getElementById("yMax").value;
        const normX = clickX / fieldCanvas.width;
        const normY = clickY / fieldCanvas.height;
        const sysX = xMin + normX * (xMax - xMin);
        const sysY = yMax - normY * (yMax - yMin);
        userPoints.push({ x: sysX, y: sysY });
        const trajPoints = computeTrajectory(fCompiled, gCompiled, sysX, sysY, xMin, xMax, yMin, yMax);
        trajectories.push(trajPoints);
        drawTrajectoryOnTrajCanvas(trajPoints, xMin, xMax, yMin, yMax);
        instruction.style.display = "none";
      });

      const redraw = () => {
        userPoints = [];
        trajectories = [];
        trajCtx.clearRect(0, 0, trajCanvas.width, trajCanvas.height);
        drawPhasePlane(false);
      };
      const inputIds = ['fInput', 'gInput', 'xMin', 'xMax', 'yMin', 'yMax', 'arrowCount', 'arrowLength', 'arrowThickness'];
      const changeIds = ['trajColor', 'showGrid', 'variableArrows'];
      inputIds.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('input', redraw);
      });
      changeIds.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('change', redraw);
      });

      drawPhasePlane(true);
    });

    function clearTrajectories() {
      userPoints = [];
      trajectories = [];
      trajCtx.clearRect(0, 0, trajCanvas.width, trajCanvas.height);
      instruction.style.display = "block";
    }

    function drawPhasePlane(clearTrajectoriesOnGenerate) {
      if (clearTrajectoriesOnGenerate) {
        clearTrajectories();
      }
      fieldCtx.fillStyle = '#fafafa';
      fieldCtx.fillRect(0, 0, fieldCanvas.width, fieldCanvas.height);
      const f = document.getElementById("fInput").value;
      const g = document.getElementById("gInput").value;
      try {
        fCompiled = math.compile(f);
        gCompiled = math.compile(g);
      } catch(e) {
        console.error("Error compiling functions:", e);
        fieldCtx.fillStyle = '#ef4444';
        fieldCtx.font = '16px Arial';
        fieldCtx.fillText('Error in function expressions', 20, 50);
        return;
      }
      const xMin = +document.getElementById("xMin").value;
      const xMax = +document.getElementById("xMax").value;
      const yMin = +document.getElementById("yMin").value;
      const yMax = +document.getElementById("yMax").value;
      const arrowCount = +document.getElementById("arrowCount").value;
      const arrowLength = +document.getElementById("arrowLength").value || 20;
      const arrowThickness = +document.getElementById("arrowThickness").value || 0.75;
      const variableArrows = document.getElementById("variableArrows").checked;
      const showGrid = document.getElementById("showGrid").checked;
      renderEquationToCanvas(f, g);
      drawAxes(xMin, xMax, yMin, yMax, showGrid);
      drawVectorFieldLinearStyle(fCompiled, gCompiled, xMin, xMax, yMin, yMax, arrowCount, arrowLength, arrowThickness, variableArrows);
      trajectories.forEach(traj => {
        drawTrajectoryOnTrajCanvas(traj, xMin, xMax, yMin, yMax);
      });
    }

    // ------------------------------------------------------------------
    // Vector field
    // ------------------------------------------------------------------
    function drawVectorFieldLinearStyle(f, g, xMin, xMax, yMin, yMax, arrowCount, arrowLength, arrowThickness, variableArrows) {
      fieldCtx.lineWidth = arrowThickness;
      fieldCtx.strokeStyle = 'rgba(30, 100, 200, 0.9)';
      fieldCtx.fillStyle = 'rgba(30, 100, 200, 0.9)';
      const scope = { x: 0, y: 0 };
      const gridSpacingX = (xMax - xMin) / arrowCount;
      const gridSpacingY = (yMax - yMin) / arrowCount;
      const width = fieldCanvas.width;
      const height = fieldCanvas.height;
      const scaleX = width / (xMax - xMin);
      const scaleY = height / (yMax - yMin);
      const fixedArrowLength = arrowLength;
      for (let i = 0; i <= arrowCount; i++) {
        for (let j = 0; j <= arrowCount; j++) {
          const sysX = xMin + i * gridSpacingX;
          const sysY = yMin + j * gridSpacingY;
          let dx = 0, dy = 0;
          try {
            scope.x = sysX;
            scope.y = sysY;
            dx = f.evaluate(scope) || 0;
            dy = g.evaluate(scope) || 0;
          } catch (e) { continue; }
          const len = Math.sqrt(dx * dx + dy * dy);
          if (len === 0) continue;
          const deltaCanvasX = dx * scaleX;
          const deltaCanvasY = -dy * scaleY;
          const lenCanvas = Math.sqrt(deltaCanvasX * deltaCanvasX + deltaCanvasY * deltaCanvasY);
          const normDx = deltaCanvasX / lenCanvas;
          const normDy = deltaCanvasY / lenCanvas;
          const canvasX = ((sysX - xMin) / (xMax - xMin)) * width;
          const canvasY = ((yMax - sysY) / (yMax - yMin)) * height;
          let drawLength = fixedArrowLength;
          if (variableArrows) {
            const magnitude = len;
            drawLength = fixedArrowLength / Math.sqrt(1 + magnitude / 5);
            drawLength = Math.max(drawLength, 3);
          }
          const startX = canvasX - (normDx * drawLength) / 2;
          const startY = canvasY - (normDy * drawLength) / 2;
          const endX = canvasX + (normDx * drawLength) / 2;
          const endY = canvasY + (normDy * drawLength) / 2;
          fieldCtx.beginPath();
          fieldCtx.moveTo(startX, startY);
          fieldCtx.lineTo(endX, endY);
          fieldCtx.stroke();
          const headSize = Math.min(10, drawLength / 3);
          const angle = Math.atan2(normDy, normDx);
          fieldCtx.beginPath();
          fieldCtx.moveTo(endX, endY);
          fieldCtx.lineTo(endX - headSize * Math.cos(angle - Math.PI / 6), endY - headSize * Math.sin(angle - Math.PI / 6));
          fieldCtx.moveTo(endX, endY);
          fieldCtx.lineTo(endX - headSize * Math.cos(angle + Math.PI / 6), endY - headSize * Math.sin(angle + Math.PI / 6));
          fieldCtx.stroke();
        }
      }
    }

    // ------------------------------------------------------------------
    // RK4 integration
    // ------------------------------------------------------------------
    function computeTrajectory(f, g, x0, y0, xMin, xMax, yMin, yMax) {
      const dt = 0.01;
      const maxSteps = 4000;
      const points = [{ x: x0, y: y0 }];
      const scope = { x: 0, y: 0 };
      // Forward
      let x = x0, y = y0;
      scope.x = x; scope.y = y;
      for (let i = 0; i < maxSteps; i++) {
        try {
          const k1x = f.evaluate(scope), k1y = g.evaluate(scope);
          scope.x = x + k1x * dt / 2; scope.y = y + k1y * dt / 2;
          const k2x = f.evaluate(scope), k2y = g.evaluate(scope);
          scope.x = x + k2x * dt / 2; scope.y = y + k2y * dt / 2;
          const k3x = f.evaluate(scope), k3y = g.evaluate(scope);
          scope.x = x + k3x * dt; scope.y = y + k3y * dt;
          const k4x = f.evaluate(scope), k4y = g.evaluate(scope);
          x += (k1x + 2 * k2x + 2 * k3x + k4x) / 6 * dt;
          y += (k1y + 2 * k2y + 2 * k3y + k4y) / 6 * dt;
          if (x < xMin - 1 || x > xMax + 1 || y < yMin - 1 || y > yMax + 1) break;
          points.push({ x, y });
          scope.x = x; scope.y = y;
        } catch(e) { break; }
      }
      // Backward
      x = x0; y = y0;
      scope.x = x; scope.y = y;
      const backwardPoints = [];
      for (let i = 0; i < maxSteps; i++) {
        try {
          const k1x = f.evaluate(scope), k1y = g.evaluate(scope);
          scope.x = x - k1x * dt / 2; scope.y = y - k1y * dt / 2;
          const k2x = f.evaluate(scope), k2y = g.evaluate(scope);
          scope.x = x - k2x * dt / 2; scope.y = y - k2y * dt / 2;
          const k3x = f.evaluate(scope), k3y = g.evaluate(scope);
          scope.x = x - k3x * dt; scope.y = y - k3y * dt;
          const k4x = f.evaluate(scope), k4y = g.evaluate(scope);
          x -= (k1x + 2 * k2x + 2 * k3x + k4x) / 6 * dt;
          y -= (k1y + 2 * k2y + 2 * k3y + k4y) / 6 * dt;
          if (x < xMin - 1 || x > xMax + 1 || y < yMin - 1 || y > yMax + 1) break;
          backwardPoints.unshift({ x, y });
          scope.x = x; scope.y = y;
        } catch(e) { break; }
      }
      return [...backwardPoints, ...points];
    }

    function drawTrajectoryOnTrajCanvas(points, xMin, xMax, yMin, yMax) {
      if (points.length < 2) return;
      const trajColor = document.getElementById("trajColor").value;
      let color;
      if (trajColor === "multicolor") {
        const colors = ['#dc2626', '#ea580c', '#ca8a04', '#16a34a', '#0891b2', '#7c3aed', '#db2777', '#4b5563'];
        color = colors[trajectories.length % colors.length];
      } else if (trajColor === "blue") {
        color = '#3b82f6';
      } else if (trajColor === "black") {
        color = '#000000';
      }
      trajCtx.strokeStyle = color;
      trajCtx.lineWidth = 1.8;
      trajCtx.lineJoin = 'round';
      trajCtx.lineCap = 'round';
      trajCtx.beginPath();
      points.forEach((p, i) => {
        const cx = ((p.x - xMin) / (xMax - xMin)) * fieldCanvas.width;
        const cy = ((yMax - p.y) / (yMax - yMin)) * fieldCanvas.height;
        if (i === 0) trajCtx.moveTo(cx, cy);
        else trajCtx.lineTo(cx, cy);
      });
      trajCtx.stroke();
    }

    function renderEquationToCanvas(f, g) {
      const eqContainer = document.getElementById('canvas-equation');
      eqContainer.innerHTML = '';
      const formatExpr = (expr) => {
        return expr
          .replace(/\*/g, '·')
          .replace(/sin\(/g, '\\sin(')
          .replace(/cos\(/g, '\\cos(')
          .replace(/tan\(/g, '\\tan(')
          .replace(/\^/g, '^');
      };
      const eqString = `\\begin{cases} \\dot{x} = ${formatExpr(f)} \\\\ \\dot{y} = ${formatExpr(g)} \\end{cases}`;
      katex.render(eqString, eqContainer, { throwOnError: false, displayMode: true });
    }

    function drawAxes(xMin, xMax, yMin, yMax, showGrid) {
      if (showGrid) {
        fieldCtx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
        fieldCtx.lineWidth = 0.5;
        const xStep = getNiceStep(xMax - xMin);
        for (let i = Math.ceil(xMin / xStep) * xStep; i < xMax; i += xStep) {
          const x = ((i - xMin) / (xMax - xMin)) * fieldCanvas.width;
          fieldCtx.beginPath();
          fieldCtx.moveTo(x, 0);
          fieldCtx.lineTo(x, fieldCanvas.height);
          fieldCtx.stroke();
        }
        const yStep = getNiceStep(yMax - yMin);
        for (let i = Math.ceil(yMin / yStep) * yStep; i < yMax; i += yStep) {
          const y = ((yMax - i) / (yMax - yMin)) * fieldCanvas.height;
          fieldCtx.beginPath();
          fieldCtx.moveTo(0, y);
          fieldCtx.lineTo(fieldCanvas.width, y);
          fieldCtx.stroke();
        }
      }
      fieldCtx.strokeStyle = '#000';
      fieldCtx.lineWidth = 2;
      if (yMin <= 0 && yMax >= 0) {
        const y0 = ((yMax - 0) / (yMax - yMin)) * fieldCanvas.height;
        fieldCtx.beginPath();
        fieldCtx.moveTo(0, y0);
        fieldCtx.lineTo(fieldCanvas.width, y0);
        fieldCtx.stroke();
      }
      if (xMin <= 0 && xMax >= 0) {
        const x0 = ((0 - xMin) / (xMax - xMin)) * fieldCanvas.width;
        fieldCtx.beginPath();
        fieldCtx.moveTo(x0, 0);
        fieldCtx.lineTo(x0, fieldCanvas.height);
        fieldCtx.stroke();
      }
      drawAxisLabels(xMin, xMax, yMin, yMax);
    }

    function getNiceStep(range) {
      const rough = range / 8;
      const exp = Math.pow(10, Math.floor(Math.log10(rough)));
      const frac = rough / exp;
      return (frac <= 1.5 ? 1 : frac <= 3.5 ? 2 : frac <= 7 ? 5 : 10) * exp;
    }

    function drawAxisLabels(xMin, xMax, yMin, yMax) {
      fieldCtx.font = 'bold 14px Arial';
      fieldCtx.fillStyle = '#111';
      fieldCtx.textAlign = 'center';
      fieldCtx.textBaseline = 'top';
      const xStep = getNiceStep(xMax - xMin);
      for (let i = Math.ceil(xMin / xStep) * xStep; i <= xMax + 1e-9; i += xStep) {
        const x = ((i - xMin) / (xMax - xMin)) * fieldCanvas.width;
        const y = fieldCanvas.height - 20;
        fieldCtx.fillText(i.toFixed(2).replace(/\.00$/, ''), x, y);
      }
      fieldCtx.textAlign = 'right';
      fieldCtx.textBaseline = 'middle';
      const yStep = getNiceStep(yMax - yMin);
      for (let i = Math.ceil(yMin / yStep) * yStep; i <= yMax + 1e-9; i += yStep) {
        const y = ((yMax - i) / (yMax - yMin)) * fieldCanvas.height;
        const x = 25;
        fieldCtx.fillText(i.toFixed(2).replace(/\.00$/, ''), x, y);
      }
      fieldCtx.textAlign = 'center';
      fieldCtx.textBaseline = 'top';
      fieldCtx.fillText('x', fieldCanvas.width / 2, fieldCanvas.height - 40);
      fieldCtx.save();
      fieldCtx.textAlign = 'center';
      fieldCtx.textBaseline = 'middle';
      fieldCtx.translate(15, fieldCanvas.height / 2);
      fieldCtx.rotate(-Math.PI / 2);
      fieldCtx.fillText('y', 0, 0);
      fieldCtx.restore();
    }

    // ------------------------------------------------------------------
    // Download image
    // ------------------------------------------------------------------
    function downloadImage() {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = fieldCanvas.width;
      tempCanvas.height = fieldCanvas.height + 120;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.fillStyle = '#fafafa';
      tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
      const f = document.getElementById("fInput").value;
      const g = document.getElementById("gInput").value;
      const xMin = +document.getElementById("xMin").value;
      const xMax = +document.getElementById("xMax").value;
      const yMin = +document.getElementById("yMin").value;
      const yMax = +document.getElementById("yMax").value;
      const arrowCount = +document.getElementById("arrowCount").value;
      const arrowLength = +document.getElementById("arrowLength").value || 20;
      const arrowThickness = +document.getElementById("arrowThickness").value || 0.75;
      const variableArrows = document.getElementById("variableArrows").checked;
      const showGrid = document.getElementById("showGrid").checked;
      const trajColor = document.getElementById("trajColor").value;
      tempCtx.fillStyle = '#4f46e5';
      tempCtx.font = 'bold 16px Arial';
      tempCtx.textAlign = 'center';
      tempCtx.textBaseline = 'middle';
      tempCtx.fillText('Nonlinear Phase Portrait', tempCanvas.width / 2, 20);
      tempCtx.fillStyle = 'white';
      tempCtx.strokeStyle = '#3b82f6';
      tempCtx.lineWidth = 2;
      tempCtx.beginPath();
      tempCtx.roundRect(tempCanvas.width / 2 - 200, 40, 400, 40, 10);
      tempCtx.fill();
      tempCtx.stroke();
      tempCtx.fillStyle = '#1e293b';
      tempCtx.font = 'bold 14px Arial';
      const eqText = `x' = ${f}, y' = ${g}`;
      tempCtx.fillText(eqText, tempCanvas.width / 2, 60);
      tempCtx.font = '12px Arial';
      tempCtx.fillStyle = '#6b7280';
      tempCtx.fillText(`Domain: [${xMin}, ${xMax}] × [${yMin}, ${yMax}]`, tempCanvas.width / 2, 85);
      const graphOffsetY = 110;
      const graphCanvas = document.createElement('canvas');
      graphCanvas.width = fieldCanvas.width;
      graphCanvas.height = fieldCanvas.height;
      const graphCtx = graphCanvas.getContext('2d');
      graphCtx.fillStyle = '#fafafa';
      graphCtx.fillRect(0, 0, graphCanvas.width, graphCanvas.height);
      try {
        const fCompiledTemp = math.compile(f);
        const gCompiledTemp = math.compile(g);
        if (showGrid) {
          graphCtx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
          graphCtx.lineWidth = 0.5;
          const xStep = getNiceStep(xMax - xMin);
          for (let i = Math.ceil(xMin / xStep) * xStep; i < xMax; i += xStep) {
            const x = ((i - xMin) / (xMax - xMin)) * graphCanvas.width;
            graphCtx.beginPath();
            graphCtx.moveTo(x, 0);
            graphCtx.lineTo(x, graphCanvas.height);
            graphCtx.stroke();
          }
          const yStep = getNiceStep(yMax - yMin);
          for (let i = Math.ceil(yMin / yStep) * yStep; i < yMax; i += yStep) {
            const y = ((yMax - i) / (yMax - yMin)) * graphCanvas.height;
            graphCtx.beginPath();
            graphCtx.moveTo(0, y);
            graphCtx.lineTo(graphCanvas.width, y);
            graphCtx.stroke();
          }
        }
        graphCtx.strokeStyle = '#000';
        graphCtx.lineWidth = 2;
        if (yMin <= 0 && yMax >= 0) {
          const y0 = ((yMax - 0) / (yMax - yMin)) * graphCanvas.height;
          graphCtx.beginPath();
          graphCtx.moveTo(0, y0);
          graphCtx.lineTo(graphCanvas.width, y0);
          graphCtx.stroke();
        }
        if (xMin <= 0 && xMax >= 0) {
          const x0 = ((0 - xMin) / (xMax - xMin)) * graphCanvas.width;
          graphCtx.beginPath();
          graphCtx.moveTo(x0, 0);
          graphCtx.lineTo(x0, graphCanvas.height);
          graphCtx.stroke();
        }
        graphCtx.font = 'bold 14px Arial';
        graphCtx.fillStyle = '#111';
        graphCtx.textAlign = 'center';
        graphCtx.textBaseline = 'top';
        const xStep = getNiceStep(xMax - xMin);
        for (let i = Math.ceil(xMin / xStep) * xStep; i <= xMax + 1e-9; i += xStep) {
          const x = ((i - xMin) / (xMax - xMin)) * graphCanvas.width;
          const y = graphCanvas.height - 20;
          graphCtx.fillText(i.toFixed(2).replace(/\.00$/, ''), x, y);
        }
        graphCtx.textAlign = 'right';
        graphCtx.textBaseline = 'middle';
        const yStep = getNiceStep(yMax - yMin);
        for (let i = Math.ceil(yMin / yStep) * yStep; i <= yMax + 1e-9; i += yStep) {
          const y = ((yMax - i) / (yMax - yMin)) * graphCanvas.height;
          const x = 25;
          graphCtx.fillText(i.toFixed(2).replace(/\.00$/, ''), x, y);
        }
        const scope = { x: 0, y: 0 };
        const stepX = (xMax - xMin) / arrowCount;
        const stepY = (yMax - yMin) / arrowCount;
        const width = graphCanvas.width;
        const height = graphCanvas.height;
        const scaleX = width / (xMax - xMin);
        const scaleY = height / (yMax - yMin);
        const fixedArrowLength = arrowLength;
        graphCtx.lineWidth = arrowThickness;
        graphCtx.strokeStyle = 'rgba(30, 100, 200, 0.9)';
        graphCtx.fillStyle = 'rgba(30, 100, 200, 0.9)';
        for (let i = 0; i <= arrowCount; i++) {
          for (let j = 0; j <= arrowCount; j++) {
            const sysX = xMin + i * stepX;
            const sysY = yMin + j * stepY;
            let dx = 0, dy = 0;
            try {
              scope.x = sysX;
              scope.y = sysY;
              dx = fCompiledTemp.evaluate(scope) || 0;
              dy = gCompiledTemp.evaluate(scope) || 0;
            } catch(e) { continue; }
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len === 0) continue;
            const deltaCanvasX = dx * scaleX;
            const deltaCanvasY = -dy * scaleY;
            const lenCanvas = Math.sqrt(deltaCanvasX * deltaCanvasX + deltaCanvasY * deltaCanvasY);
            const normDx = deltaCanvasX / lenCanvas;
            const normDy = deltaCanvasY / lenCanvas;
            const canvasX = ((sysX - xMin) / (xMax - xMin)) * width;
            const canvasY = ((yMax - sysY) / (yMax - yMin)) * height;
            let drawLength = fixedArrowLength;
            if (variableArrows) {
              const magnitude = len;
              drawLength = fixedArrowLength / Math.sqrt(1 + magnitude / 5);
              drawLength = Math.max(drawLength, 3);
            }
            const startX = canvasX - (normDx * drawLength) / 2;
            const startY = canvasY - (normDy * drawLength) / 2;
            const endX = canvasX + (normDx * drawLength) / 2;
            const endY = canvasY + (normDy * drawLength) / 2;
            graphCtx.beginPath();
            graphCtx.moveTo(startX, startY);
            graphCtx.lineTo(endX, endY);
            graphCtx.stroke();
            const headSize = Math.min(10, drawLength / 3);
            const angle = Math.atan2(normDy, normDx);
            graphCtx.beginPath();
            graphCtx.moveTo(endX, endY);
            graphCtx.lineTo(endX - headSize * Math.cos(angle - Math.PI / 6), endY - headSize * Math.sin(angle - Math.PI / 6));
            graphCtx.moveTo(endX, endY);
            graphCtx.lineTo(endX - headSize * Math.cos(angle + Math.PI / 6), endY - headSize * Math.sin(angle + Math.PI / 6));
            graphCtx.stroke();
          }
        }
        const colors = { multicolor: ['#dc2626', '#ea580c', '#ca8a04', '#16a34a', '#0891b2', '#7c3aed', '#db2777', '#4b5563'], blue: ['#3b82f6'], black: ['#000000'] };
        trajectories.forEach((traj, idx) => {
          if (traj.length > 1) {
            let color;
            if (trajColor === "multicolor") {
              color = colors.multicolor[idx % colors.multicolor.length];
            } else {
              color = colors[trajColor][0];
            }
            graphCtx.strokeStyle = color;
            graphCtx.lineWidth = 1.8;
            graphCtx.lineJoin = 'round';
            graphCtx.lineCap = 'round';
            graphCtx.beginPath();
            traj.forEach((p, i) => {
              const cx = ((p.x - xMin) / (xMax - xMin)) * graphCanvas.width;
              const cy = ((yMax - p.y) / (yMax - yMin)) * graphCanvas.height;
              if (i === 0) graphCtx.moveTo(cx, cy);
              else graphCtx.lineTo(cx, cy);
            });
            graphCtx.stroke();
          }
        });
        graphCtx.textAlign = 'center';
        graphCtx.textBaseline = 'top';
        graphCtx.fillText('x', graphCanvas.width / 2, graphCanvas.height - 40);
        graphCtx.save();
        graphCtx.textAlign = 'center';
        graphCtx.textBaseline = 'middle';
        graphCtx.translate(15, graphCanvas.height / 2);
        graphCtx.rotate(-Math.PI / 2);
        graphCtx.fillText('y', 0, 0);
        graphCtx.restore();
      } catch(e) {
        console.error("Error creating download image:", e);
      }
      tempCtx.drawImage(graphCanvas, 0, graphOffsetY);
      const link = document.createElement('a');
      link.download = 'nonlinear-phase-portrait.png';
      link.href = tempCanvas.toDataURL('image/png');
      link.click();
    }
  </script>
</body>
</html>
