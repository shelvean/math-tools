<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Direction Field Visualizer • Shelvean Kapita</title>
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body, {delimiters: [{left: '$', right: '$', display: false},{left: '$$', right: '$$', display: true}], throwOnError: false});"></script>
<style>
  body {background:linear-gradient(135deg,#f8f9fa,#e9ecef);min-height:100vh;}
  .main-container{max-width:1500px;margin:140px auto 0;padding:20px;display:flex;gap:30px;flex-wrap:wrap;}
  .left-panel{flex:1;min-width:320px;display:flex;flex-direction:column;gap:20px;}
  .controls{background:rgba(255,255,255,0.95);backdrop-filter:blur(10px);border-radius:15px;padding:1.8rem;box-shadow:0 8px 32px rgba(0,0,0,0.1);border:1px solid rgba(255,255,255,0.3);}
  .canvas-container{background:white;border-radius:15px;box-shadow:0 8px 32px rgba(0,0,0,0.1);position:relative;padding:20px;}
  .control-group{margin:1rem 0;display:flex;align-items:center;gap:0.8rem;flex-wrap:wrap;}
  .control-group.buttons{justify-content:center;margin-top:1.5rem;}
  label{color:#2b2d42;font-weight:500;min-width:160px;}
  input[type="text"],input[type="number"]{padding:0.7rem 1rem;border:2px solid #dee2e6;border-radius:8px;background:white;font-size:1rem;}
  input:focus{outline:none;border-color:#4cc9f0;box-shadow:0 0 0 3px rgba(76,201,240,0.2);}
  .btn-gradient{padding:0.75rem 2rem;border:none;border-radius:12px;font-weight:600;font-size:1rem;color:white;cursor:pointer;transition:all 0.3s ease;box-shadow:0 4px 15px rgba(0,0,0,0.1);text-shadow:0 1px 2px rgba(0,0,0,0.2);}
  .btn-gradient:hover{transform:translateY(-3px);box-shadow:0 10px 25px rgba(0,0,0,0.2);}
  .btn-update{background-image:linear-gradient(to right,#4ade80,#22c55e,#16a34a);}
  .btn-clear{background-image:linear-gradient(to right,#f87171,#ef4444,#dc2626);}
  .btn-download{background-image:linear-gradient(to right,#60a5fa,#3b82f6,#2563eb);}
  canvas{display:block;cursor:crosshair;border-radius:8px;box-shadow:0 4px 15px rgba(0,0,0,0.1);}
  .instruction{position:absolute;top:35px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,0.85);color:#1e293b;font-weight:600;font-size:1rem;padding:0.75rem 1.8rem;border-radius:50px;border:2px solid rgba(99,102,241,0.4);backdrop-filter:blur(12px);box-shadow:0 8px 25px rgba(0,0,0,0.12);z-index:20;animation:gentleFloat 4s ease-in-out infinite;white-space:nowrap;}
  .instruction:hover{background:rgba(255,255,255,0.95);border-color:#6366f1;transform:translateX(-50%) translateY(-5px);}
  @keyframes gentleFloat{0%,100%{transform:translateX(-50%) translateY(0);}50%{transform:translateX(-50%) translateY(-6px);}}
  .functions-sidebar{ width:340px;background:rgba(255,255,255,0.97);backdrop-filter:blur(12px); border-radius:15px;padding:1.8rem;box-shadow:0 8px 32px rgba(0,0,0,0.12); border:1px solid rgba(255,255,255,0.4);position:sticky;top:140px;align-self:start; max-height:calc(100vh-160px);overflow:hidden;transition:all 0.4s ease; }
  .functions-content{display:none;}
  .functions-content.show{display:block;}
  .toggle-btn{ width:100%;padding:1rem;background:linear-gradient(to right,#6366f1,#4f46e5); color:white;font-weight:600;border:none;border-radius:12px;cursor:pointer; font-size:1.1rem;transition:all 0.3s;box-shadow:0 4px 15px rgba(79,70,229,0.3); }
  .toggle-btn:hover{transform:translateY(-2px);box-shadow:0 8px 20px rgba(79,70,229,0.4);}
  .func-table{width:100%;margin-top:1rem;}
  .func-table td{padding:0.7rem 0;border-bottom:1px solid #eee;}
  .func-name{font-family:'Consolas',monospace;color:#d6336c;background:#f8f9fa;padding:0.3rem 0.6rem;border-radius:4px;}
  .func-latex{text-align:center;color:#4361ee;}
  .footer{margin-top:30px;padding:15px;text-align:center;color:#6c757d;font-size:0.9rem;border-top:1px solid #dee2e6;}
</style>
</head>
<body>
<nav class="fixed top-0 left-0 w-full z-50 bg-white shadow-md">
  <div class="max-w-5xl mx-auto px-4 py-3">
    <ul class="flex justify-center space-x-6">
      <li><a href="index.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-xl">Home</a></li>
      <li><a href="teaching.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-xl">Teaching</a></li>
      <li><a href="projects.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-xl">Diff Eq</a></li>
      <li><a href="linear.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-xl">Linear Algebra</a></li>
      <li><a href="numerical.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-xl">Numerical Methods</a></li>
    </ul>
  </div>
</nav>

<div class="main-container">
  <div class="left-panel">
    <div class="controls">
      <div class="katex-instruction" id="katex-instruction"></div>
      <div class="control-group">
        <label>Differential Equation: y' =</label>
        <input type="text" id="equation" value="min(5*cos(y), -4*x*sin(y))" style="flex:1; min-width:180px; max-width:400px;">
      </div>
      <div class="control-group">
        <label>Horizontal (t or x):</label>
        <input type="number" id="tMin" value="-5" step="0.5"><span>to</span><input type="number" id="tMax" value="5" step="0.5">
      </div>
      <div class="control-group">
        <label>Vertical (y):</label>
        <input type="number" id="yMin" value="-2" step="0.5"><span>to</span><input type="number" id="yMax" value="10" step="0.5">
      </div>
      <div class="control-group">
        <label>Arrow Length:</label>
        <input type="number" id="arrowLength" value="15" min="5" max="50">
        <label style="margin-left:20px;">Arrows per Axis:</label>
        <input type="number" id="arrowsPerAxis" value="25" min="10" max="50">
      </div>
      <!-- NEW Arrow Thickness Control -->
      <div class="control-group">
        <label>Arrow Thickness:</label>
        <input type="range" id="arrowThickness" min="0.5" max="3" step="0.1" value="0.8" style="flex:1;">
        <span id="thicknessValue" style="min-width:50px;text-align:right;font-weight:600;color:#4361ee;">0.8</span>
      </div>
      <div class="control-group buttons">
        <button onclick="drawDirectionField(true)" class="btn-gradient btn-update">Update Field</button>
        <button onclick="clearSolutions()" class="btn-gradient btn-clear">Clear Solutions</button>
      </div>
    </div>

    <div class="canvas-container">
      <div class="instruction" id="instruction">Click anywhere to draw a solution curve</div>
      <canvas id="canvas" width="900" height="600"></canvas>
      <div class="text-center mt-8">
        <button onclick="downloadPNG()" class="btn-gradient btn-download text-lg px-8 py-4">Download as PNG</button>
      </div>
    </div>

    <div class="footer">
      © 2025 Shelvean Kapita • kapita@tamu.edu<br>
      Last updated: November 30, 2025
    </div>
  </div>

  <!-- Toggleable Supported Functions Sidebar -->
  <div class="functions-sidebar">
    <button id="toggleFunctions" class="toggle-btn">Show Supported Functions</button>
    <div id="functionsContent" class="functions-content">
      <h3 style="text-align:center;color:#4361ee;margin:1.2rem 0 0.8rem;">Supported Functions</h3>
      <table class="func-table">
        <tr><td class="func-name">sqrt(x)</td><td class="func-latex">$\sqrt{x}$</td></tr>
        <tr><td class="func-name">cbrt(x)</td><td class="func-latex">$\sqrt[3]{x}$</td></tr>
        <tr><td class="func-name">abs(x)</td><td class="func-latex">$|x|$</td></tr>
        <tr><td class="func-name">sin(x)</td><td class="func-latex">$\sin x$</td></tr>
        <tr><td class="func-name">cos(x)</td><td class="func-latex">$\cos x$</td></tr>
        <tr><td class="func-name">tan(x)</td><td class="func-latex">$\tan x$</td></tr>
        <tr><td class="func-name">asin(x)</td><td class="func-latex">$\arcsin x$</td></tr>
        <tr><td class="func-name">acos(x)</td><td class="func-latex">$\arccos x$</td></tr>
        <tr><td class="func-name">atan(x)</td><td class="func-latex">$\arctan x$</td></tr>
        <tr><td class="func-name">sinh(x)</td><td class="func-latex">$\sinh x$</td></tr>
        <tr><td class="func-name">cosh(x)</td><td class="func-latex">$\cosh x$</td></tr>
        <tr><td class="func-name">tanh(x)</td><td class="func-latex">$\tanh x$</td></tr>
        <tr><td class="func-name">exp(x)</td><td class="func-latex">$e^{x}$</td></tr>
        <tr><td class="func-name">log(x)</td><td class="func-latex">$\ln x$</td></tr>
        <tr><td class="func-name">log10(x)</td><td class="func-latex">$\log_{10} x$</td></tr>
        <tr><td class="func-name">pi</td><td class="func-latex">$\pi$</td></tr>
        <tr><td class="func-name">e</td><td class="func-latex">$e$</td></tr>
        <tr><td class="func-name">ceil(x)</td><td class="func-latex">$\lceil x \rceil$</td></tr>
        <tr><td class="func-name">floor(x)</td><td class="func-latex">$\lfloor x \rfloor$</td></tr>
        <tr><td class="func-name">round(x)</td><td class="func-latex">$\operatorname{round}(x)$</td></tr>
        <tr><td class="func-name">max(a,b)</td><td class="func-latex">$\max(a,b)$</td></tr>
        <tr><td class="func-name">min(a,b)</td><td class="func-latex">$\min(a,b)$</td></tr>
      </table>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  katex.render("\\text{Enter } \\dfrac{dy}{dt} = f(t,y) \\text{ or } \\dfrac{dy}{dx} = f(x,y)", document.getElementById('katex-instruction'), {throwOnError:false});

  // Update displayed thickness value
  const thicknessSlider = document.getElementById('arrowThickness');
  const thicknessValueSpan = document.getElementById('thicknessValue');
  thicknessSlider.addEventListener('input', () => {
    thicknessValueSpan.textContent = thicknessSlider.value;
  });

  // Toggle supported functions
  const toggleBtn = document.getElementById('toggleFunctions');
  const content = document.getElementById('functionsContent');
  toggleBtn.addEventListener('click', () => {
    const isShown = content.classList.toggle('show');
    toggleBtn.textContent = isShown ? "Hide Supported Functions" : "Show Supported Functions";
  });

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const PADDING = 60;
  let solutions = [];
  let colorIndex = 0;
  const COLORS = [[0,0,0],[46,139,87],[255,140,0],[255,0,0],[139,0,139],[220,20,60],[65,105,225],[0,128,128],[165,42,42]];

  function preprocess(eq) {
    return eq
      .replace(/\bx\b/g, 't')
      .replace(/\b(sin|cos|tan|sinh|cosh|tanh|asin|acos|atan|exp|log|log10|sqrt|cbrt|abs|ceil|floor|round|max|min)\b/gi, 'Math.$1')
      .replace(/\^/g, '**')
      .replace(/\bpi\b/gi, 'Math.PI')
      .replace(/(?<!Math\.)e(?!\w)/g, 'Math.E');
  }

  function getNiceStep(range) {
    const rough = range / 6;
    const exp = Math.pow(10, Math.floor(Math.log10(rough)));
    const frac = rough / exp;
    return (frac <= 1.5 ? 1 : frac <= 3.5 ? 2 : frac <= 7 ? 5 : 10) * exp;
  }

  function drawAxisLabels(tMin, tMax, yMin, yMax, xScale, yScale) {
    ctx.font = '14px Arial';
    ctx.fillStyle = '#333';
    ctx.textAlign = 'center';
    const tStep = getNiceStep(tMax - tMin);
    for (let t = Math.ceil(tMin/tStep)*tStep; t <= tMax + 1e-9; t += tStep) {
      const x = PADDING + (t - tMin)*xScale;
      ctx.fillText(t.toFixed(1).replace(/\.0$/, ''), x, canvas.height - 10);
    }
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    const yStep = getNiceStep(yMax - yMin);
    for (let y = Math.ceil(yMin/yStep)*yStep; y <= yMax + 1e-9; y += yStep) {
      const py = canvas.height - PADDING - (y - yMin)*yScale;
      ctx.fillText(y.toFixed(1).replace(/\.0$/, ''), PADDING - 10, py);
    }
  }

  window.drawDirectionField = function(clearFlag = false) {
    if (clearFlag) {
      solutions = [];
      document.getElementById('instruction').style.display = 'block';
    }
    ctx.clearRect(0,0,canvas.width,canvas.height);

    const eq = document.getElementById('equation').value.trim() || "0";
    const tMin = +document.getElementById('tMin').value;
    const tMax = +document.getElementById('tMax').value;
    const yMin = +document.getElementById('yMin').value;
    const yMax = +document.getElementById('yMax').value;
    const arrowLen = +document.getElementById('arrowLength').value || 15;
    const arrowsN = +document.getElementById('arrowsPerAxis').value || 25;
    const arrowThickness = +document.getElementById('arrowThickness').value;

    const step = Math.min((canvas.width-2*PADDING)/arrowsN, (canvas.height-2*PADDING)/arrowsN);
    const xScale = (canvas.width-2*PADDING)/(tMax-tMin);
    const yScale = (canvas.height-2*PADDING)/(yMax-yMin);
    const aspect = yScale/xScale;

    const slopeFunc = new Function('t','y',`return ${preprocess(eq)}`);

    // Grid lines
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 0.5;
    for (let i=Math.ceil(tMin); i<tMax; i++) {
      const x = PADDING + (i-tMin)*xScale;
      ctx.beginPath();
      ctx.moveTo(x,PADDING);
      ctx.lineTo(x,canvas.height-PADDING);
      ctx.stroke();
    }
    for (let i=Math.ceil(yMin); i<yMax; i++) {
      const y = canvas.height-PADDING - (i-yMin)*yScale;
      ctx.beginPath();
      ctx.moveTo(PADDING,y);
      ctx.lineTo(canvas.width-PADDING,y);
      ctx.stroke();
    }

    // Arrows
    for (let px=PADDING+step/2; px<canvas.width-PADDING; px+=step) {
      for (let py=PADDING+step/2; py<canvas.height-PADDING; py+=step) {
        const t = tMin + (px-PADDING)/xScale;
        const y = yMin + (canvas.height-PADDING-py)/yScale;
        let m;
        try { m = slopeFunc(t,y); } catch(e) { continue; }
        if (!isFinite(m)) continue;

        const angle = Math.atan(-m*aspect);
        const dx = arrowLen*Math.cos(angle);
        const dy = arrowLen*Math.sin(angle);

        ctx.strokeStyle = '#111';
        ctx.lineWidth = arrowThickness;  // ← now uses the slider value
        ctx.beginPath();
        ctx.moveTo(px-dx/2, py-dy/2);
        ctx.lineTo(px+dx/2, py+dy/2);
        ctx.stroke();

        const head=5;
        ctx.beginPath();
        ctx.moveTo(px+dx/2, py+dy/2);
        ctx.lineTo(px+dx/2 - head*Math.cos(angle-Math.PI/6), py+dy/2 - head*Math.sin(angle-Math.PI/6));
        ctx.moveTo(px+dx/2, py+dy/2);
        ctx.lineTo(px+dx/2 - head*Math.cos(angle+Math.PI/6), py+dy/2 - head*Math.sin(angle+Math.PI/6));
        ctx.stroke();
      }
    }

    // Axes
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    if (yMin <= 0 && yMax >= 0) {
      const y0 = canvas.height - PADDING;
      ctx.beginPath();
      ctx.moveTo(PADDING, y0);
      ctx.lineTo(canvas.width-PADDING, y0);
      ctx.stroke();
    }
    if (tMin <= 0 && tMax >= 0) {
      const x0 = PADDING;
      ctx.beginPath();
      ctx.moveTo(x0, PADDING);
      ctx.lineTo(x0, canvas.height-PADDING);
      ctx.stroke();
    }

    drawAxisLabels(tMin, tMax, yMin, yMax, xScale, yScale);

    // Draw solution curves
    solutions.forEach(s => {
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      let started = false;
      for (let i = 0; i < s.points.length; i++) {
        const p = s.points[i];
        const x = PADDING + (p.t - tMin) * xScale;
        const y = canvas.height - PADDING - (p.y - yMin) * yScale;
        if (p.t >= tMin && p.t <= tMax && p.y >= yMin && p.y <= yMax) {
          if (!started) { ctx.moveTo(x, y); started = true; }
          else { ctx.lineTo(x, y); }
        } else if (started) {
          ctx.stroke();
          ctx.beginPath();
          started = false;
        }
      }
      if (started) ctx.stroke();
    });

    document.getElementById('instruction').style.display = solutions.length === 0 ? 'block' : 'none';
  };

  // (solve function, canvas click handler, clearSolutions, downloadPNG remain unchanged)
  function solve(t0, y0) {
    const h = 0.005;
    const func = new Function('t','y',`return ${preprocess(document.getElementById('equation').value)}`);
    const tMin = +document.getElementById('tMin').value;
    const tMax = +document.getElementById('tMax').value;
    const yMin = +document.getElementById('yMin').value;
    const yMax = +document.getElementById('yMax').value;

    let f0;
    try { f0 = func(t0, y0); } catch(e) { f0 = NaN; }

    const isCircular = !isNaN(f0) && Math.abs(t0 * 1 + y0 * f0) < 1e-8 && Math.abs(y0) > 1e-10;
    if (isCircular) {
      const r = Math.sqrt(t0*t0 + y0*y0);
      const pts = [];
      const steps = 1000;
      const theta0 = Math.atan2(y0, t0);
      for (let i = 0; i <= steps; i++) {
        const theta = theta0 + (i/steps - 0.5) * 2 * Math.PI;
        const t = r * Math.cos(theta);
        const y = r * Math.sin(theta);
        pts.push({t, y});
      }
      return pts.filter(p => p.t >= tMin && p.t <= tMax && p.y >= yMin && p.y <= yMax);
    }

    const pts = [];
    let t = t0, y = y0;
    let prev_f = null, prev_prev_f = null;
    if (t >= tMin && t <= tMax && y >= yMin && y <= yMax) pts.push({t, y});

    while (t < tMax + h && Math.abs(y) < 1e8) {
      let f_mid;
      try { f_mid = func(t + h/2, y + h/2 * f0); } catch(e) { f_mid = func(t + h/2, y); }
      if (isNaN(f_mid)) break;
      let t_new = t + h;
      let y_new = y + h * f_mid;

      const dot = t * 1 + y * f0;
      if (Math.abs(dot) < 1e-6 && t*t + y*y > 1e-12) {
        const r2 = t*t + y*y;
        const r2_new = t_new*t_new + y_new*y_new;
        if (r2_new > 0) {
          const scale = Math.sqrt(r2 / r2_new);
          t_new *= scale;
          y_new *= scale;
        }
      }

      let current_f;
      try { current_f = func(t_new, y_new); } catch(e) { current_f = NaN; }
      if (!isFinite(current_f)) break;

      if (prev_f !== null && prev_prev_f !== null) {
        if (Math.sign(prev_f) !== Math.sign(current_f) && Math.sign(prev_f) !== 0) {
          const ypp = (current_f - 2*prev_f + prev_prev_f) / (h*h);
          if (Math.abs(ypp) >= 3.0) break;
        }
      }

      t = t_new; y = y_new;
      prev_prev_f = prev_f;
      prev_f = current_f;
      f0 = current_f;
      if (t >= tMin && t <= tMax && y >= yMin && y <= yMax) pts.push({t, y});
    }

    const back = [];
    t = t0; y = y0;
    try { f0 = func(t, y); } catch(e) { f0 = NaN; }
    prev_f = null; prev_prev_f = null;
    if (t >= tMin && t <= tMax && y >= yMin && y <= yMax) back.push({t, y});

    while (t > tMin - h && Math.abs(y) < 1e8) {
      let f_mid;
      try { f_mid = func(t - h/2, y - h/2 * f0); } catch(e) { f_mid = func(t - h/2, y); }
      if (isNaN(f_mid)) break;
      let t_new = t - h;
      let y_new = y - h * f_mid;

      const dot = t * 1 + y * f0;
      if (Math.abs(dot) < 1e-6 && t*t + y*y > 1e-12) {
        const r2 = t*t + y*y;
        const r2_new = t_new*t_new + y_new*y_new;
        if (r2_new > 0) {
          const scale = Math.sqrt(r2 / r2_new);
          t_new *= scale;
          y_new *= scale;
        }
      }

      let current_f;
      try { current_f = func(t_new, y_new); } catch(e) { current_f = NaN; }
      if (!isFinite(current_f)) break;

      if (prev_f !== null && prev_prev_f !== null) {
        if (Math.sign(prev_f) !== Math.sign(current_f) && Math.sign(prev_f) !== 0) {
          const ypp = (current_f - 2*prev_f + prev_prev_f) / (h*h);
          if (Math.abs(ypp) >= 3.0) break;
        }
      }

      t = t_new; y = y_new;
      prev_prev_f = prev_f;
      prev_f = current_f;
      f0 = current_f;
      if (t >= tMin && t <= tMax && y >= yMin && y <= yMax) back.push({t, y});
    }

    return [...back.reverse().slice(1), ...pts];
  }

  canvas.onclick = e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const tMin = +document.getElementById('tMin').value;
    const tMax = +document.getElementById('tMax').value;
    const yMin = +document.getElementById('yMin').value;
    const yMax = +document.getElementById('yMax').value;
    const xScale = (canvas.width-2*PADDING)/(tMax-tMin);
    const yScale = (canvas.height-2*PADDING)/(yMax-yMin);

    const t = tMin + (x-PADDING)/xScale;
    const yVal = yMin + (canvas.height-PADDING-y)/yScale;

    const pts = solve(t, yVal);
    const [r,g,b] = COLORS[colorIndex % COLORS.length];
    solutions.push({points: pts, color: `rgb(${r},${g},${b})`});
    colorIndex++;
    drawDirectionField();
  };

  window.clearSolutions = () => {
    solutions = [];
    drawDirectionField(true);
  };

  window.downloadPNG = () => {
    drawDirectionField();
    const link = document.createElement('a');
    link.download = 'direction-field.png';
    link.href = canvas.toDataURL();
    link.click();
  };

  // Initial draw
  drawDirectionField();
});
</script>
</body>
</html>