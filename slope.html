<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Direction Field Visualizer • Shelvean Kapita</title>
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"></script>
<style>
  body {background:linear-gradient(135deg,#f8f9fa,#e9ecef);min-height:100vh;}
  .main-container{max-width:1500px;margin:140px auto 0;padding:20px;display:flex;gap:30px;flex-wrap:wrap;}
  .left-panel{flex:1;min-width:320px;display:flex;flex-direction:column;gap:20px;}
  .controls{background:rgba(255,255,255,0.95);backdrop-filter:blur(10px);border-radius:15px;padding:1.8rem;box-shadow:0 8px 32px rgba(0,0,0,0.1);border:1px solid rgba(255,255,255,0.3);}
  .canvas-container{background:white;border-radius:15px;box-shadow:0 8px 32px rgba(0,0,0,0.1);position:relative;padding:20px;}
  .control-group{margin:1rem 0;display:flex;align-items:center;gap:0.8rem;flex-wrap:wrap;}
  .control-group.buttons{justify-content:center;margin-top:1.5rem;}
  label{color:#2b2d42;font-weight:500;min-width:160px;}
  input[type="text"],input[type="number"]{padding:0.7rem 1rem;border:2px solid #dee2e6;border-radius:8px;background:white;font-size:1rem;}
  input:focus{outline:none;border-color:#4cc9f0;box-shadow:0 0 0 3px rgba(76,201,240,0.2);}
  .btn-gradient{padding:0.75rem 2rem;border:none;border-radius:12px;font-weight:600;font-size:1rem;color:white;cursor:pointer;transition:all 0.3s ease;box-shadow:0 4px 15px rgba(0,0,0,0.1);text-shadow:0 1px 2px rgba(0,0,0,0.2);}
  .btn-gradient:hover{transform:translateY(-3px);box-shadow:0 10px 25px rgba(0,0,0,0.2);}
  .btn-update{background-image:linear-gradient(to right,#4ade80,#22c55e,#16a34a);}
  .btn-clear{background-image:linear-gradient(to right,#f87171,#ef4444,#dc2626);}
  .btn-download{background-image:linear-gradient(to right,#60a5fa,#3b82f6,#2563eb);}
  canvas{display:block;cursor:crosshair;border-radius:8px;box-shadow:0 4px 15px rgba(0,0,0,0.1);}
  .instruction{position:absolute;top:35px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,0.85);color:#1e293b;font-weight:600;font-size:1rem;padding:0.75rem 1.8rem;border-radius:50px;border:2px solid rgba(99,102,241,0.4);backdrop-filter:blur(12px);box-shadow:0 8px 25px rgba(0,0,0,0.12);z-index:20;animation:gentleFloat 4s ease-in-out infinite;white-space:nowrap;}
  .instruction:hover{background:rgba(255,255,255,0.95);border-color:#6366f1;transform:translateX(-50%) translateY(-5px);}
  @keyframes gentleFloat{0%,100%{transform:translateX(-50%) translateY(0);}50%{transform:translateX(-50%) translateY(-6px);}}
  
  /* About Panel Styling */
  .about-panel{ 
    background:rgba(255,255,255,0.97); 
    backdrop-filter:blur(12px); 
    border-radius:16px; 
    box-shadow:0 8px 32px rgba(0,0,0,0.12); 
    border:1px solid rgba(255,255,255,0.4); 
    overflow:hidden; 
    width:340px;
    position:sticky;
    top:140px;
    align-self:start;
    max-height:calc(100vh-160px);
    overflow:hidden;
    transition:all 0.4s ease;
  }
  .about-header {
    background-color:#4f46e5;
    color:white;
    padding:1rem 2rem;
    font-size:1.6rem;
    font-weight:700;
    text-align:center;
  }
  .about-content {
    padding:1.8rem;
    font-size:1.05rem;
    line-height:1.7;
    color:#475569;
  }
  
  /* Functions Sidebar Styling */
  .functions-sidebar{ 
    width:340px;
    background:rgba(255,255,255,0.97);
    backdrop-filter:blur(12px); 
    border-radius:16px;
    padding:1.8rem;
    box-shadow:0 8px 32px rgba(0,0,0,0.12); 
    border:1px solid rgba(255,255,255,0.4);
    position:sticky;
    top:140px;
    align-self:start; 
    max-height:calc(100vh-160px);
    overflow:hidden;
    transition:all 0.4s ease; 
  }
  .functions-content{display:none;}
  .functions-content.show{display:block;}
  .toggle-btn{ 
    width:100%;
    padding:1rem;
    background:linear-gradient(to right,#6366f1,#4f46e5); 
    color:white;
    font-weight:600;
    border:none;
    border-radius:14px;
    cursor:pointer; 
    font-size:1.1rem;
    transition:all 0.3s;
    box-shadow:0 4px 15px rgba(79,70,229,0.3); 
  }
  .toggle-btn:hover{transform:translateY(-2px);box-shadow:0 8px 20px rgba(79,70,229,0.4);}
  .func-table{width:100%;margin-top:1rem;}
  .func-table td{padding:0.7rem 0;border-bottom:1px solid #eee;}
  .func-name{font-family:'Consolas',monospace;color:#d6336c;background:#f8f9fa;padding:0.3rem 0.6rem;border-radius:4px;}
  .func-latex{text-align:center;color:#4361ee;}
  .footer{margin-top:30px;padding:15px;text-align:center;color:#6c757d;font-size:0.9rem;border-top:1px solid #dee2e6;}
</style>
</head>
<body>
<nav class="fixed top-0 left-0 w-full z-50 bg-white shadow-md">
  <div class="max-w-5xl mx-auto px-4 py-3">
    <ul class="flex justify-center space-x-6">
      <li><a href="index.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-xl">Home</a></li>
      <li><a href="teaching.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-xl">Teaching</a></li>
      <li><a href="projects.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-xl">Diff Eq</a></li>
      <li><a href="linear.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-xl">Linear Algebra</a></li>
      <li><a href="numerical.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-xl">Numerical Methods</a></li>
    </ul>
  </div>
</nav>

<div class="main-container">
  <div class="left-panel">
    <div class="controls">
      <div class="katex-instruction" id="katex-instruction"></div>
      <div class="control-group">
        <label>Differential Equation: y' =</label>
        <input type="text" id="equation" value="2*t/y" style="flex:1; min-width:180px; max-width:400px;">
      </div>
      <div class="control-group">
        <label>Horizontal (t or x):</label>
        <input type="number" id="tMin" value="-5" step="0.5"><span>to</span><input type="number" id="tMax" value="5" step="0.5">
      </div>
      <div class="control-group">
        <label>Vertical (y):</label>
        <input type="number" id="yMin" value="-5" step="0.5"><span>to</span><input type="number" id="yMax" value="5" step="0.5">
      </div>
      <div class="control-group">
        <label>Arrow Length:</label>
        <input type="number" id="arrowLength" value="12" min="5" max="50">
        <label style="margin-left:20px;">Grid Density:</label>
        <input type="number" id="arrowsPerAxis" value="20" min="10" max="50">
      </div>
      <!-- NEW Arrow Thickness Control -->
      <div class="control-group">
        <label>Arrow Thickness:</label>
        <input type="range" id="arrowThickness" min="0.5" max="3" step="0.1" value="1.2" style="flex:1;">
        <span id="thicknessValue" style="min-width:50px;text-align:right;font-weight:600;color:#4361ee;">1.2</span>
      </div>
      <div class="control-group">
        <input type="checkbox" id="variableArrows" checked style="margin-left:10px;">
        <label for="variableArrows" style="min-width:auto;">Variable length arrows</label>
      </div>
      <div class="control-group">
        <input type="checkbox" id="showGrid" checked style="margin-left:10px;">
        <label for="showGrid" style="min-width:auto;">Show grid</label>
      </div>
      <div class="control-group">
        <input type="checkbox" id="showInitialPoint" checked style="margin-left:10px;">
        <label for="showInitialPoint" style="min-width:auto;">Show initial points</label>
      </div>
      <div class="control-group buttons">
        <button onclick="drawDirectionField(true)" class="btn-gradient btn-update">Update Field</button>
        <button onclick="clearSolutions()" class="btn-gradient btn-clear">Clear Solutions</button>
      </div>
    </div>

    <div class="canvas-container">
      <div class="instruction" id="instruction">Click anywhere to draw a solution curve</div>
      <canvas id="canvas" width="900" height="600"></canvas>
      <div class="text-center mt-8">
        <button onclick="downloadPNG()" class="btn-gradient btn-download text-lg px-8 py-4">Download as PNG</button>
      </div>
    </div>

    <div class="footer">
      © 2025 Shelvean Kapita • kapita@tamu.edu<br>
      Last updated: November 30, 2025
    </div>
  </div>

  <!-- Right Column with About and Functions side by side -->
  <div style="display: flex; flex-direction: column; gap: 20px; width: 340px;">
    <!-- About Panel -->
    <div class="about-panel">
      <div class="about-header">About</div>
      <div class="about-content" id="about-content">
        This tool visualizes direction fields and solution curves for first-order differential equations of the form \( y' = f(t,y) \).<br><br>
        Solution curves are computed using an <strong>adaptive Dormand-Prince 5(4)</strong> method, which automatically adjusts step size to maintain accuracy while remaining stable near singularities.<br><br>
        Click anywhere on the graph to trace a solution curve through that point. The arrows show the slope direction at each grid point.
      </div>
    </div>

    <!-- Functions Sidebar -->
    <div class="functions-sidebar">
      <button id="toggleFunctions" class="toggle-btn">Show Supported Functions</button>
      <div id="functionsContent" class="functions-content">
        <h3 style="text-align:center;color:#4361ee;margin:1.2rem 0 0.8rem;">Supported Functions</h3>
        <table class="func-table">
          <tr><td class="func-name">sqrt(x)</td><td class="func-latex">$\sqrt{x}$</td></tr>
          <tr><td class="func-name">cbrt(x)</td><td class="func-latex">$\sqrt[3]{x}$</td></tr>
          <tr><td class="func-name">abs(x)</td><td class="func-latex">$|x|$</td></tr>
          <tr><td class="func-name">sin(x)</td><td class="func-latex">$\sin x$</td></tr>
          <tr><td class="func-name">cos(x)</td><td class="func-latex">$\cos x$</td></tr>
          <tr><td class="func-name">tan(x)</td><td class="func-latex">$\tan x$</td></tr>
          <tr><td class="func-name">asin(x)</td><td class="func-latex">$\arcsin x$</td></tr>
          <tr><td class="func-name">acos(x)</td><td class="func-latex">$\arccos x$</td></tr>
          <tr><td class="func-name">atan(x)</td><td class="func-latex">$\arctan x$</td></tr>
          <tr><td class="func-name">sinh(x)</td><td class="func-latex">$\sinh x$</td></tr>
          <tr><td class="func-name">cosh(x)</td><td class="func-latex">$\cosh x$</td></tr>
          <tr><td class="func-name">tanh(x)</td><td class="func-latex">$\tanh x$</td></tr>
          <tr><td class="func-name">exp(x)</td><td class="func-latex">$e^{x}$</td></tr>
          <tr><td class="func-name">log(x)</td><td class="func-latex">$\ln x$</td></tr>
          <tr><td class="func-name">log10(x)</td><td class="func-latex">$\log_{10} x$</td></tr>
          <tr><td class="func-name">pi</td><td class="func-latex">$\pi$</td></tr>
          <tr><td class="func-name">e</td><td class="func-latex">$e$</td></tr>
          <tr><td class="func-name">ceil(x)</td><td class="func-latex">$\lceil x \rceil$</td></tr>
          <tr><td class="func-name">floor(x)</td><td class="func-latex">$\lfloor x \rfloor$</td></tr>
          <tr><td class="func-name">round(x)</td><td class="func-latex">$\operatorname{round}(x)$</td></tr>
          <tr><td class="func-name">max(a,b)</td><td class="func-latex">$\max(a,b)$</td></tr>
          <tr><td class="func-name">min(a,b)</td><td class="func-latex">$\min(a,b)$</td></tr>
        </table>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // Initialize KaTeX rendering
  renderMathInElement(document.body, {
    delimiters: [
      {left: '$', right: '$', display: false},
      {left: '$$', right: '$$', display: true},
      {left: '\\(', right: '\\)', display: false},
      {left: '\\[', right: '\\]', display: true}
    ],
    throwOnError: false
  });

  // Render the instruction at the top of controls
  const katexInstruction = document.getElementById('katex-instruction');
  katex.render("\\text{Enter } \\dfrac{dy}{dt} = f(t,y) \\text{ or } \\dfrac{dy}{dx} = f(x,y)", katexInstruction, {throwOnError:false});

  // Update displayed thickness value
  const thicknessSlider = document.getElementById('arrowThickness');
  const thicknessValueSpan = document.getElementById('thicknessValue');
  thicknessSlider.addEventListener('input', () => {
    thicknessValueSpan.textContent = thicknessSlider.value;
  });

  // Toggle supported functions
  const toggleBtn = document.getElementById('toggleFunctions');
  const content = document.getElementById('functionsContent');
  toggleBtn.addEventListener('click', () => {
    const isShown = content.classList.toggle('show');
    toggleBtn.textContent = isShown ? "Hide Supported Functions" : "Show Supported Functions";
    // Re-render math when functions content is shown
    if (isShown) {
      renderMathInElement(content, {
        delimiters: [
          {left: '$', right: '$', display: false},
          {left: '$$', right: '$$', display: true},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ],
        throwOnError: false
      });
    }
  });

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const PADDING = 60;
  let solutions = [];
  let colorIndex = 0;
  
  // Professional color palette for scientific plots
  const COLORS = [
    [0, 0, 0],        // Black - for main/default
    [230, 50, 50],    // Red
    [0, 100, 200],    // Blue
    [0, 150, 50],     // Green
    [180, 50, 180],   // Purple
    [255, 140, 0],    // Orange
    [50, 180, 180],   // Teal
    [150, 100, 50],   // Brown
    [200, 100, 100]   // Pink
  ];

  // Enhanced function preprocessing with caret support
  function preprocess(eq) {
    eq = eq.replace(/\bx\b/g, 't');
    
    // Replace ^ with ** for exponentiation
    eq = eq.replace(/\^/g, '**');
    
    // Standard function replacements
    eq = eq
      .replace(/\b(sin|cos|tan|sinh|cosh|tanh|asin|acos|atan|exp|log|log10|sqrt|cbrt|abs|ceil|floor|round|max|min)\b/gi, 'Math.$1')
      .replace(/\bpi\b/gi, 'Math.PI')
      .replace(/(?<!Math\.)e(?!\w)/g, 'Math.E');
    
    return eq;
  }

  function getNiceStep(range) {
    const rough = range / 8; // More ticks for better readability
    const exp = Math.pow(10, Math.floor(Math.log10(rough)));
    const frac = rough / exp;
    return (frac <= 1.5 ? 1 : frac <= 3.5 ? 2 : frac <= 7 ? 5 : 10) * exp;
  }

  function drawAxisLabels(tMin, tMax, yMin, yMax, xScale, yScale) {
    ctx.font = 'bold 14px Arial'; // Bolder font for better readability
    ctx.fillStyle = '#111';
    ctx.textAlign = 'center';
    
    const tStep = getNiceStep(tMax - tMin);
    for (let t = Math.ceil(tMin/tStep)*tStep; t <= tMax + 1e-9; t += tStep) {
      const x = PADDING + (t - tMin)*xScale;
      ctx.fillText(t.toFixed(1).replace(/\.0$/, ''), x, canvas.height - 15);
    }
    
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    const yStep = getNiceStep(yMax - yMin);
    for (let y = Math.ceil(yMin/yStep)*yStep; y <= yMax + 1e-9; y += yStep) {
      const py = canvas.height - PADDING - (y - yMin)*yScale;
      ctx.fillText(y.toFixed(1).replace(/\.0$/, ''), PADDING - 12, py);
    }
    
    // Add axis labels
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('t', canvas.width - 20, canvas.height - PADDING + 10);
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.save();
    ctx.translate(20, canvas.height/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('y', 0, 0);
    ctx.restore();
  }

  window.drawDirectionField = function(clearFlag = false) {
    if (clearFlag) {
      solutions = [];
      document.getElementById('instruction').style.display = 'block';
    }
    
    // Clear with a subtle off-white background for print quality
    ctx.fillStyle = '#fafafa';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const eq = document.getElementById('equation').value.trim() || "0";
    const tMin = +document.getElementById('tMin').value;
    const tMax = +document.getElementById('tMax').value;
    const yMin = +document.getElementById('yMin').value;
    const yMax = +document.getElementById('yMax').value;
    const arrowLen = +document.getElementById('arrowLength').value || 12;
    const arrowsN = +document.getElementById('arrowsPerAxis').value || 20;
    const arrowThickness = +document.getElementById('arrowThickness').value;
    const variableArrows = document.getElementById('variableArrows').checked;
    const showGrid = document.getElementById('showGrid').checked;
    const showInitialPoint = document.getElementById('showInitialPoint').checked;

    const step = Math.min((canvas.width-2*PADDING)/arrowsN, (canvas.height-2*PADDING)/arrowsN);
    const xScale = (canvas.width-2*PADDING)/(tMax-tMin);
    const yScale = (canvas.height-2*PADDING)/(yMax-yMin);
    const aspect = yScale/xScale;

    const slopeFunc = new Function('t','y',`return ${preprocess(eq)}`);

    // Subtle grid lines
    if (showGrid) {
      ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
      ctx.lineWidth = 0.5;
      ctx.setLineDash([]);
      
      const tStep = getNiceStep(tMax - tMin);
      for (let i=Math.ceil(tMin/tStep)*tStep; i<tMax; i+=tStep) {
        const x = PADDING + (i-tMin)*xScale;
        ctx.beginPath();
        ctx.moveTo(x, PADDING);
        ctx.lineTo(x, canvas.height-PADDING);
        ctx.stroke();
      }
      
      const yStep = getNiceStep(yMax - yMin);
      for (let i=Math.ceil(yMin/yStep)*yStep; i<yMax; i+=yStep) {
        const y = canvas.height-PADDING - (i-yMin)*yScale;
        ctx.beginPath();
        ctx.moveTo(PADDING, y);
        ctx.lineTo(canvas.width-PADDING, y);
        ctx.stroke();
      }
    }

    // Arrows with variable length option
    ctx.lineWidth = arrowThickness;
    
    for (let px=PADDING+step/2; px<canvas.width-PADDING; px+=step) {
      for (let py=PADDING+step/2; py<canvas.height-PADDING; py+=step) {
        const t = tMin + (px-PADDING)/xScale;
        const y = yMin + (canvas.height-PADDING-py)/yScale;
        let m;
        try { m = slopeFunc(t,y); } catch(e) { continue; }
        if (!isFinite(m)) continue;

        const angle = Math.atan(-m*aspect);
        const slopeMagnitude = Math.sqrt(1 + m*m);
        
        let drawLength = arrowLen;
        if (variableArrows) {
          // More sophisticated scaling for better visualization
          drawLength = arrowLen / Math.sqrt(1 + slopeMagnitude/5);
          drawLength = Math.max(drawLength, 4);
        }
        
        const dx = drawLength*Math.cos(angle);
        const dy = drawLength*Math.sin(angle);
        
        // Use a subtle blue for arrows
        ctx.strokeStyle = 'rgba(30, 100, 200, 0.7)';
        ctx.beginPath();
        ctx.moveTo(px-dx/2, py-dy/2);
        ctx.lineTo(px+dx/2, py+dy/2);
        ctx.stroke();

        // Arrow heads - proportional to arrow length
        const head = Math.min(8, drawLength/2.5);
        ctx.beginPath();
        ctx.moveTo(px+dx/2, py+dy/2);
        ctx.lineTo(px+dx/2 - head*Math.cos(angle-Math.PI/6), py+dy/2 - head*Math.sin(angle-Math.PI/6));
        ctx.moveTo(px+dx/2, py+dy/2);
        ctx.lineTo(px+dx/2 - head*Math.cos(angle+Math.PI/6), py+dy/2 - head*Math.sin(angle+Math.PI/6));
        ctx.stroke();
      }
    }

    // Axes - thicker and darker for prominence
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    
    // x-axis
    if (yMin <= 0 && yMax >= 0) {
      const y0 = canvas.height - PADDING;
      ctx.beginPath();
      ctx.moveTo(PADDING, y0);
      ctx.lineTo(canvas.width-PADDING, y0);
      ctx.stroke();
    }
    // y-axis
    if (tMin <= 0 && tMax >= 0) {
      const x0 = PADDING;
      ctx.beginPath();
      ctx.moveTo(x0, PADDING);
      ctx.lineTo(x0, canvas.height-PADDING);
      ctx.stroke();
    }

    drawAxisLabels(tMin, tMax, yMin, yMax, xScale, yScale);

    // Draw solution curves with improved styling
    solutions.forEach(s => {
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 3;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.setLineDash([]);
      ctx.beginPath();
      
      let started = false;
      for (let i = 0; i < s.points.length; i++) {
        const p = s.points[i];
        const x = PADDING + (p.t - tMin) * xScale;
        const y = canvas.height - PADDING - (p.y - yMin) * yScale;
        
        if (p.t >= tMin && p.t <= tMax && p.y >= yMin && p.y <= yMax) {
          if (!started) { 
            ctx.moveTo(x, y); 
            started = true; 
          } else { 
            ctx.lineTo(x, y); 
          }
        } else if (started) {
          ctx.stroke();
          ctx.beginPath();
          started = false;
        }
      }
      if (started) ctx.stroke();
      
      // Draw initial point with better styling
      if (showInitialPoint && s.points.length > 0) {
        const first = s.points[0];
        const x = PADDING + (first.t - tMin) * xScale;
        const y = canvas.height - PADDING - (first.y - yMin) * yScale;
        
        // Draw a circle with border
        ctx.fillStyle = s.color;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      }
    });

    // Draw equation in top-right corner
    const eqText = `y' = ${eq}`;
    ctx.font = 'bold 16px Arial';
    ctx.fillStyle = '#111';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    ctx.fillText(eqText, canvas.width - 20, 20);

    document.getElementById('instruction').style.display = solutions.length === 0 ? 'block' : 'none';
  };

  // Dormand-Prince 5(4) adaptive step method for stability near singularities
  function dormandPrinceStep(t, y, h, f) {
    // Dormand-Prince coefficients
    const c2 = 1/5, c3 = 3/10, c4 = 4/5, c5 = 8/9, c6 = 1, c7 = 1;
    
    const a21 = 1/5;
    const a31 = 3/40, a32 = 9/40;
    const a41 = 44/45, a42 = -56/15, a43 = 32/9;
    const a51 = 19372/6561, a52 = -25360/2187, a53 = 64448/6561, a54 = -212/729;
    const a61 = 9017/3168, a62 = -355/33, a63 = 46732/5247, a64 = 49/176, a65 = -5103/18656;
    const a71 = 35/384, a72 = 0, a73 = 500/1113, a74 = 125/192, a75 = -2187/6784, a76 = 11/84;
    
    // b coefficients for 4th order (error estimation)
    const b41 = 5179/57600, b42 = 0, b43 = 7571/16695, b44 = 393/640, 
          b45 = -92097/339200, b46 = 187/2100, b47 = 1/40;
    
    // b coefficients for 5th order (main method)
    const b51 = 35/384, b52 = 0, b53 = 500/1113, b54 = 125/192, 
          b55 = -2187/6784, b56 = 11/84, b57 = 0;
    
    try {
      const k1 = f(t, y);
      const k2 = f(t + c2*h, y + h*(a21*k1));
      const k3 = f(t + c3*h, y + h*(a31*k1 + a32*k2));
      const k4 = f(t + c4*h, y + h*(a41*k1 + a42*k2 + a43*k3));
      const k5 = f(t + c5*h, y + h*(a51*k1 + a52*k2 + a53*k3 + a54*k4));
      const k6 = f(t + c6*h, y + h*(a61*k1 + a62*k2 + a63*k3 + a64*k4 + a65*k5));
      const k7 = f(t + c7*h, y + h*(a71*k1 + a72*k2 + a73*k3 + a74*k4 + a75*k5 + a76*k6));
      
      // 5th order estimate
      const y5 = y + h*(b51*k1 + b52*k2 + b53*k3 + b54*k4 + b55*k5 + b56*k6 + b57*k7);
      
      // 4th order estimate (for error)
      const y4 = y + h*(b41*k1 + b42*k2 + b43*k3 + b44*k4 + b45*k5 + b46*k6 + b47*k7);
      
      // Error estimate
      const error = Math.abs(y5 - y4);
      
      return {
        yNext: y5,
        error: error,
        k1: k1, k2: k2, k3: k3, k4: k4, k5: k5, k6: k6, k7: k7
      };
    } catch(e) {
      return { yNext: NaN, error: Infinity };
    }
  }

  // Robust adaptive Dormand-Prince solver
  function solve(t0, y0) {
    const tMin = +document.getElementById('tMin').value;
    const tMax = +document.getElementById('tMax').value;
    const yMin = +document.getElementById('yMin').value;
    const yMax = +document.getElementById('yMax').value;
    
    const eqString = document.getElementById('equation').value.trim();
    const f = new Function('t','y',`return ${preprocess(eqString)}`);
    
    // Test if function works at initial point
    try {
      const test = f(t0, y0);
      if (!isFinite(test)) {
        return [];
      }
    } catch(e) {
      return [];
    }
    
    const points = [];
    const MAX_STEPS = 5000;
    const TOL = 1e-6; // Tolerance for error control
    const SAFETY = 0.9; // Safety factor
    const MIN_H = 1e-10; // Minimum step size
    const MAX_H = 0.1; // Maximum step size
    
    // Helper function to integrate in one direction
    function integrate(direction) {
      const dir = direction; // 1 for forward, -1 for backward
      const localPoints = [];
      
      let t = t0;
      let y = y0;
      let h = dir * 0.001; // Initial step size
      let steps = 0;
      
      // Add initial point if in view
      if (t >= tMin && t <= tMax && y >= yMin && y <= yMax) {
        localPoints.push({t, y});
      }
      
      while (steps < MAX_STEPS/2) { // Half the steps for each direction
        // Adaptive step control
        let stepAccepted = false;
        let attempt = 0;
        let currentH = h;
        
        while (!stepAccepted && attempt < 10) {
          const result = dormandPrinceStep(t, y, currentH, f);
          
          if (!isFinite(result.yNext) || result.error === Infinity) {
            // Function evaluation failed
            break;
          }
          
          // Calculate optimal step size
          const errRatio = result.error / TOL;
          let hOpt;
          if (errRatio > 0) {
            hOpt = currentH * Math.pow(SAFETY / errRatio, 0.2);
          } else {
            hOpt = currentH * 2; // No error, increase step
          }
          
          // Bound the step size
          hOpt = Math.max(MIN_H, Math.min(MAX_H, Math.abs(hOpt))) * Math.sign(hOpt);
          
          if (errRatio <= 1) {
            // Step accepted
            t = t + currentH;
            y = result.yNext;
            h = hOpt;
            stepAccepted = true;
            
            // Add point if in view
            if (t >= tMin && t <= tMax && y >= yMin && y <= yMax) {
              localPoints.push({t, y});
            }
          } else {
            // Step rejected, try smaller step
            currentH = hOpt;
            attempt++;
          }
        }
        
        if (!stepAccepted) {
          // Could not find acceptable step
          break;
        }
        
        // Check bounds with margin
        const margin = 0.5;
        if (t < tMin - margin || t > tMax + margin || 
            y < yMin - margin || y > yMax + margin) {
          break;
        }
        
        // Check for blow-up
        if (Math.abs(y) > 1e8 || Math.abs(t) > 1e8) {
          break;
        }
        
        // Special handling for equations like y' = 2*t/y
        // If y is approaching 0, stop to avoid singularity
        if (Math.abs(y) < 1e-4) {
          // Check if we're actually crossing zero
          if (localPoints.length >= 2) {
            const lastY = localPoints[localPoints.length - 2].y;
            if (lastY * y < 0) {
              // Sign change detected - approaching singularity
              break;
            }
          }
        }
        
        // Check if we're stuck
        if (localPoints.length > 10) {
          const recent = localPoints.slice(-5);
          const tVals = recent.map(p => p.t);
          const yVals = recent.map(p => p.y);
          const tRange = Math.max(...tVals) - Math.min(...tVals);
          const yRange = Math.max(...yVals) - Math.min(...yVals);
          
          if (tRange < 1e-3 && yRange < 1e-3) {
            // Not moving
            break;
          }
        }
        
        steps++;
        
        // Stop if step size becomes too small
        if (Math.abs(h) < MIN_H * 10) {
          break;
        }
      }
      
      return localPoints;
    }
    
    // Integrate forward
    const forwardPoints = integrate(1);
    
    // Integrate backward
    const backwardPoints = integrate(-1);
    
    // Combine (backward points need to be reversed)
    const allPoints = [...backwardPoints.reverse().slice(1), ...forwardPoints];
    
    // If we have very few points, try a simpler method as fallback
    if (allPoints.length < 5 && allPoints.length > 0) {
      // Simple Euler with tiny step as last resort
      const simplePoints = [];
      const simpleStep = 0.001;
      
      // Forward
      let t = t0, y = y0;
      for (let i = 0; i < 1000; i++) {
        try {
          const slope = f(t, y);
          if (!isFinite(slope)) break;
          
          t += simpleStep;
          y += simpleStep * slope;
          
          if (t >= tMin && t <= tMax && y >= yMin && y <= yMax) {
            simplePoints.push({t, y});
          }
          
          if (Math.abs(t - t0) > 10 || Math.abs(y) > 1e6) break;
        } catch(e) {
          break;
        }
      }
      
      // Backward
      t = t0; y = y0;
      const backwardSimple = [];
      for (let i = 0; i < 1000; i++) {
        try {
          const slope = f(t, y);
          if (!isFinite(slope)) break;
          
          t -= simpleStep;
          y -= simpleStep * slope;
          
          if (t >= tMin && t <= tMax && y >= yMin && y <= yMax) {
            backwardSimple.push({t, y});
          }
          
          if (Math.abs(t - t0) > 10 || Math.abs(y) > 1e6) break;
        } catch(e) {
          break;
        }
      }
      
      return [...backwardSimple.reverse(), {t: t0, y: y0}, ...simplePoints];
    }
    
    return allPoints;
  }

  canvas.onclick = e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const tMin = +document.getElementById('tMin').value;
    const tMax = +document.getElementById('tMax').value;
    const yMin = +document.getElementById('yMin').value;
    const yMax = +document.getElementById('yMax').value;
    const xScale = (canvas.width-2*PADDING)/(tMax-tMin);
    const yScale = (canvas.height-2*PADDING)/(yMax-yMin);

    const t = tMin + (x-PADDING)/xScale;
    const yVal = yMin + (canvas.height-PADDING-y)/yScale;

    const pts = solve(t, yVal);
    if (pts.length > 0) {
      const [r,g,b] = COLORS[colorIndex % COLORS.length];
      solutions.push({points: pts, color: `rgb(${r},${g},${b})`});
      colorIndex++;
      drawDirectionField();
    }
  };

  window.clearSolutions = () => {
    solutions = [];
    drawDirectionField(true);
  };

  window.downloadPNG = () => {
    drawDirectionField();
    const link = document.createElement('a');
    link.download = 'direction-field.png';
    link.href = canvas.toDataURL();
    link.click();
  };

  // Initial draw
  drawDirectionField();
});
</script>
</body>
</html>
