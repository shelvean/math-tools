<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="description" content="Linear Phase Diagram, Phase Portrait, Spirals, Centers, Trajectories">
    <meta name="keywords" content="Linear, Direction Fields, Phase Portraits, Phase Diagrams, Phase Plane Plotter, Phase Spaces, Phase Portrait Plotter, 2D Phase Plane, Systems of Differential Equations, Spirals, Centers, Trajectories, Stable, Unstable">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LEQE004C92"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LEQE004C92');
</script>
    <title>Phase Plane Plotter (Performance Optimized)</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background-color: #f5f7fb; overflow-x: hidden; }
        .page-container { max-width: 1600px; margin: 0 auto; padding-top: 80px; }
        .main-content { display: flex; gap: 20px; flex-wrap: wrap; align-items: flex-start; }
        .container { background: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 6px 25px rgba(0, 0, 0, 0.08); flex: 1; min-width: 700px; display: flex; flex-direction: column; }
        .examples-column { width: 400px; background: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 6px 25px rgba(0, 0, 0, 0.08); height: fit-content; margin-top: 120px; }
        .example { margin-bottom: 0.8rem; cursor: pointer; padding: 12px; border-radius: 8px; transition: all 0.2s; border: 1px solid #e5e7eb; background: #f8fafc; }
        .example:hover { background-color: #f0f9ff; border-color: #3b82f6; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2); }
        .example h3 { margin-bottom: 0.5rem; color: #1e293b; font-weight: 600; font-size: 1rem; }
        .matrix-latex { font-size: 0.95rem; }
        h1 { color: #1e293b; text-align: center; margin-bottom: 1rem; font-size: 2rem; }
        /* Compact controls section */
        .controls-section { background: #f8fafc; border-radius: 10px; padding: 1.2rem; margin-bottom: 1rem; border: 1px solid #e5e7eb; }
        /* Matrix input grid - using the same style as matrix product calculator */
        .matrix-grid { display: flex; flex-direction: column; align-items: center; margin: 1rem 0; }
        .matrix-input-container { display: flex; align-items: flex-start; gap: 40px; margin-bottom: 1rem; width: 100%; justify-content: center; }
        .matrix-input-group { display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .matrix-label { font-size: 1.1rem; font-weight: 600; color: #1e293b; white-space: nowrap; }
        .matrix-table { border-collapse: collapse; }
        .matrix-table td { padding: 4px; border: 1px solid #d1d5db; }
        .matrix-input { width: 70px; height: 40px; text-align: center; border: 2px solid #d1d5db; border-radius: 6px; font-size: 1rem; font-weight: 500; transition: all 0.2s; }
        .matrix-input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
        /* Classification box - positioned to the right */
        .classification-box { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px 14px; border-radius: 8px; text-align: center; font-weight: 600; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3); line-height: 1.2; min-height: 80px; display: flex; flex-direction: column; justify-content: center; min-width: 220px; max-width: 250px; }
        .classification-type { font-size: 0.95rem; font-weight: 700; margin-bottom: 4px; }
        .classification-stability { font-size: 0.85rem; font-weight: 600; opacity: 0.95; margin-bottom: 6px; }
        .classification-details { font-size: 0.75rem; font-weight: 500; opacity: 0.9; line-height: 1.1; }
        /* Controls row */
        .controls-row { display: flex; flex-wrap: wrap; gap: 20px; justify-content: space-between; align-items: center; margin-top: 1rem; }
        .input-group { display: flex; align-items: center; gap: 8px; }
        .input-group input, .input-group select { width: 70px; padding: 0.4rem; text-align: center; border: 2px solid #d1d5db; border-radius: 6px; font-size: 0.95rem; }
        .input-group label { font-size: 0.95rem; color: #1e293b; font-weight: 500; white-space: nowrap; }
        .checkbox-group { display: flex; align-items: center; gap: 8px; white-space: nowrap; }
        .checkbox-group input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
        .checkbox-group label { font-size: 0.95rem; color: #1e293b; font-weight: 500; cursor: pointer; }
        button { background: #3b82f6; color: white; border: none; padding: 0.6rem 1.2rem; border-radius: 8px; cursor: pointer; font-size: 0.95rem; font-weight: 600; transition: all 0.3s ease; }
        button:hover { background: #2563eb; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3); }
        .button-container { display: flex; gap: 12px; justify-content: center; margin: 1rem 0; }
        button.clear { background: #ef4444; }
        button.clear:hover { background: #dc2626; box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3); }
        button.download-btn { background: #10b981; }
        button.download-btn:hover { background: #059669; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); }
        canvas { border: 1px solid #e5e7eb; border-radius: 8px; background: #fafafa; }
        .canvas-wrapper { display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .instruction { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(5px); width: calc(100% - 4rem); max-width: 40rem; padding: 0.6rem 1.5rem; border-radius: 30px; font-size: 0.85rem; font-weight: 600; color: #1e40af; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); z-index: 10; animation: float 3s ease-in-out infinite; border: 1px solid rgba(59, 130, 246, 0.3); text-align: center; }
        @keyframes float { 0%, 100% { transform: translateX(-50%) translateY(0); } 50% { transform: translateX(-50%) translateY(-3px); } }
        /* Navigation */
        nav { height: 60px; }
        nav .max-w-5xl { max-width: 1400px; }
        /* Examples grid */
        .examples-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; max-height: 700px; overflow-y: auto; padding-right: 5px; }
        /* Canvas equation box - made wider for larger canvas */
        .canvas-equation-container { width: 700px; background: white; padding: 12px 20px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); border: 2px solid #3b82f6; text-align: center; margin-bottom: 10px; }
        /* Footer - made wider for larger canvas */
        .canvas-footer { margin-top: 15px; padding-top: 10px; text-align: center; color: #6b7280; font-size: 0.85rem; width: 700px; }
        /* System equation */
        .system-equation { font-size: 1.2rem; text-align: center; margin: 0.5rem 0; min-height: 40px; }
        /* Responsive adjustments */
        @media (max-width: 1400px) { .container { min-width: 650px; } .examples-column { width: 350px; } .matrix-input-container { gap: 30px; } }
        @media (max-width: 1200px) { .page-container { padding-top: 70px; } .main-content { flex-direction: column; } .container { min-width: 100%; } .examples-column { width: 100%; margin-top: 20px; } .examples-grid { grid-template-columns: repeat(4, 1fr); max-height: none; } .canvas-equation-container, .canvas-footer { width: 100%; max-width: 700px; } .matrix-input-container { flex-direction: column; align-items: center; gap: 20px; } .classification-box { min-width: 300px; max-width: 400px; } }
        @media (max-width: 768px) { body { padding: 10px; } .container { padding: 1rem; } .matrix-input { width: 55px; height: 35px; font-size: 0.9rem; } .controls-row { flex-direction: column; align-items: flex-start; gap: 10px; } .input-group, .checkbox-group { width: 100%; justify-content: space-between; } .instruction { font-size: 0.75rem; padding: 0.5rem 1rem; width: 90%; } .examples-grid { grid-template-columns: repeat(2, 1fr); } .canvas-equation-container, .canvas-footer { width: 100%; max-width: 500px; } .matrix-input-container { gap: 15px; } .classification-box { min-width: 250px; max-width: 300px; } }
        @media (max-width: 480px) { .examples-grid { grid-template-columns: 1fr; } .matrix-input-container { flex-direction: column; gap: 15px; } .matrix-input-group { width: 100%; } .classification-box { width: 100%; max-width: none; } }
    </style>
</head>
<body>
    <div class="nav-container w-full bg-white shadow-md fixed top-0 left-0 z-50">
        <nav class="max-w-5xl mx-auto px-4 py-3">
            <ul class="flex justify-center space-x-4 sm:space-x-6">
                <li><a href="index.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Home</a></li>
                <li><a href="teaching.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Teaching</a></li>
                <li><a href="projects.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Diff Eq</a></li>
                <li><a href="linear.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Linear Algebra</a></li>
                <li><a href="numerical.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Numerical Methods</a></li>
            </ul>
        </nav>
    </div>
    <div class="page-container">
        <div class="main-content">
            <div class="container">
                <h1>Phase Portraits of Linear Systems</h1>
                <div class="controls-section">
                    <!-- System equation -->
                    <div class="system-equation" id="equation-display"></div>
                    <!-- Matrix input with classification to the right -->
                    <div class="matrix-grid">
                        <div class="matrix-input-container">
                            <div class="matrix-input-group">
                                <span class="matrix-label">Matrix of Coefficients:</span>
                                <table class="matrix-table">
                                    <tr>
                                        <td><input type="text" id="a" class="matrix-input" placeholder="a" value="-1"></td>
                                        <td><input type="text" id="b" class="matrix-input" placeholder="b" value="2"></td>
                                    </tr>
                                    <tr>
                                        <td><input type="text" id="c" class="matrix-input" placeholder="c" value="-2"></td>
                                        <td><input type="text" id="d" class="matrix-input" placeholder="d" value="-1"></td>
                                    </tr>
                                </table>
                            </div>
                            <!-- Classification info - positioned to the right -->
                            <div class="classification-box" id="classification-info">
                                <div class="classification-type">Enter matrix coefficients</div>
                                <div class="classification-stability">to see classification</div>
                                <div class="classification-details">Based on eigenvalues and eigenvectors</div>
                            </div>
                        </div>
                        <div class="controls-row">
                            <div class="input-group">
                                <label for="arrow-count">Arrows per axis:</label>
                                <input type="number" id="arrow-count" value="25" min="10" max="40">
                            </div>
                            <div class="input-group">
                                <label for="arrow-scale">Arrow Scale:</label>
                                <input type="number" id="arrow-scale" value="0.6" min="0.1" max="2" step="0.1">
                            </div>
                            <!-- Field Color Dropdown -->
                            <div class="input-group">
                                <label for="field-color">Field Color:</label>
                                <select id="field-color">
                                    <option value="#2563eb">Blue</option>
                                    <option value="#dc2626">Red</option>
                                    <option value="#16a34a">Green</option>
                                    <option value="#7c3aed">Purple</option>
                                    <option value="#ea580c">Orange</option>
                                    <option value="#000000">Black</option>
                                </select>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="showInitialPoint" checked>
                                <label for="showInitialPoint">Show initial point</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="showGrid" checked>
                                <label for="showGrid">Show grid</label>
                            </div>
                        </div>
                        <div class="button-container">
                            <button onclick="clearAndDrawPhasePortrait()">Generate Phase Portrait</button>
                            <button class="clear" onclick="clearUserPoints()">Clear Trajectories</button>
                        </div>
                    </div>
                </div>
                <div class="canvas-wrapper">
                    <!-- Equation container above the canvas -->
                    <div class="canvas-equation-container" id="canvas-equation"></div>
                    <!-- Canvas with instruction - increased to 700x700 (1:1 aspect ratio) -->
                    <div style="position: relative; width: 700px; height: 700px;">
                        <canvas id="canvas" width="700" height="700"></canvas>
                        <div id="instruction" class="instruction">✨ Click anywhere on the graph to add trajectories</div>
                    </div>
                    <!-- Footer with download button -->
                    <div class="canvas-footer">
                        <button class="download-btn" onclick="downloadImage()">Download Image</button>
                        <p style="margin-top: 15px;">© 2025 Shelvean Kapita &bull; kapita@tamu.edu &bull; All code released under the MIT License. Optimized January 16, 2026 </p>
                    </div>
                </div>
            </div>
            <div class="examples-column">
                <h2 class="text-2xl font-bold mb-4">Example Matrices (click)</h2>
                <div class="examples-grid">
                    <!-- Basic classifications -->
                    <div class="example" data-a="-2" data-b="0" data-c="0" data-d="-3">
                        <h3>Stable Node </h3>
                        <span class="matrix-latex">\begin{pmatrix} -2 & 0 \\ 0 & -3 \end{pmatrix}</span>
                    </div>
                    <div class="example" data-a="2" data-b="0" data-c="0" data-d="3">
                        <h3>Unstable Node </h3>
                        <span class="matrix-latex">\begin{pmatrix} 2 & 0 \\ 0 & 3 \end{pmatrix}</span>
                    </div>
                    <div class="example" data-a="-2" data-b="1" data-c="1" data-d="-3">
                        <h3>Stable Node </h3>
                        <span class="matrix-latex">\begin{pmatrix} -2 & 1 \\ 1 & -3 \end{pmatrix}</span>
                    </div>
                    <div class="example" data-a="1" data-b="3" data-c="3" data-d="-1">
                        <h3>Saddle Point</h3>
                        <span class="matrix-latex">\begin{pmatrix} 1 & 3 \\ 3 & -1 \end{pmatrix}</span>
                    </div>
                    <!-- Spiral classifications -->
                    <div class="example" data-a="-1" data-b="2" data-c="-2" data-d="-1">
                        <h3>Stable Spiral</h3>
                        <span class="matrix-latex">\begin{pmatrix} -1 & 2 \\ -2 & -1 \end{pmatrix}</span>
                    </div>
                    <div class="example" data-a="1" data-b="2" data-c="-2" data-d="1">
                        <h3>Unstable Spiral</h3>
                        <span class="matrix-latex">\begin{pmatrix} 1 & 2 \\ -2 & 1 \end{pmatrix}</span>
                    </div>
                    <!-- Centers with different eccentricities -->
                    <div class="example" data-a="0" data-b="1" data-c="-1" data-d="0">
                        <h3>Center (Circular)</h3>
                        <span class="matrix-latex">\begin{pmatrix} 0 & 1 \\ -1 & 0 \end{pmatrix}</span>
                    </div>
                    <div class="example" data-a="0" data-b="2" data-c="-1" data-d="0">
                        <h3>Center (Elliptical)</h3>
                        <span class="matrix-latex">\begin{pmatrix} 0 & 2 \\ -1 & 0 \end{pmatrix}</span>
                    </div>
                    <div class="example" data-a="0" data-b="1" data-c="-4" data-d="0">
                        <h3>Center (More Elliptical)</h3>
                        <span class="matrix-latex">\begin{pmatrix} 0 & 1 \\ -4 & 0 \end{pmatrix}</span>
                    </div>
                    <div class="example" data-a="1" data-b="2" data-c="-2" data-d="-1">
                        <h3>Center (Rotated)</h3>
                        <span class="matrix-latex">\begin{pmatrix} 1 & 2 \\ -2 & -1 \end{pmatrix}</span>
                    </div>
                    <!-- Degenerate cases -->
                    <div class="example" data-a="-1" data-b="0" data-c="0" data-d="-1">
                        <h3>Stable Star Node</h3>
                        <span class="matrix-latex">\begin{pmatrix} -1 & 0 \\ 0 & -1 \end{pmatrix}</span>
                    </div>
                    <div class="example" data-a="1" data-b="0" data-c="0" data-d="1">
                        <h3>Unstable Star Node</h3>
                        <span class="matrix-latex">\begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix}</span>
                    </div>
                    <!-- Line of equilibria -->
                    <div class="example" data-a="0" data-b="0" data-c="0" data-d="-1">
                        <h3>Line of Equilibria</h3>
                        <span class="matrix-latex">\begin{pmatrix} 0 & 0 \\ 0 & -1 \end{pmatrix}</span>
                    </div>
                    <!-- Non-diagonalizable cases -->
                    <div class="example" data-a="1" data-b="1" data-c="0" data-d="1">
                        <h3>Defective Node</h3>
                        <span class="matrix-latex">\begin{pmatrix} 1 & 1 \\ 0 & 1 \end{pmatrix}</span>
                    </div>
                    <!-- Borderline cases -->
                    <div class="example" data-a="0" data-b="1" data-c="0" data-d="0">
                        <h3>Zero Eigenvalue</h3>
                        <span class="matrix-latex">\begin{pmatrix} 0 & 1 \\ 0 & 0 \end{pmatrix}</span>
                    </div>
                    <!-- Mixed stability -->
                    <div class="example" data-a="-2" data-b="0" data-c="0" data-d="1">
                        <h3>Saddle (Diagonal)</h3>
                        <span class="matrix-latex">\begin{pmatrix} -2 & 0 \\ 0 & 1 \end{pmatrix}</span>
                    </div>
                    <!-- Degenerate spiral (critically damped) -->
                    <div class="example" data-a="-1" data-b="1" data-c="-1" data-d="-1">
                        <h3>Stable Spiral</h3>
                        <span class="matrix-latex">\begin{pmatrix} -1 & 1 \\ -1 & -1 \end{pmatrix}</span>
                    </div>
                    <!-- Repeated eigenvalues with nontrivial Jordan block -->
                    <div class="example" data-a="2" data-b="1" data-c="0" data-d="2">
                        <h3>Degenerate (Improper) Node</h3>
                        <span class="matrix-latex">\begin{pmatrix} 2 & 1 \\ 0 & 2 \end{pmatrix}</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script>
        // ========================================
        // PERFORMANCE OPTIMIZATION: Utility Functions
        // ========================================

        /**
         * Debounce function - prevents function from being called too frequently
         * Waits for 'delay' ms of inactivity before executing the function
         */
        function debounce(func, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func.apply(this, args), delay);
            };
        }

        /**
         * Throttle function - limits function execution to once per 'limit' ms
         * Ensures function runs at most once per time period
         */
        function throttle(func, limit) {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }

        let userPoints = [];
        let trajectories = [];

        document.addEventListener('DOMContentLoaded', () => {
            // Render main equation (OPTIMIZATION: Render specific element only)
            katex.render('\\begin{cases}\n \\dot{x} = ax + by \\\\\n \\dot{y} = cx + dy\n \\end{cases}', document.getElementById('equation-display'), { throwOnError: false, displayMode: true } );

            // Set up example click handlers
            document.querySelectorAll('.example').forEach(example => {
                example.addEventListener('click', () => {
                    // Clear existing trajectories
                    userPoints = [];
                    trajectories = [];
                    document.getElementById('a').value = example.dataset.a;
                    document.getElementById('b').value = example.dataset.b;
                    document.getElementById('c').value = example.dataset.c;
                    document.getElementById('d').value = example.dataset.d;
                    // Hide instruction and draw
                    document.getElementById('instruction').style.display = 'block';
                    drawPhasePortrait();
                });
                // Render matrix LaTeX for each example (OPTIMIZATION: Render specific elements)
                katex.render(
                    example.querySelector('.matrix-latex').textContent,
                    example.querySelector('.matrix-latex'),
                    { throwOnError: false, displayMode: true }
                );
            });

            // Canvas click handler
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('click', event => {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                // Check if click is within the graph area
                const PADDING = 70;
                if (x < PADDING || x > canvas.width - PADDING || y < PADDING || y > canvas.height - PADDING) return;
                const tMin = -5, tMax = 5, yMin = -5, yMax = 5;
                const drawWidth = canvas.width - 2 * PADDING;
                const drawHeight = canvas.height - 2 * PADDING;
                const xScale = drawWidth / (tMax - tMin);
                const yScale = drawHeight / (yMax - yMin);
                const t = tMin + (x - PADDING) / xScale;
                const yVal = yMin + (canvas.height - PADDING - y) / yScale;
                userPoints.push({ x: t, y: yVal });
                // Compute trajectory immediately
                computeTrajectoryAsync(t, yVal).then(trajPoints => {
                    trajectories.push(trajPoints);
                    drawPhasePortrait();
                });
                document.getElementById('instruction').style.display = 'none';
            });

            // ========================================
            // OPTIMIZATION: Debounced input handlers
            // ========================================
            // Create debounced redraw function (waits 300ms after last input)
            const debouncedMatrixRedraw = debounce(() => {
                // Clear trajectories when matrix changes (system has changed)
                userPoints = [];
                trajectories = [];
                drawPhasePortrait();
            }, 300);

            // Add debounced listeners to matrix inputs
            ['a', 'b', 'c', 'd'].forEach(id => {
                document.getElementById(id).addEventListener('input', debouncedMatrixRedraw);
            });

            // OPTIMIZATION: Field color change doesn't need to clear trajectories
            // Just redraw with new color
            document.getElementById('field-color').addEventListener('change', () => {
                drawPhasePortrait(); // Redraw without clearing trajectories
            });

            // Arrow count and scale changes - throttled redraw
            const throttledRedraw = throttle(drawPhasePortrait, 100);
            document.getElementById('arrow-count').addEventListener('input', throttledRedraw);
            document.getElementById('arrow-scale').addEventListener('input', throttledRedraw);

            // Checkboxes - immediate redraw (no debounce needed)
            document.getElementById('showInitialPoint').addEventListener('change', drawPhasePortrait);
            document.getElementById('showGrid').addEventListener('change', drawPhasePortrait);

            // Initial draw
            drawPhasePortrait();
        });

        function clearUserPoints() {
            userPoints = [];
            trajectories = [];
            drawPhasePortrait();
            document.getElementById('instruction').style.display = 'block';
        }

        // New function to clear trajectories and redraw phase portrait
        function clearAndDrawPhasePortrait() {
            userPoints = [];
            trajectories = [];
            document.getElementById('instruction').style.display = 'block';
            drawPhasePortrait();
        }

        // Function to classify the equilibrium
        function classifyEquilibrium(a, b, c, d) {
            const trace = a + d;
            const det = a * d - b * c;
            const discriminant = trace * trace - 4 * det;
            // Check for zero matrix first
            if (a === 0 && b === 0 && c === 0 && d === 0) {
                return { type: 'Plane of Equilibria', stability: 'Neutrally Stable', description: 'Every point is an equilibrium' };
            }
            // Check for line of equilibria (determinant = 0 but not all zeros)
            if (Math.abs(det) < 1e-10) {
                if (Math.abs(a) < 1e-10 && Math.abs(b) < 1e-10 && Math.abs(c) < 1e-10 && Math.abs(d) < 1e-10) {
                    // Already handled above
                } else {
                    return { type: 'Line of Equilibria', stability: 'Mixed', description: 'Continuous line of equilibrium points' };
                }
            }
            // Check eigenvalues
            if (discriminant > 0) {
                // Real distinct eigenvalues
                const lambda1 = (trace + Math.sqrt(discriminant)) / 2;
                const lambda2 = (trace - Math.sqrt(discriminant)) / 2;
                if (lambda1 * lambda2 < 0) {
                    return { type: 'Saddle Point', stability: 'Unstable', description: 'One stable and one unstable direction' };
                } else if (lambda1 < 0 && lambda2 < 0) {
                    if (Math.abs(lambda1 - lambda2) < 1e-10) {
                        return { type: 'Star Node', stability: 'Stable', description: 'Repeated negative eigenvalues' };
                    } else if (b === 0 && c === 0) {
                        return { type: 'Proper Node', stability: 'Stable', description: 'Diagonal matrix with negative eigenvalues' };
                    } else {
                        return { type: 'Improper Node', stability: 'Stable', description: 'Real negative eigenvalues, not diagonal' };
                    }
                } else if (lambda1 > 0 && lambda2 > 0) {
                    if (Math.abs(lambda1 - lambda2) < 1e-10) {
                        return { type: 'Star Node', stability: 'Unstable', description: 'Repeated positive eigenvalues' };
                    } else if (b === 0 && c === 0) {
                        return { type: 'Proper Node', stability: 'Unstable', description: 'Diagonal matrix with positive eigenvalues' };
                    } else {
                        return { type: 'Improper Node', stability: 'Unstable', description: 'Real positive eigenvalues, not diagonal' };
                    }
                }
            } else if (discriminant < 0) {
                // Complex eigenvalues
                const realPart = trace / 2;
                if (Math.abs(realPart) < 1e-10) {
                    return { type: 'Center', stability: 'Neutrally Stable', description: 'Purely imaginary eigenvalues' };
                } else if (realPart < 0) {
                    return { type: 'Stable Spiral', stability: 'Stable', description: 'Complex eigenvalues with negative real part' };
                } else {
                    return { type: 'Unstable Spiral', stability: 'Unstable', description: 'Complex eigenvalues with positive real part' };
                }
            } else {
                // Repeated eigenvalues (discriminant = 0)
                const lambda = trace / 2;
                // Check if matrix is diagonalizable
                const isDiagonal = (b === 0 && c === 0) || (Math.abs(a - d) < 1e-10 && Math.abs(b) < 1e-10 && Math.abs(c) < 1e-10);
                if (isDiagonal) {
                    if (lambda < 0) {
                        return { type: 'Star Node', stability: 'Stable', description: 'Repeated negative eigenvalues, diagonalizable' };
                    } else if (lambda > 0) {
                        return { type: 'Star Node', stability: 'Unstable', description: 'Repeated positive eigenvalues, diagonalizable' };
                    } else {
                        return { type: 'Line of Equilibria', stability: 'Neutrally Stable', description: 'Zero eigenvalue repeated' };
                    }
                } else {
                    // Non-diagonalizable case (defective matrix)
                    if (lambda < 0) {
                        return { type: 'Defective Node', stability: 'Stable', description: 'Repeated negative eigenvalues, non-diagonalizable' };
                    } else if (lambda > 0) {
                        return { type: 'Defective Node', stability: 'Unstable', description: 'Repeated positive eigenvalues, non-diagonalizable' };
                    } else {
                        return { type: 'Nilpotent', stability: 'Unstable', description: 'Zero eigenvalue, non-diagonalizable' };
                    }
                }
            }
        }

        // Simple 4th-order Runge-Kutta
        function rk4Step(x, y, a, b, c, d, h) {
            const k1x = a * x + b * y;
            const k1y = c * x + d * y;
            const k2x = a * (x + h/2 * k1x) + b * (y + h/2 * k1y);
            const k2y = c * (x + h/2 * k1x) + d * (y + h/2 * k1y);
            const k3x = a * (x + h/2 * k2x) + b * (y + h/2 * k2y);
            const k3y = c * (x + h/2 * k2x) + d * (y + h/2 * k2y);
            const k4x = a * (x + h * k3x) + b * (y + h * k3y);
            const k4y = c * (x + h * k3x) + d * (y + h * k3y);
            return {
                x: x + h/6 * (k1x + 2*k2x + 2*k3x + k4x),
                y: y + h/6 * (k1y + 2*k2y + 2*k3y + k4y)
            };
        }

        // Helper function to check if point is within visible bounds
        function isInBounds(x, y, tMin, tMax, yMin, yMax) {
            return x >= tMin && x <= tMax && y >= yMin && y <= yMax;
        }

        // Calculate eigenvalues for centers
        function calculateEigenvalues(a, b, c, d) {
            const trace = a + d;
            const det = a * d - b * c;
            const discriminant = trace * trace - 4 * det;
            if (discriminant < 0) {
                const realPart = trace / 2;
                const imagPart = Math.sqrt(-discriminant) / 2;
                return { real: realPart, imag: imagPart };
            } else if (discriminant === 0) {
                const lambda = trace / 2;
                return { real: lambda, imag: 0, repeated: true };
            } else {
                const lambda1 = (trace + Math.sqrt(discriminant)) / 2;
                const lambda2 = (trace - Math.sqrt(discriminant)) / 2;
                return { lambda1, lambda2, real: true };
            }
        }

        // Analytical solution for centers (ellipses, not circles)
        function computeCenterTrajectory(x0, y0, a, b, c, d, tMin, tMax, yMin, yMax, xOffset, xScale, yScale) {
            const trajPoints = [];
            const points = 400; // More points for smoother ellipses
            const det = a * d - b * c;
            const eigenvalues = calculateEigenvalues(a, b, c, d);
            if (Math.abs(eigenvalues.real) < 1e-10 && eigenvalues.imag > 0) {
                let x = x0, y = y0;
                const h = 0.01; // Very small step for accuracy
                // Forward integration
                for (let i = 0; i < points; i++) {
                    if (!isInBounds(x, y, tMin, tMax, yMin, yMax)) break;
                    const canvasX = xOffset + (x - tMin) * xScale;
                    const canvasY = 700 - xOffset - (y - yMin) * yScale;
                    if (canvasX >= 70 && canvasX <= 700 - 70 && canvasY >= 70 && canvasY <= 700 - 70) {
                        trajPoints.push({ x: canvasX, y: canvasY });
                    } else break;
                    const next = rk4Step(x, y, a, b, c, d, h);
                    x = next.x;
                    y = next.y;
                }
                // Backward integration
                x = x0; y = y0;
                const backwardPoints = [];
                for (let i = 0; i < points; i++) {
                    const next = rk4Step(x, y, a, b, c, d, -h);
                    x = next.x;
                    y = next.y;
                    if (!isInBounds(x, y, tMin, tMax, yMin, yMax)) break;
                    const canvasX = xOffset + (x - tMin) * xScale;
                    const canvasY = 700 - xOffset - (y - yMin) * yScale;
                    if (canvasX >= 70 && canvasX <= 700 - 70 && canvasY >= 70 && canvasY <= 700 - 70) {
                        backwardPoints.unshift({ x: canvasX, y: canvasY });
                    } else break;
                }
                return [...backwardPoints, ...trajPoints];
            }
            return trajPoints;
        }

        // ========================================
        // OPTIMIZATION: Reduced MAX_STEPS from 3000 to 1000
        // Added early termination for equilibria
        // ========================================
        async function computeTrajectoryAsync(x0, y0) {
            const a = parseFloat(document.getElementById('a').value) || 0;
            const b = parseFloat(document.getElementById('b').value) || 0;
            const c = parseFloat(document.getElementById('c').value) || 0;
            const d = parseFloat(document.getElementById('d').value) || 0;
            const trajPoints = [];
            const tMin = -5, tMax = 5, yMin = -5, yMax = 5;
            const PADDING = 70;
            const drawWidth = 700 - 2 * PADDING;
            const drawHeight = 700 - 2 * PADDING;
            const scale = Math.min(drawWidth, drawHeight) / (tMax - tMin);
            const xScale = scale;
            const yScale = scale;
            const xOffset = (700 - (tMax - tMin) * xScale) / 2;

            // Classify system for adaptive step size
            const classification = classifyEquilibrium(a, b, c, d);
            const isCenter = classification.type === 'Center';
            const isSpiral = classification.type.includes('Spiral');

            // For centers, use proper elliptical trajectories
            if (isCenter) {
                return computeCenterTrajectory(x0, y0, a, b, c, d, tMin, tMax, yMin, yMax, xOffset, xScale, yScale);
            }

            // OPTIMIZATION: Reduced from 3000 to 1000 steps
            const MAX_STEPS = 1000;

            // Forward integration
            let x = x0, y = y0;
            let h = isSpiral ? 0.015 : 0.05;

            if (isInBounds(x, y, tMin, tMax, yMin, yMax)) {
                const canvasX = xOffset + (x - tMin) * xScale;
                const canvasY = 700 - xOffset - (y - yMin) * yScale;
                trajPoints.push({ x: canvasX, y: canvasY });
            }

            for (let i = 0; i < MAX_STEPS; i++) {
                // Adaptive step size
                const dx = a * x + b * y;
                const dy = c * x + d * y;
                const speed = Math.sqrt(dx * dx + dy * dy);

                if (isSpiral) {
                    h = 0.015;
                } else if (speed > 0.1) {
                    h = Math.min(0.3 / speed, 0.1);
                } else {
                    h = 0.05;
                }

                // Take step
                const next = rk4Step(x, y, a, b, c, d, h);
                x = next.x;
                y = next.y;

                // Stop if trajectory goes to infinity
                if (Math.abs(x) > 100 || Math.abs(y) > 100) break;

                // STRICT bounds checking - stop immediately if outside
                if (!isInBounds(x, y, tMin, tMax, yMin, yMax)) break;

                const canvasX = xOffset + (x - tMin) * xScale;
                const canvasY = 700 - xOffset - (y - yMin) * yScale;

                if (canvasX >= PADDING && canvasX <= 700 - PADDING && canvasY >= PADDING && canvasY <= 700 - PADDING) {
                    trajPoints.push({ x: canvasX, y: canvasY });
                } else break;

                // Stop if we have enough points
                if (trajPoints.length > 1500) break;

                // OPTIMIZATION: Early termination for near-equilibrium
                if (trajPoints.length > 10 && speed < 1e-4) break;
            }

            // Backward integration
            x = x0; y = y0;
            const backwardPoints = [];
            h = isSpiral ? -0.015 : -0.05;

            for (let i = 0; i < MAX_STEPS; i++) {
                const dx = a * x + b * y;
                const dy = c * x + d * y;
                const speed = Math.sqrt(dx * dx + dy * dy);

                if (isSpiral) {
                    h = -0.015;
                } else if (speed > 0.1) {
                    h = -Math.min(0.3 / speed, 0.1);
                } else {
                    h = -0.05;
                }

                const next = rk4Step(x, y, a, b, c, d, h);
                x = next.x;
                y = next.y;

                if (Math.abs(x) > 100 || Math.abs(y) > 100) break;
                if (!isInBounds(x, y, tMin, tMax, yMin, yMax)) break;

                const canvasX = xOffset + (x - tMin) * xScale;
                const canvasY = 700 - xOffset - (y - yMin) * yScale;

                if (canvasX >= PADDING && canvasX <= 700 - PADDING && canvasY >= PADDING && canvasY <= 700 - PADDING) {
                    backwardPoints.unshift({ x: canvasX, y: canvasY });
                } else break;

                if (backwardPoints.length > 750) break;

                // OPTIMIZATION: Early termination for near-equilibrium
                if (backwardPoints.length > 10 && speed < 1e-4) break;
            }

            return [...backwardPoints, ...trajPoints];
        }

        function getNiceStep(range) {
            const rough = range / 8;
            const exp = Math.pow(10, Math.floor(Math.log10(rough)));
            const frac = rough / exp;
            return (frac <= 1.5 ? 1 : frac <= 3.5 ? 2 : frac <= 7 ? 5 : 10) * exp;
        }

        function drawAxisLabels(ctx, tMin, tMax, yMin, yMax, xScale, yScale, PADDING, canvas) {
            ctx.font = 'bold 12px Arial';
            ctx.fillStyle = '#111';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            const tStep = getNiceStep(tMax - tMin);
            for (let t = Math.ceil(tMin/tStep)*tStep; t <= tMax + 1e-9; t += tStep) {
                const x = PADDING + (t - tMin) * xScale;
                ctx.fillText(t.toFixed(1).replace(/\.0$/, ''), x, canvas.height - PADDING + 8);
            }
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            const yStep = getNiceStep(yMax - yMin);
            for (let y = Math.ceil(yMin/yStep)*yStep; y <= yMax + 1e-9; y += yStep) {
                const py = canvas.height - PADDING - (y - yMin) * yScale;
                ctx.fillText(y.toFixed(1).replace(/\.0$/, ''), PADDING - 8, py);
            }
            // Add axis labels
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText('x', canvas.width - 15, canvas.height - PADDING + 10);
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('y', 0, 0);
            ctx.restore();
        }

        function renderEquationToCanvas(a, b, c, d) {
            const eqContainer = document.getElementById('canvas-equation');
            eqContainer.innerHTML = '';
            // Format coefficients
            const formatCoeff = (coeff) => {
                if (coeff === 0) return '0';
                if (coeff === 1) return '';
                if (coeff === -1) return '-';
                const rounded = Math.round(coeff * 100) / 100;
                return rounded.toString();
            };
            const aStr = formatCoeff(a);
            const bStr = formatCoeff(b);
            const cStr = formatCoeff(c);
            const dStr = formatCoeff(d);
            const bSign = b >= 0 ? '+' : '';
            const dSign = d >= 0 ? '+' : '';
            const eqString = `\\begin{cases} \\dot{x} = ${aStr === '' ? '' : aStr}${aStr === '' && a === -1 ? '-' : ''}x ${bSign}${bStr}y \\\\ \\dot{y} = ${cStr === '' ? '' : cStr}${cStr === '' && c === -1 ? '-' : ''}x ${dSign}${dStr}y \\end{cases}`;
            // OPTIMIZATION: Render to specific element
            katex.render(eqString, eqContainer, { throwOnError: false, displayMode: true, fontSize: 18 });
        }

        function drawPhasePortrait() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            // Clear with background
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Get matrix coefficients and field color
            const a = parseFloat(document.getElementById('a').value) || 0;
            const b = parseFloat(document.getElementById('b').value) || 0;
            const c = parseFloat(document.getElementById('c').value) || 0;
            const d = parseFloat(document.getElementById('d').value) || 0;
            const arrowCount = parseInt(document.getElementById('arrow-count').value) || 18;
            const arrowScale = parseFloat(document.getElementById('arrow-scale').value) || 0.6;
            const fieldColor = document.getElementById('field-color').value || '#2563eb';
            const showInitialPoint = document.getElementById('showInitialPoint').checked;
            const showGrid = document.getElementById('showGrid').checked;

            // Update classification
            const classification = classifyEquilibrium(a, b, c, d);
            const infoBox = document.getElementById('classification-info');
            infoBox.innerHTML = `
                <div class="classification-type">${classification.type}</div>
                <div class="classification-stability">${classification.stability}</div>
                <div class="classification-details">${classification.description}</div>
            `;

            // Render equation at top using KaTeX (separate from canvas)
            renderEquationToCanvas(a, b, c, d);

            const tMin = -5, tMax = 5, yMin = -5, yMax = 5;
            const PADDING = 70;
            const drawWidth = canvas.width - 2 * PADDING;
            const drawHeight = canvas.height - 2 * PADDING;
            const scale = Math.min(drawWidth, drawHeight) / (tMax - tMin);
            const xScale = scale;
            const yScale = scale;
            const xOffset = (canvas.width - (tMax - tMin) * xScale) / 2;
            const yOffset = (canvas.height - (yMax - yMin) * yScale) / 2;
            const step = Math.min(drawWidth / arrowCount, drawHeight / arrowCount);

            // Draw grid if enabled
            if (showGrid) {
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                ctx.lineWidth = 0.5;
                ctx.setLineDash([]);
                const tStep = getNiceStep(tMax - tMin);
                for (let i = Math.ceil(tMin/tStep)*tStep; i < tMax; i += tStep) {
                    const x = xOffset + (i - tMin) * xScale;
                    ctx.beginPath();
                    ctx.moveTo(x, yOffset);
                    ctx.lineTo(x, canvas.height - yOffset);
                    ctx.stroke();
                }
                const yStep = getNiceStep(yMax - yMin);
                for (let i = Math.ceil(yMin/yStep)*yStep; i < tMax; i += yStep) {
                    const y = canvas.height - yOffset - (i - yMin) * yScale;
                    ctx.beginPath();
                    ctx.moveTo(xOffset, y);
                    ctx.lineTo(canvas.width - xOffset, y);
                    ctx.stroke();
                }
            }

            // ========================================
            // OPTIMIZATION: Batched canvas path operations
            // ========================================
            ctx.lineWidth = 0.75;
            ctx.strokeStyle = fieldColor;

            const minX = xOffset;
            const maxX = canvas.width - xOffset;
            const minY = yOffset;
            const maxY = canvas.height - yOffset;

            // OPTIMIZATION: Collect all arrow shafts in one path
            ctx.beginPath();
            const arrowData = []; // Store arrow endpoints for later arrowhead drawing

            for (let px = minX + step/2; px < maxX; px += step) {
                for (let py = minY + step/2; py < maxY; py += step) {
                    const t = tMin + (px - xOffset) / xScale;
                    const y_val = yMin + (canvas.height - yOffset - py) / yScale;
                    const dx = a * t + b * y_val;
                    const dy = c * t + d * y_val;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len === 0) continue;

                    const deltaCanvasX = dx * xScale;
                    const deltaCanvasY = -dy * yScale;
                    const lenCanvas = Math.sqrt(deltaCanvasX * deltaCanvasX + deltaCanvasY * deltaCanvasY);
                    const normDx = deltaCanvasX / lenCanvas;
                    const normDy = deltaCanvasY / lenCanvas;
                    let drawLength = 20 * arrowScale;
                    drawLength = drawLength * Math.min(1, 5 / len);
                    drawLength = Math.max(drawLength, 5);

                    const startX = px - (normDx * drawLength) / 2;
                    const startY = py - (normDy * drawLength) / 2;
                    const endX = px + (normDx * drawLength) / 2;
                    const endY = py + (normDy * drawLength) / 2;

                    // Add to batched path
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);

                    // Store arrowhead data
                    arrowData.push({
                        endX: endX,
                        endY: endY,
                        normDx: normDx,
                        normDy: normDy,
                        drawLength: drawLength
                    });
                }
            }
            // OPTIMIZATION: Single stroke call for all arrow shafts
            ctx.stroke();

            // OPTIMIZATION: Batch arrowheads
            ctx.fillStyle = fieldColor;
            arrowData.forEach(arrow => {
                const headSize = Math.min(12, arrow.drawLength / 2.5 + 3);
                const angle = Math.atan2(arrow.normDy, arrow.normDx);
                ctx.beginPath();
                ctx.moveTo(arrow.endX, arrow.endY);
                ctx.lineTo(arrow.endX - headSize * Math.cos(angle - Math.PI / 6),
                          arrow.endY - headSize * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(arrow.endX - headSize * Math.cos(angle + Math.PI / 6),
                          arrow.endY - headSize * Math.sin(angle + Math.PI / 6));
                ctx.closePath();
                ctx.fill();
            });

            // Draw axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);

            // x-axis
            if (yMin <= 0 && yMax >= 0) {
                const y0 = canvas.height - yOffset - (0 - yMin) * yScale;
                ctx.beginPath();
                ctx.moveTo(xOffset, y0);
                ctx.lineTo(canvas.width - xOffset, y0);
                ctx.stroke();
            }
            // y-axis
            if (tMin <= 0 && tMax >= 0) {
                const x0 = xOffset + (0 - tMin) * xScale;
                ctx.beginPath();
                ctx.moveTo(x0, yOffset);
                ctx.lineTo(x0, canvas.height - yOffset);
                ctx.stroke();
            }

            // Draw axis labels
            drawAxisLabels(ctx, tMin, tMax, yMin, yMax, xScale, yScale, xOffset, canvas);

            // Draw user trajectories
            const colors = [ '#dc2626', '#ea580c', '#ca8a04', '#16a34a', '#0891b2', '#7c3aed', '#db2777', '#4b5563' ];

            // Draw stored trajectories
            trajectories.forEach((traj, idx) => {
                if (traj.length > 1) {
                    ctx.strokeStyle = colors[idx % colors.length];
                    ctx.lineWidth = 1.8;
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(traj[0].x, traj[0].y);
                    for (let i = 1; i < traj.length; i++) {
                        ctx.lineTo(traj[i].x, traj[i].y);
                    }
                    ctx.stroke();
                }
            });

            // Draw initial points
            if (showInitialPoint) {
                userPoints.forEach((point, idx) => {
                    const startX = xOffset + (point.x - tMin) * xScale;
                    const startY = canvas.height - xOffset - (point.y - yMin) * yScale;
                    ctx.fillStyle = colors[idx % colors.length];
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(startX, startY, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                });
            }
        }

        function downloadImage() {
            const canvas = document.getElementById('canvas');
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height + 100;
            const tempCtx = tempCanvas.getContext('2d');

            tempCtx.fillStyle = '#fafafa';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            const a = parseFloat(document.getElementById('a').value) || 0;
            const b = parseFloat(document.getElementById('b').value) || 0;
            const c = parseFloat(document.getElementById('c').value) || 0;
            const d = parseFloat(document.getElementById('d').value) || 0;
            const arrowCount = parseInt(document.getElementById('arrow-count').value) || 18;
            const arrowScale = parseFloat(document.getElementById('arrow-scale').value) || 0.6;
            const fieldColor = document.getElementById('field-color').value || '#2563eb';
            const showGrid = document.getElementById('showGrid').checked;
            const showInitialPoint = document.getElementById('showInitialPoint').checked;

            const classification = classifyEquilibrium(a, b, c, d);

            tempCtx.fillStyle = '#4f46e5';
            tempCtx.font = 'bold 16px Arial';
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillText(`${classification.type} • ${classification.stability}`, tempCanvas.width/2, 20);
            tempCtx.font = '12px Arial';
            tempCtx.fillText(classification.description, tempCanvas.width/2, 40);

            const formatCoeff = (coeff) => {
                if (coeff === 0) return '0';
                if (coeff === 1) return '';
                if (coeff === -1) return '-';
                return Math.round(coeff * 100) / 100;
            };
            const aStr = formatCoeff(a);
            const bStr = formatCoeff(b);
            const cStr = formatCoeff(c);
            const dStr = formatCoeff(d);
            const bSign = b >= 0 ? '+' : '';
            const dSign = d >= 0 ? '+' : '';
            const eqText1 = `x' = ${aStr === '' ? '' : aStr}${aStr === '' && a === -1 ? '-' : ''}x ${bSign}${bStr}y`;
            const eqText2 = `y' = ${cStr === '' ? '' : cStr}${cStr === '' && c === -1 ? '-' : ''}x ${dSign}${dStr}y`;

            tempCtx.fillStyle = 'white';
            tempCtx.strokeStyle = '#3b82f6';
            tempCtx.lineWidth = 2;
            tempCtx.beginPath();
            tempCtx.roundRect(tempCanvas.width/2 - 160, 50, 320, 40, 10);
            tempCtx.fill();
            tempCtx.stroke();

            tempCtx.fillStyle = '#1e293b';
            tempCtx.font = 'bold 14px Arial';
            tempCtx.fillText(eqText1, tempCanvas.width/2, 60);
            tempCtx.fillText(eqText2, tempCanvas.width/2, 80);

            const graphOffsetY = 100;
            const tMin = -5, tMax = 5, yMin = -5, yMax = 5;
            const xOffset = 70;
            const drawWidth = canvas.width - 2 * xOffset;
            const drawHeight = canvas.height - 2 * xOffset;
            const scale = Math.min(drawWidth, drawHeight) / (tMax - tMin);
            const xScale = scale;
            const yScale = scale;
            const graphXOffset = (canvas.width - (tMax - tMin) * xScale) / 2;
            const graphYOffset = (canvas.height - (yMax - yMin) * yScale) / 2;
            const step = Math.min(drawWidth / arrowCount, drawHeight / arrowCount);

            if (showGrid) {
                tempCtx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                tempCtx.lineWidth = 0.5;
                tempCtx.setLineDash([]);
                const tStep = getNiceStep(tMax - tMin);
                for (let i = Math.ceil(tMin/tStep)*tStep; i < tMax; i += tStep) {
                    const x = graphXOffset + (i - tMin) * xScale;
                    const y1 = graphOffsetY + graphYOffset;
                    const y2 = graphOffsetY + canvas.height - graphYOffset;
                    tempCtx.beginPath();
                    tempCtx.moveTo(x, y1);
                    tempCtx.lineTo(x, y2);
                    tempCtx.stroke();
                }
                const yStep = getNiceStep(yMax - yMin);
                for (let i = Math.ceil(yMin/yStep)*yStep; i < yMax; i += yStep) {
                    const y = graphOffsetY + canvas.height - graphYOffset - (i - yMin) * yScale;
                    tempCtx.beginPath();
                    tempCtx.moveTo(graphXOffset, y);
                    tempCtx.lineTo(canvas.width - graphXOffset, y);
                    tempCtx.stroke();
                }
            }

            // OPTIMIZATION: Batched arrows in download too
            tempCtx.lineWidth = 0.75;
            tempCtx.strokeStyle = fieldColor;
            tempCtx.beginPath();
            const arrowData = [];

            const minX = graphXOffset;
            const maxX = canvas.width - graphXOffset;
            const minY = graphOffsetY + graphYOffset;
            const maxY = graphOffsetY + canvas.height - graphYOffset;

            for (let px = minX + step/2; px < maxX; px += step) {
                for (let py = minY + step/2; py < maxY; py += step) {
                    const t = tMin + (px - graphXOffset) / xScale;
                    const y_val = yMin + (canvas.height - graphYOffset - (py - graphOffsetY)) / yScale;
                    const dx = a * t + b * y_val;
                    const dy = c * t + d * y_val;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len === 0) continue;

                    const deltaCanvasX = dx * xScale;
                    const deltaCanvasY = -dy * yScale;
                    const lenCanvas = Math.sqrt(deltaCanvasX * deltaCanvasX + deltaCanvasY * deltaCanvasY);
                    const normDx = deltaCanvasX / lenCanvas;
                    const normDy = deltaCanvasY / lenCanvas;
                    let drawLength = 20 * arrowScale;
                    drawLength = drawLength * Math.min(1, 5 / len);
                    drawLength = Math.max(drawLength, 5);

                    const startX = px - (normDx * drawLength) / 2;
                    const startY = py - (normDy * drawLength) / 2;
                    const endX = px + (normDx * drawLength) / 2;
                    const endY = py + (normDy * drawLength) / 2;

                    tempCtx.moveTo(startX, startY);
                    tempCtx.lineTo(endX, endY);

                    arrowData.push({
                        endX: endX,
                        endY: endY,
                        normDx: normDx,
                        normDy: normDy,
                        drawLength: drawLength
                    });
                }
            }
            tempCtx.stroke();

            tempCtx.fillStyle = fieldColor;
            arrowData.forEach(arrow => {
                const headSize = Math.min(8, arrow.drawLength / 3 + 2);
                const angle = Math.atan2(arrow.normDy, arrow.normDx);
                tempCtx.beginPath();
                tempCtx.moveTo(arrow.endX, arrow.endY);
                tempCtx.lineTo(arrow.endX - headSize * Math.cos(angle - Math.PI / 6),
                              arrow.endY - headSize * Math.sin(angle - Math.PI / 6));
                tempCtx.lineTo(arrow.endX - headSize * Math.cos(angle + Math.PI / 6),
                              arrow.endY - headSize * Math.sin(angle + Math.PI / 6));
                tempCtx.closePath();
                tempCtx.fill();
            });

            tempCtx.strokeStyle = '#000';
            tempCtx.lineWidth = 2;
            tempCtx.setLineDash([]);
            if (yMin <= 0 && yMax >= 0) {
                const y0 = graphOffsetY + canvas.height - graphYOffset - (0 - yMin) * yScale;
                tempCtx.beginPath();
                tempCtx.moveTo(graphXOffset, y0);
                tempCtx.lineTo(canvas.width - graphXOffset, y0);
                tempCtx.stroke();
            }
            if (tMin <= 0 && tMax >= 0) {
                const x0 = graphXOffset + (0 - tMin) * xScale;
                const y1 = graphOffsetY + graphYOffset;
                const y2 = graphOffsetY + canvas.height - graphYOffset;
                tempCtx.beginPath();
                tempCtx.moveTo(x0, y1);
                tempCtx.lineTo(x0, y2);
                tempCtx.stroke();
            }

            tempCtx.font = 'bold 12px Arial';
            tempCtx.fillStyle = '#111';
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'top';
            const tStep = getNiceStep(tMax - tMin);
            for (let t = Math.ceil(tMin/tStep)*tStep; t <= tMax + 1e-9; t += tStep) {
                const x = graphXOffset + (t - tMin) * xScale;
                const y = graphOffsetY + canvas.height - graphYOffset + 8;
                tempCtx.fillText(t.toFixed(1).replace(/\.0$/, ''), x, y);
            }
            tempCtx.textAlign = 'right';
            tempCtx.textBaseline = 'middle';
            const yStep = getNiceStep(yMax - yMin);
            for (let yVal = Math.ceil(yMin/yStep)*yStep; yVal <= yMax + 1e-9; yVal += yStep) {
                const py = graphOffsetY + canvas.height - graphYOffset - (yVal - yMin) * yScale;
                tempCtx.fillText(yVal.toFixed(1).replace(/\.0$/, ''), graphXOffset - 8, py);
            }
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'top';
            tempCtx.fillText('x', canvas.width - 15, graphOffsetY + canvas.height - graphYOffset + 10);
            tempCtx.textAlign = 'right';
            tempCtx.textBaseline = 'middle';
            tempCtx.save();
            tempCtx.translate(15, graphOffsetY + canvas.height / 2);
            tempCtx.rotate(-Math.PI / 2);
            tempCtx.textAlign = 'center';
            tempCtx.fillText('y', 0, 0);
            tempCtx.restore();

            const colors = [ '#dc2626', '#ea580c', '#ca8a04', '#16a34a', '#0891b2', '#7c3aed', '#db2777', '#4b5563' ];
            trajectories.forEach((traj, idx) => {
                if (traj.length > 1) {
                    tempCtx.strokeStyle = colors[idx % colors.length];
                    tempCtx.lineWidth = 1.8;
                    tempCtx.lineJoin = 'round';
                    tempCtx.lineCap = 'round';
                    tempCtx.setLineDash([]);
                    tempCtx.beginPath();
                    tempCtx.moveTo(traj[0].x, traj[0].y + graphOffsetY);
                    for (let i = 1; i < traj.length; i++) {
                        tempCtx.lineTo(traj[i].x, traj[i].y + graphOffsetY);
                    }
                    tempCtx.stroke();
                }
            });

            if (showInitialPoint && userPoints.length > 0) {
                userPoints.forEach((point, idx) => {
                    const startX = graphXOffset + (point.x - tMin) * xScale;
                    const startY = graphOffsetY + canvas.height - graphYOffset - (point.y - yMin) * yScale;
                    tempCtx.fillStyle = colors[idx % colors.length];
                    tempCtx.strokeStyle = '#000';
                    tempCtx.lineWidth = 1.5;
                    tempCtx.beginPath();
                    tempCtx.arc(startX, startY, 4, 0, Math.PI * 2);
                    tempCtx.fill();
                    tempCtx.stroke();
                });
            }

            const link = document.createElement('a');
            link.download = 'phase-portrait-optimized.png';
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        }
    </script>
</body>
</html>
