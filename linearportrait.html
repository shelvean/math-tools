<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Linear Phase Diagram, Phase Portrait, Spirals, Centers, Trajectories">
  <meta name="keywords" content="Linear, Direction Fields, Phase Portraits, Phase Diagrams, Phase Plane Plotter, Phase Spaces, Phase Portrait Plotter, 2D Phase Plane, Systems of Differential Equations, Spirals, Centers, Trajectories, Stable, Unstable">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5B8PRB2WZT"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments) }
    gtag('js', new Date());
    gtag('config', 'G-5B8PRB2WZT');
  </script>
  <title>Phase Plane Plotter</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f7fb;
      overflow-x: hidden;
    }
    .page-container {
      max-width: 1600px;
      margin: 0 auto;
      padding-top: 80px;
    }
    .main-content {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }
    .container {
      background: white;
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: 0 6px 25px rgba(0, 0, 0, 0.08);
      flex: 1;
      min-width: 700px;
      display: flex;
      flex-direction: column;
    }
    .examples-column {
      width: 400px;
      background: white;
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: 0 6px 25px rgba(0, 0, 0, 0.08);
      height: fit-content;
    }
    .example {
      margin-bottom: 0.8rem;
      cursor: pointer;
      padding: 12px;
      border-radius: 8px;
      transition: all 0.2s;
      border: 1px solid #e5e7eb;
      background: #f8fafc;
    }
    .example:hover {
      background-color: #f0f9ff;
      border-color: #3b82f6;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
    }
    .example h3 {
      margin-bottom: 0.5rem;
      color: #1e293b;
      font-weight: 600;
      font-size: 1rem;
    }
    .matrix-latex {
      font-size: 0.95rem;
    }
    h1 {
      color: #1e293b;
      text-align: center;
      margin-bottom: 1rem;
      font-size: 2rem;
    }
    
    /* Compact controls section */
    .controls-section {
      background: #f8fafc;
      border-radius: 10px;
      padding: 1.2rem;
      margin-bottom: 1rem;
      border: 1px solid #e5e7eb;
    }
    
    /* Matrix input grid - using the same style as matrix product calculator */
    .matrix-grid {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 1rem 0;
    }
    
    .matrix-input-container {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 1rem;
    }
    
    .matrix-label {
      font-size: 1.1rem;
      font-weight: 600;
      color: #1e293b;
      white-space: nowrap;
    }
    
    .matrix-table {
      border-collapse: collapse;
    }
    
    .matrix-table td {
      padding: 4px;
      border: 1px solid #d1d5db;
    }
    
    .matrix-input {
      width: 70px;
      height: 40px;
      text-align: center;
      border: 2px solid #d1d5db;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      transition: all 0.2s;
    }
    
    .matrix-input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }
    
    /* Controls row */
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: space-between;
      align-items: center;
      margin-top: 1rem;
    }
    
    .input-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .input-group input {
      width: 70px;
      padding: 0.4rem;
      text-align: center;
      border: 2px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.95rem;
    }
    
    .input-group label {
      font-size: 0.95rem;
      color: #1e293b;
      font-weight: 500;
      white-space: nowrap;
    }
    
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
    }
    
    .checkbox-group input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    
    .checkbox-group label {
      font-size: 0.95rem;
      color: #1e293b;
      font-weight: 500;
      cursor: pointer;
    }
    
    button {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    
    button:hover {
      background: #2563eb;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
    }
    
    .button-container {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin: 1rem 0;
    }
    
    button.clear {
      background: #ef4444;
    }
    
    button.clear:hover {
      background: #dc2626;
      box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
    }
    
    button.download-btn {
      background: #10b981;
    }
    
    button.download-btn:hover {
      background: #059669;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }
    
    canvas {
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      background: #fafafa;
    }
    
    .canvas-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    
    .instruction {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(5px);
      width: calc(100% - 4rem);
      max-width: 40rem;
      padding: 0.6rem 1.5rem;
      border-radius: 30px;
      font-size: 0.85rem;
      font-weight: 600;
      color: #1e40af;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      z-index: 10;
      animation: float 3s ease-in-out infinite;
      border: 1px solid rgba(59, 130, 246, 0.3);
      text-align: center;
    }
    
    @keyframes float {
      0%, 100% { transform: translateX(-50%) translateY(0); }
      50% { transform: translateX(-50%) translateY(-3px); }
    }
    
    /* Navigation */
    nav {
      height: 60px;
    }
    
    nav .max-w-5xl {
      max-width: 1400px;
    }
    
    /* Examples grid */
    .examples-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
    
    /* Canvas equation box - made wider for larger canvas */
    .canvas-equation-container {
      width: 700px;
      background: white;
      padding: 12px 20px;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      border: 2px solid #3b82f6;
      text-align: center;
      margin-bottom: 10px;
    }
    
    /* Footer - made wider for larger canvas */
    .canvas-footer {
      margin-top: 15px;
      padding-top: 10px;
      text-align: center;
      color: #6b7280;
      font-size: 0.85rem;
      width: 700px;
    }
    
    /* System equation */
    .system-equation {
      font-size: 1.2rem;
      text-align: center;
      margin: 0.5rem 0;
      min-height: 40px;
    }
    
    /* Responsive adjustments */
    @media (max-width: 1400px) {
      .container {
        min-width: 650px;
      }
      .examples-column {
        width: 350px;
      }
    }
    
    @media (max-width: 1200px) {
      .page-container {
        padding-top: 70px;
      }
      .main-content {
        flex-direction: column;
      }
      .container {
        min-width: 100%;
      }
      .examples-column {
        width: 100%;
      }
      .examples-grid {
        grid-template-columns: repeat(4, 1fr);
      }
      .canvas-equation-container,
      .canvas-footer {
        width: 100%;
        max-width: 700px;
      }
    }
    
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      .container {
        padding: 1rem;
      }
      .matrix-input {
        width: 55px;
        height: 35px;
        font-size: 0.9rem;
      }
      .controls-row {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
      .input-group, .checkbox-group {
        width: 100%;
        justify-content: space-between;
      }
      .instruction {
        font-size: 0.75rem;
        padding: 0.5rem 1rem;
        width: 90%;
      }
      .examples-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      .canvas-equation-container, .canvas-footer {
        width: 100%;
        max-width: 500px;
      }
    }
    
    @media (max-width: 480px) {
      .examples-grid {
        grid-template-columns: 1fr;
      }
      .matrix-input-container {
        flex-direction: column;
        gap: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="nav-container w-full bg-white shadow-md fixed top-0 left-0 z-50">
    <nav class="max-w-5xl mx-auto px-4 py-3">
      <ul class="flex justify-center space-x-4 sm:space-x-6">
        <li><a href="index.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Home</a></li>
        <li><a href="teaching.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Teaching</a></li>
        <li><a href="projects.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Diff Eq</a></li>
        <li><a href="linear.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Linear Algebra</a></li>
        <li><a href="numerical.html" class="text-indigo-600 hover:text-indigo-800 font-bold text-sm sm:text-lg">Numerical Methods</a></li>
      </ul>
    </nav>
  </div>
  
  <div class="page-container">
    <div class="main-content">
      <div class="container">
        <h1>Phase Portraits of Linear Systems</h1>
        
        <div class="controls-section">
          <!-- System equation -->
          <div class="system-equation" id="equation-display"></div>
          
          <!-- Matrix input - using grid structure from matrix product calculator -->
          <div class="matrix-grid">
            <div class="matrix-input-container">
              <span class="matrix-label">Matrix of Coefficients:</span>
              <table class="matrix-table">
                <tr>
                  <td><input type="text" id="a" class="matrix-input" placeholder="a" value="-1"></td>
                  <td><input type="text" id="b" class="matrix-input" placeholder="b" value="2"></td>
                </tr>
                <tr>
                  <td><input type="text" id="c" class="matrix-input" placeholder="c" value="-2"></td>
                  <td><input type="text" id="d" class="matrix-input" placeholder="d" value="-1"></td>
                </tr>
              </table>
            </div>
            
            <div class="controls-row">
              <div class="input-group">
                <label for="arrow-count">Arrows per axis:</label>
                <input type="number" id="arrow-count" value="25" min="10" max="40">
              </div>
              
              <div class="input-group">
                <label for="arrow-scale">Arrow Scale:</label>
                <input type="number" id="arrow-scale" value="0.6" min="0.1" max="2" step="0.1">
              </div>
              
              <div class="checkbox-group">
                <input type="checkbox" id="showInitialPoint" checked>
                <label for="showInitialPoint">Show initial point</label>
              </div>
              
              <div class="checkbox-group">
                <input type="checkbox" id="showGrid" checked>
                <label for="showGrid">Show grid</label>
              </div>
            </div>
            
            <div class="button-container">
              <button onclick="drawPhasePortrait()">Generate Phase Portrait</button>
              <button class="clear" onclick="clearUserPoints()">Clear Trajectories</button>
            </div>
          </div>
        </div>
        
        <div class="canvas-wrapper">
          <!-- Equation container above the canvas -->
          <div class="canvas-equation-container" id="canvas-equation"></div>
          
          <!-- Canvas with instruction - increased to 700x700 (1:1 aspect ratio) -->
          <div style="position: relative; width: 700px; height: 700px;">
            <canvas id="canvas" width="700" height="700"></canvas>
            <div id="instruction" class="instruction">✨ Click anywhere on the graph to add trajectories</div>
          </div>
          
          <!-- Footer with download button -->
          <div class="canvas-footer">
            <button class="download-btn" onclick="downloadImage()">Download Image</button>
            <p style="margin-top: 15px;">© 2025 Shelvean Kapita &bull;  kapita@tamu.edu &bull; All code released under the MIT License. Last modified December 11, 2025 </p>
          </div>
        </div>
      </div>
      
      <div class="examples-column">
        <h2 class="text-2xl font-bold mb-4">Example Matrices (click)</h2>
        <div class="examples-grid">
          <div class="example" data-a="-2" data-b="1" data-c="1" data-d="-3">
            <h3>Stable Node</h3>
            <span class="matrix-latex">\begin{pmatrix} -2 & 1 \\ 1 & -3 \end{pmatrix}</span>
          </div>
          <div class="example" data-a="2" data-b="1" data-c="1" data-d="5">
            <h3>Unstable Node</h3>
            <span class="matrix-latex">\begin{pmatrix} 2 & 1 \\ 1 & 5 \end{pmatrix}</span>
          </div>
          <div class="example" data-a="1" data-b="3" data-c="3" data-d="-1">
            <h3>Saddle Point</h3>
            <span class="matrix-latex">\begin{pmatrix} 1 & 3 \\ 3 & -1 \end{pmatrix}</span>
          </div>
          <div class="example" data-a="-1" data-b="2" data-c="-2" data-d="-1">
            <h3>Stable Spiral</h3>
            <span class="matrix-latex">\begin{pmatrix} -1 & 2 \\ -2 & -1 \end{pmatrix}</span>
          </div>
          <div class="example" data-a="1" data-b="2" data-c="-2" data-d="1">
            <h3>Unstable Spiral</h3>
            <span class="matrix-latex">\begin{pmatrix} 1 & 2 \\ -2 & 1 \end{pmatrix}</span>
          </div>
          <div class="example" data-a="0" data-b="1" data-c="-1" data-d="0">
            <h3>Center</h3>
            <span class="matrix-latex">\begin{pmatrix} 0 & 1 \\ -1 & 0 \end{pmatrix}</span>
          </div>
          <div class="example" data-a="2" data-b="-1" data-c="1" data-d="4">
            <h3>Degenerate Node</h3>
            <span class="matrix-latex">\begin{pmatrix} 2 & -1 \\ 1 & 4 \end{pmatrix}</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script>
    let userPoints = [];
    
    document.addEventListener('DOMContentLoaded', () => {
      // Render main equation
      katex.render('\\begin{cases}\n \\dot{x} = ax + by \\\\\n \\dot{y} = cx + dy\n \\end{cases}', 
        document.getElementById('equation-display'), 
        { throwOnError: false, displayMode: true }
      );
      
      // Set up example click handlers
      document.querySelectorAll('.example').forEach(example => {
        example.addEventListener('click', () => {
          userPoints = [];
          document.getElementById('a').value = example.dataset.a;
          document.getElementById('b').value = example.dataset.b;
          document.getElementById('c').value = example.dataset.c;
          document.getElementById('d').value = example.dataset.d;
          drawPhasePortrait();
        });
        // Render matrix LaTeX for each example
        katex.render(
          example.querySelector('.matrix-latex').textContent, 
          example.querySelector('.matrix-latex'), 
          { throwOnError: false, displayMode: true }
        );
      });
      
      // Canvas click handler
      const canvas = document.getElementById('canvas');
      canvas.addEventListener('click', event => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Check if click is within the graph area
        const PADDING = 70; // Increased padding for larger canvas
        if (x < PADDING || x > canvas.width - PADDING || y < PADDING || y > canvas.height - PADDING) return;
        
        const tMin = -5, tMax = 5, yMin = -5, yMax = 5;
        const drawWidth = canvas.width - 2 * PADDING;
        const drawHeight = canvas.height - 2 * PADDING;
        const xScale = drawWidth / (tMax - tMin);
        const yScale = drawHeight / (yMax - yMin);
        
        const t = tMin + (x - PADDING) / xScale;
        const yVal = yMin + (canvas.height - PADDING - y) / yScale;
        
        userPoints.push({ x: t, y: yVal });
        drawPhasePortrait();
        document.getElementById('instruction').style.display = 'none';
      });
      
      // Initial draw
      drawPhasePortrait();
    });
    
    function clearUserPoints() {
      userPoints = [];
      drawPhasePortrait();
      document.getElementById('instruction').style.display = 'block';
    }
    
    function getNiceStep(range) {
      const rough = range / 8;
      const exp = Math.pow(10, Math.floor(Math.log10(rough)));
      const frac = rough / exp;
      return (frac <= 1.5 ? 1 : frac <= 3.5 ? 2 : frac <= 7 ? 5 : 10) * exp;
    }
    
    function drawAxisLabels(ctx, tMin, tMax, yMin, yMax, xScale, yScale, PADDING, canvas) {
      ctx.font = 'bold 12px Arial';
      ctx.fillStyle = '#111';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      
      const tStep = getNiceStep(tMax - tMin);
      for (let t = Math.ceil(tMin/tStep)*tStep; t <= tMax + 1e-9; t += tStep) {
        const x = PADDING + (t - tMin) * xScale;
        ctx.fillText(t.toFixed(1).replace(/\.0$/, ''), x, canvas.height - PADDING + 8);
      }
      
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      const yStep = getNiceStep(yMax - yMin);
      for (let y = Math.ceil(yMin/yStep)*yStep; y <= yMax + 1e-9; y += yStep) {
        const py = canvas.height - PADDING - (y - yMin) * yScale;
        ctx.fillText(y.toFixed(1).replace(/\.0$/, ''), PADDING - 8, py);
      }
      
      // Add axis labels
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillText('x', canvas.width - 15, canvas.height - PADDING + 10);
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      ctx.save();
      ctx.translate(15, canvas.height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('y', 0, 0);
      ctx.restore();
    }
    
    function renderEquationToCanvas(a, b, c, d) {
      const eqContainer = document.getElementById('canvas-equation');
      eqContainer.innerHTML = '';
      
      // Format coefficients
      const formatCoeff = (coeff) => {
        if (coeff === 0) return '0';
        if (coeff === 1) return '';
        if (coeff === -1) return '-';
        const rounded = Math.round(coeff * 100) / 100;
        return rounded.toString();
      };
      
      const aStr = formatCoeff(a);
      const bStr = formatCoeff(b);
      const cStr = formatCoeff(c);
      const dStr = formatCoeff(d);
      
      const bSign = b >= 0 ? '+' : '';
      const dSign = d >= 0 ? '+' : '';
      
      const eqString = `\\begin{cases} \\dot{x} = ${aStr === '' ? '' : aStr}${aStr === '' && a === -1 ? '-' : ''}x ${bSign}${bStr}y \\\\ \\dot{y} = ${cStr === '' ? '' : cStr}${cStr === '' && c === -1 ? '-' : ''}x ${dSign}${dStr}y \\end{cases}`;
      
      katex.render(eqString, eqContainer, {
        throwOnError: false,
        displayMode: true,
        fontSize: 18
      });
    }
    
    function computeTrajectory(x0, y0, a, b, c, d, tMin, tMax, yMin, yMax, xOffset, xScale, yScale, canvas) {
        const points = [];
        const MAX_STEPS = 5000;
        const dt = 0.02; // Smaller step for better accuracy
        
        function derivatives(x, y) {
            return { dx: a * x + b * y, dy: c * x + d * y };
        }
        
        // Heun's method (Improved Euler) - forward integration
        let x = x0, y = y0;
        for (let i = 0; i < MAX_STEPS; i++) {
            if (x < tMin || x > tMax || y < yMin || y > yMax) break;
            
            const px = xOffset + (x - tMin) * xScale;
            const py = canvas.height - xOffset - (y - yMin) * yScale;
            points.push({ x: px, y: py });
            
            // Heun's method step
            const k1 = derivatives(x, y);
            const x_temp = x + dt * k1.dx;
            const y_temp = y + dt * k1.dy;
            
            const k2 = derivatives(x_temp, y_temp);
            
            x += dt * 0.5 * (k1.dx + k2.dx);
            y += dt * 0.5 * (k1.dy + k2.dy);
            
            // Stop if trajectory leaves reasonable bounds
            if (Math.abs(x) > 20 || Math.abs(y) > 20) break;
        }
        
        // Heun's method - backward integration
        x = x0; y = y0;
        const backwardPoints = [];
        for (let i = 0; i < MAX_STEPS; i++) {
            const k1 = derivatives(x, y);
            const x_temp = x - dt * k1.dx;
            const y_temp = y - dt * k1.dy;
            
            const k2 = derivatives(x_temp, y_temp);
            
            x -= dt * 0.5 * (k1.dx + k2.dx);
            y -= dt * 0.5 * (k1.dy + k2.dy);
            
            if (x < tMin || x > tMax || y < yMin || y > yMax) break;
            if (Math.abs(x) > 20 || Math.abs(y) > 20) break;
            
            const px = xOffset + (x - tMin) * xScale;
            const py = canvas.height - xOffset - (y - yMin) * yScale;
            backwardPoints.unshift({ x: px, y: py });
        }
        
        return [...backwardPoints, ...points];
    }
    
    function drawPhasePortrait() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      // Clear with background
      ctx.fillStyle = '#fafafa';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Get matrix coefficients
      const a = parseFloat(document.getElementById('a').value) || 0;
      const b = parseFloat(document.getElementById('b').value) || 0;
      const c = parseFloat(document.getElementById('c').value) || 0;
      const d = parseFloat(document.getElementById('d').value) || 0;
      
      const arrowCount = parseInt(document.getElementById('arrow-count').value) || 18;
      const arrowScale = parseFloat(document.getElementById('arrow-scale').value) || 0.6;
      const showInitialPoint = document.getElementById('showInitialPoint').checked;
      const showGrid = document.getElementById('showGrid').checked;
      
      // Render equation at top using KaTeX (separate from canvas)
      renderEquationToCanvas(a, b, c, d);
      
      const tMin = -5, tMax = 5, yMin = -5, yMax = 5;
      const PADDING = 70; // Increased padding for larger canvas
      const drawWidth = canvas.width - 2 * PADDING;
      const drawHeight = canvas.height - 2 * PADDING;
      
      // Use the same scale for both axes to maintain 1:1 aspect ratio
      const scale = Math.min(drawWidth, drawHeight) / (tMax - tMin);
      const xScale = scale;
      const yScale = scale;
      
      // Center the graph in the canvas
      const xOffset = (canvas.width - (tMax - tMin) * xScale) / 2;
      const yOffset = (canvas.height - (yMax - yMin) * yScale) / 2;
      
      const step = Math.min(drawWidth / arrowCount, drawHeight / arrowCount);
      
      // Draw grid if enabled
      if (showGrid) {
        ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
        ctx.lineWidth = 0.5;
        ctx.setLineDash([]);
        
        const tStep = getNiceStep(tMax - tMin);
        for (let i = Math.ceil(tMin/tStep)*tStep; i < tMax; i += tStep) {
          const x = xOffset + (i - tMin) * xScale;
          ctx.beginPath();
          ctx.moveTo(x, yOffset);
          ctx.lineTo(x, canvas.height - yOffset);
          ctx.stroke();
        }
        
        const yStep = getNiceStep(yMax - yMin);
        for (let i = Math.ceil(yMin/yStep)*yStep; i < yMax; i += yStep) {
          const y = canvas.height - yOffset - (i - yMin) * yScale;
          ctx.beginPath();
          ctx.moveTo(xOffset, y);
          ctx.lineTo(canvas.width - xOffset, y);
          ctx.stroke();
        }
      }
      
      // Draw arrows
      ctx.lineWidth = 1.5;
      
      // Calculate the actual drawing area based on the centered graph
      const minX = xOffset;
      const maxX = canvas.width - xOffset;
      const minY = yOffset;
      const maxY = canvas.height - yOffset;
      
      for (let px = minX + step/2; px < maxX; px += step) {
        for (let py = minY + step/2; py < maxY; py += step) {
          const t = tMin + (px - xOffset) / xScale;
          const y = yMin + (canvas.height - yOffset - py) / yScale;
          
          const dx = a * t + b * y;
          const dy = c * t + d * y;
          const len = Math.sqrt(dx * dx + dy * dy);
          if (len === 0) continue;
          
          // For 1:1 aspect ratio, we don't need to adjust for aspect
          const angle = Math.atan2(-dy, dx); // Negative because canvas y is positive downward
          
          let drawLength = 25 * arrowScale;
          drawLength = Math.max(drawLength, 10);
          
          const dxArrow = drawLength * Math.cos(angle);
          const dyArrow = drawLength * Math.sin(angle);
          
          ctx.strokeStyle = 'rgba(30, 100, 200, 0.7)';
          ctx.beginPath();
          ctx.moveTo(px - dxArrow/2, py - dyArrow/2);
          ctx.lineTo(px + dxArrow/2, py + dyArrow/2);
          ctx.stroke();
          
          // Arrow heads
          const head = Math.min(8, drawLength/2.5);
          ctx.beginPath();
          ctx.moveTo(px + dxArrow/2, py + dyArrow/2);
          ctx.lineTo(px + dxArrow/2 - head * Math.cos(angle - Math.PI/6), py + dyArrow/2 - head * Math.sin(angle - Math.PI/6));
          ctx.moveTo(px + dxArrow/2, py + dyArrow/2);
          ctx.lineTo(px + dxArrow/2 - head * Math.cos(angle + Math.PI/6), py + dyArrow/2 - head * Math.sin(angle + Math.PI/6));
          ctx.stroke();
        }
      }
      
      // Draw axes
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.setLineDash([]);
      
      // x-axis
      if (yMin <= 0 && yMax >= 0) {
        const y0 = canvas.height - yOffset - (0 - yMin) * yScale;
        ctx.beginPath();
        ctx.moveTo(xOffset, y0);
        ctx.lineTo(canvas.width - xOffset, y0);
        ctx.stroke();
      }
      // y-axis
      if (tMin <= 0 && tMax >= 0) {
        const x0 = xOffset + (0 - tMin) * xScale;
        ctx.beginPath();
        ctx.moveTo(x0, yOffset);
        ctx.lineTo(x0, canvas.height - yOffset);
        ctx.stroke();
      }
      
      // Draw axis labels
      drawAxisLabels(ctx, tMin, tMax, yMin, yMax, xScale, yScale, xOffset, canvas);
      
      // Draw user trajectories
      const colors = [
        '#dc2626', '#ea580c', '#ca8a04', '#16a34a', 
        '#0891b2', '#7c3aed', '#db2777', '#4b5563'
      ];
      
      userPoints.forEach((point, idx) => {
        const path = computeTrajectory(point.x, point.y, a, b, c, d, tMin, tMax, yMin, yMax, xOffset, xScale, yScale, canvas);
        if (path.length > 1) {
          ctx.strokeStyle = colors[idx % colors.length];
          ctx.lineWidth = 2.5;
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.setLineDash([]);
          ctx.beginPath();
          
          path.forEach((p, i) => {
            if (i === 0) {
              ctx.moveTo(p.x, p.y);
            } else {
              ctx.lineTo(p.x, p.y);
            }
          });
          ctx.stroke();
          
          // Draw initial point if enabled
          if (showInitialPoint) {
            const startX = xOffset + (point.x - tMin) * xScale;
            const startY = canvas.height - yOffset - (point.y - yMin) * yScale;
            ctx.fillStyle = colors[idx % colors.length];
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(startX, startY, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          }
        }
      });
    }
    
    function downloadImage() {
      const canvas = document.getElementById('canvas');
      
      // Create a temporary canvas with same size
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height + 80; // Add space for equation at top
      const tempCtx = tempCanvas.getContext('2d');
      
      // Clear with background
      tempCtx.fillStyle = '#fafafa';
      tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
      
      // Get matrix coefficients
      const a = parseFloat(document.getElementById('a').value) || 0;
      const b = parseFloat(document.getElementById('b').value) || 0;
      const c = parseFloat(document.getElementById('c').value) || 0;
      const d = parseFloat(document.getElementById('d').value) || 0;
      
      const arrowCount = parseInt(document.getElementById('arrow-count').value) || 18;
      const arrowScale = parseFloat(document.getElementById('arrow-scale').value) || 0.6;
      const showGrid = document.getElementById('showGrid').checked;
      const showInitialPoint = document.getElementById('showInitialPoint').checked;
      
      // Draw equation at top
      tempCtx.fillStyle = '#1e293b';
      tempCtx.font = 'bold 18px Arial';
      tempCtx.textAlign = 'center';
      tempCtx.textBaseline = 'middle';
      
      const formatCoeff = (coeff) => {
        if (coeff === 0) return '0';
        if (coeff === 1) return '';
        if (coeff === -1) return '-';
        return Math.round(coeff * 100) / 100;
      };
      
      const aStr = formatCoeff(a);
      const bStr = formatCoeff(b);
      const cStr = formatCoeff(c);
      const dStr = formatCoeff(d);
      
      const bSign = b >= 0 ? '+' : '';
      const dSign = d >= 0 ? '+' : '';
      
      const eqText1 = `x' = ${aStr === '' ? '' : aStr}${aStr === '' && a === -1 ? '-' : ''}x ${bSign}${bStr}y`;
      const eqText2 = `y' = ${cStr === '' ? '' : cStr}${cStr === '' && c === -1 ? '-' : ''}x ${dSign}${dStr}y`;
      
      // Draw equation box
      tempCtx.fillStyle = 'white';
      tempCtx.strokeStyle = '#3b82f6';
      tempCtx.lineWidth = 2;
      tempCtx.beginPath();
      tempCtx.roundRect(tempCanvas.width/2 - 160, 20, 320, 60, 10);
      tempCtx.fill();
      tempCtx.stroke();
      
      // Draw equation text
      tempCtx.fillStyle = '#1e293b';
      tempCtx.fillText(eqText1, tempCanvas.width/2, 40);
      tempCtx.fillText(eqText2, tempCanvas.width/2, 65);
      
      // Now draw the graph below the equation (shifted down by 80px)
      const graphOffsetY = 80;
      
      const tMin = -5, tMax = 5, yMin = -5, yMax = 5;
      const xOffset = 70;
      const drawWidth = canvas.width - 2 * xOffset;
      const drawHeight = canvas.height - 2 * xOffset;
      
      // Use the same scale for both axes to maintain 1:1 aspect ratio
      const scale = Math.min(drawWidth, drawHeight) / (tMax - tMin);
      const xScale = scale;
      const yScale = scale;
      
      // Center the graph in the canvas
      const graphXOffset = (canvas.width - (tMax - tMin) * xScale) / 2;
      const graphYOffset = (canvas.height - (yMax - yMin) * yScale) / 2;
      
      const step = Math.min(drawWidth / arrowCount, drawHeight / arrowCount);
      
      // Draw grid if enabled
      if (showGrid) {
        tempCtx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
        tempCtx.lineWidth = 0.5;
        tempCtx.setLineDash([]);
        
        const tStep = getNiceStep(tMax - tMin);
        for (let i = Math.ceil(tMin/tStep)*tStep; i < tMax; i += tStep) {
          const x = graphXOffset + (i - tMin) * xScale;
          const y1 = graphOffsetY + graphYOffset;
          const y2 = graphOffsetY + canvas.height - graphYOffset;
          tempCtx.beginPath();
          tempCtx.moveTo(x, y1);
          tempCtx.lineTo(x, y2);
          tempCtx.stroke();
        }
        
        const yStep = getNiceStep(yMax - yMin);
        for (let i = Math.ceil(yMin/yStep)*yStep; i < yMax; i += yStep) {
          const y = graphOffsetY + canvas.height - graphYOffset - (i - yMin) * yScale;
          tempCtx.beginPath();
          tempCtx.moveTo(graphXOffset, y);
          tempCtx.lineTo(canvas.width - graphXOffset, y);
          tempCtx.stroke();
        }
      }
      
      // Draw arrows
      tempCtx.lineWidth = 1.5;
      
      // Calculate the actual drawing area based on the centered graph
      const minX = graphXOffset;
      const maxX = canvas.width - graphXOffset;
      const minY = graphOffsetY + graphYOffset;
      const maxY = graphOffsetY + canvas.height - graphYOffset;
      
      for (let px = minX + step/2; px < maxX; px += step) {
        for (let py = minY + step/2; py < maxY; py += step) {
          const t = tMin + (px - graphXOffset) / xScale;
          const y = yMin + (canvas.height - graphYOffset - (py - graphOffsetY)) / yScale;
          
          const dx = a * t + b * y;
          const dy = c * t + d * y;
          const len = Math.sqrt(dx * dx + dy * dy);
          if (len === 0) continue;
          
          // For 1:1 aspect ratio, we don't need to adjust for aspect
          const angle = Math.atan2(-dy, dx);
          
          let drawLength = 25 * arrowScale;
          drawLength = Math.max(drawLength, 10);
          
          const dxArrow = drawLength * Math.cos(angle);
          const dyArrow = drawLength * Math.sin(angle);
          
          tempCtx.strokeStyle = 'rgba(30, 100, 200, 0.7)';
          tempCtx.beginPath();
          tempCtx.moveTo(px - dxArrow/2, py - dyArrow/2);
          tempCtx.lineTo(px + dxArrow/2, py + dyArrow/2);
          tempCtx.stroke();
          
          // Arrow heads
          const head = Math.min(8, drawLength/2.5);
          tempCtx.beginPath();
          tempCtx.moveTo(px + dxArrow/2, py + dyArrow/2);
          tempCtx.lineTo(px + dxArrow/2 - head * Math.cos(angle - Math.PI/6), py + dyArrow/2 - head * Math.sin(angle - Math.PI/6));
          tempCtx.moveTo(px + dxArrow/2, py + dyArrow/2);
          tempCtx.lineTo(px + dxArrow/2 - head * Math.cos(angle + Math.PI/6), py + dyArrow/2 - head * Math.sin(angle + Math.PI/6));
          tempCtx.stroke();
        }
      }
      
      // Draw axes
      tempCtx.strokeStyle = '#000';
      tempCtx.lineWidth = 2;
      tempCtx.setLineDash([]);
      
      // x-axis
      if (yMin <= 0 && yMax >= 0) {
        const y0 = graphOffsetY + canvas.height - graphYOffset - (0 - yMin) * yScale;
        tempCtx.beginPath();
        tempCtx.moveTo(graphXOffset, y0);
        tempCtx.lineTo(canvas.width - graphXOffset, y0);
        tempCtx.stroke();
      }
      // y-axis
      if (tMin <= 0 && tMax >= 0) {
        const x0 = graphXOffset + (0 - tMin) * xScale;
        const y1 = graphOffsetY + graphYOffset;
        const y2 = graphOffsetY + canvas.height - graphYOffset;
        tempCtx.beginPath();
        tempCtx.moveTo(x0, y1);
        tempCtx.lineTo(x0, y2);
        tempCtx.stroke();
      }
      
      // Draw axis labels
      tempCtx.font = 'bold 12px Arial';
      tempCtx.fillStyle = '#111';
      tempCtx.textAlign = 'center';
      tempCtx.textBaseline = 'top';
      
      const tStep = getNiceStep(tMax - tMin);
      for (let t = Math.ceil(tMin/tStep)*tStep; t <= tMax + 1e-9; t += tStep) {
        const x = graphXOffset + (t - tMin) * xScale;
        const y = graphOffsetY + canvas.height - graphYOffset + 8;
        tempCtx.fillText(t.toFixed(1).replace(/\.0$/, ''), x, y);
      }
      
      tempCtx.textAlign = 'right';
      tempCtx.textBaseline = 'middle';
      const yStep = getNiceStep(yMax - yMin);
      for (let yVal = Math.ceil(yMin/yStep)*yStep; yVal <= yMax + 1e-9; yVal += yStep) {
        const py = graphOffsetY + canvas.height - graphYOffset - (yVal - yMin) * yScale;
        tempCtx.fillText(yVal.toFixed(1).replace(/\.0$/, ''), graphXOffset - 8, py);
      }
      
      // Add axis labels
      tempCtx.textAlign = 'center';
      tempCtx.textBaseline = 'top';
      tempCtx.fillText('x', canvas.width - 15, graphOffsetY + canvas.height - graphYOffset + 10);
      tempCtx.textAlign = 'right';
      tempCtx.textBaseline = 'middle';
      tempCtx.save();
      tempCtx.translate(15, graphOffsetY + canvas.height / 2);
      tempCtx.rotate(-Math.PI / 2);
      tempCtx.textAlign = 'center';
      tempCtx.fillText('y', 0, 0);
      tempCtx.restore();
      
      // Draw user trajectories
      const colors = [
        '#dc2626', '#ea580c', '#ca8a04', '#16a34a', 
        '#0891b2', '#7c3aed', '#db2777', '#4b5563'
      ];
      
      userPoints.forEach((point, idx) => {
        // Create a copy of the canvas for trajectory computation with offset
        const tempCanvasForTraj = document.createElement('canvas');
        tempCanvasForTraj.width = canvas.width;
        tempCanvasForTraj.height = canvas.height;
        
        const path = computeTrajectory(point.x, point.y, a, b, c, d, tMin, tMax, yMin, yMax, graphXOffset, xScale, yScale, tempCanvasForTraj);
        if (path.length > 1) {
          tempCtx.strokeStyle = colors[idx % colors.length];
          tempCtx.lineWidth = 2.5;
          tempCtx.lineJoin = 'round';
          tempCtx.lineCap = 'round';
          tempCtx.setLineDash([]);
          tempCtx.beginPath();
          
          path.forEach((p, i) => {
            if (i === 0) {
              tempCtx.moveTo(p.x, p.y + graphOffsetY);
            } else {
              tempCtx.lineTo(p.x, p.y + graphOffsetY);
            }
          });
          tempCtx.stroke();
          
          // Draw initial point if enabled
          if (showInitialPoint) {
            const startX = graphXOffset + (point.x - tMin) * xScale;
            const startY = graphOffsetY + canvas.height - graphYOffset - (point.y - yMin) * yScale;
            tempCtx.fillStyle = colors[idx % colors.length];
            tempCtx.strokeStyle = '#000';
            tempCtx.lineWidth = 1.5;
            tempCtx.beginPath();
            tempCtx.arc(startX, startY, 5, 0, Math.PI * 2);
            tempCtx.fill();
            tempCtx.stroke();
          }
        }
      });
      
      // Create download link
      const link = document.createElement('a');
      link.download = 'phase-portrait.png';
      link.href = tempCanvas.toDataURL('image/png');
      link.click();
    }
  </script>
</body>
</html>
