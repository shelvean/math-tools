<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="description" content="A web-based tool to compute the generalized inverse (Moore-Penrose pseudoinverse) of a matrix using Singular Value Decomposition (SVD). Input the matrix dimensions and values to calculate A⁺ in either fractional or decimal form." />
  <meta name="keywords" content="generalized inverse, Moore-Penrose pseudoinverse, SVD, matrix inverse, crossings algebra, matrix calculator, numerical analysis" />
 <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LEQE004C92"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LEQE004C92');
</script>
  <title>Compute the Generalized Inverse of a Matrix using SVD</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" />
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
  <style>
    .katex-display { margin: 1em 0; overflow-x: auto; }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center">
  <div class="fixed top-0 left-0 w-full bg-white shadow-md z-10">
    <div class="max-w-4xl mx-auto px-4 py-2">
      <ul class="flex justify-center space-x-4">
        <li><a href="index.html" class="text-indigo-600 hover:text-blue-600 font-bold text-xl">Home</a></li>
        <li><a href="teaching.html" class="text-indigo-600 hover:text-blue-600 font-bold text-xl">Teaching</a></li>
        <li><a href="projects.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Diff Eq</a></li>
        <li><a href="linear.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Linear Algebra</a></li>
        <li><a href="numerical.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Numerical Methods</a></li>
      </ul>
    </div>
  </div>
  <div class="bg-white p-6 rounded-lg shadow-md max-w-4xl w-full mt-16">
    <h2 class="text-2xl font-bold mb-4 text-center text-gray-800">Moore-Penrose Pseudoinverse Calculator</h2>
    <p class="text-center text-gray-600 mb-6">Compute the <strong>generalized inverse</strong> (Moore-Penrose pseudoinverse) $A^{\dagger}$ using SVD.<br>
    <span class="text-sm">Works for any matrix: square, rectangular, singular, or non-singular.</span></p>

    <!-- About Pseudoinverse - Collapsible -->
    <div class="bg-blue-50 border border-blue-300 rounded-lg mb-6 overflow-hidden">
      <button onclick="togglePseudoConcepts()" class="w-full p-4 text-left flex items-center justify-between hover:bg-blue-100 transition duration-200">
        <h3 class="font-bold text-lg text-blue-800">About the Pseudoinverse</h3>
        <span id="pseudoToggleIcon" class="text-blue-800 font-bold text-xl">−</span>
      </button>
      <div id="pseudoContent" class="px-4 pb-4">
        <p class="text-gray-700 mb-2 text-sm">The <strong>Moore-Penrose pseudoinverse</strong> $A^{\dagger}$ generalizes the matrix inverse:</p>
        <ul class="text-gray-700 text-sm mb-3 ml-6 list-disc">
          <li>If $A$ is square and invertible: $A^{\dagger} = A^{-1}$</li>
          <li>If $A$ has full column rank: $A^{\dagger} = (A^TA)^{-1}A^T$ (left inverse)</li>
          <li>If $A$ has full row rank: $A^{\dagger} = A^T(AA^T)^{-1}$ (right inverse)</li>
          <li>For any matrix: computed via SVD as $A^{\dagger} = V\Sigma^{\dagger}U^T$</li>
        </ul>
        <p class="text-gray-700 mb-2"><strong>Applications:</strong></p>
        <ul class="text-gray-700 text-sm ml-6 list-disc">
          <li>Solving least squares problems: $\min \|Ax - b\|$</li>
          <li>Finding minimum norm solutions to $Ax = b$</li>
          <li>Computing best-fit approximations</li>
        </ul>
      </div>
    </div>

    <div class="bg-gray-50 p-4 rounded-lg mb-6 flex justify-center items-center space-x-4">
      <span class="text-gray-700">Rows <span class="latex">$(m)$</span>:</span>
      <input type="number" id="m" min="1" required class="w-16 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
      <span class="text-gray-700">Columns <span class="latex">$(n)$</span>:</span>
      <input type="number" id="n" min="1" required class="w-16 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
      <button type="button" onclick="generateMatrix()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 transition duration-300">Generate Matrix</button>
      <button type="button" onclick="loadExample()" class="bg-purple-500 text-white px-4 py-2 rounded hover:bg-purple-600 transition duration-300">Load Example</button>
    </div>
    <div id="matrixInput" class="mb-6 overflow-x-auto"></div>
    <div class="flex justify-center mb-6 space-x-6">
      <span class="text-gray-700">Display as:</span>
      <select id="displayType" class="p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
        <option value="fractions" selected>Fractions</option>
        <option value="decimals">Decimals</option>
      </select>
    </div>
    <div class="flex justify-center space-x-4 mb-6">
      <button id="calcBtn" type="button" class="bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-600 transition duration-300 w-1/3">Compute Generalized Inverse</button>
      <button id="clearBtn" type="button" class="bg-gray-500 text-white px-6 py-2 rounded hover:bg-gray-600 transition duration-300 w-1/3">Clear All</button>
    </div>
    <div id="result" class="mt-6 p-4 bg-gray-50 rounded-lg"></div>
    <div class="mt-6 border-t pt-4 text-center text-gray-500 text-sm">
    &copy; 2025 Shelvean Kapita: kapita@tamu.edu <br>
    All code released under the MIT License. <br>
    Last modified: May 28, 2025
</div>
  </div>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false }
        ],
        throwOnError: false
      });
    });

    class Fraction {
      constructor(numerator, denominator = 1) {
        if (denominator === 0) throw new Error('Denominator cannot be zero');
        const absNum = Math.abs(numerator);
        const absDen = Math.abs(denominator);
        const gcd = this.gcd(absNum, absDen);
        this.numerator = (numerator < 0 ? -absNum : absNum) / gcd * Math.sign(denominator);
        this.denominator = absDen / gcd;
        if (this.denominator < 0) {
          this.numerator = -this.numerator;
          this.denominator = -this.denominator;
        }
      }

      gcd(a, b) {
        while (b !== 0) {
          const t = b;
          b = a % b;
          a = t;
        }
        return a;
      }

      static from(value) {
        return value instanceof Fraction ? value : new Fraction(value);
      }

      static fromDecimal(decimal, maxDenominator = 5000) {
        if (Number.isInteger(decimal)) return new Fraction(decimal);
        let sign = decimal < 0 ? -1 : 1;
        decimal = Math.abs(decimal);
        let bestNum = 1, bestDen = 1, bestError = Math.abs(decimal - 1);
        for (let den = 1; den <= maxDenominator; den++) {
          let num = Math.round(decimal * den);
          let error = Math.abs(decimal - num / den);
          if (error < bestError) {
            bestNum = num;
            bestDen = den;
            bestError = error;
          }
        }
        return new Fraction(sign * bestNum, bestDen);
      }
    }

    function generateMatrix() {
      var m = parseInt(document.getElementById("m").value, 10);
      var n = parseInt(document.getElementById("n").value, 10);
      if (isNaN(m) || m <= 0 || isNaN(n) || n <= 0) {
        alert("Please enter valid positive integers for m and n.");
        return;
      }
      var matrixDiv = document.getElementById("matrixInput");
      matrixDiv.innerHTML = "";
      var statementDiv = document.createElement("div");
      statementDiv.className = "text-center mb-4";
      var statement = document.createElement("div");
      statement.className = "latex";
      statement.textContent = "$$ \\text{Compute the generalized inverse } A^{\\dagger} \\text{ using SVD} $$";
      statementDiv.appendChild(statement);
      matrixDiv.appendChild(statementDiv);
      var aDiv = document.createElement("div");
      aDiv.className = "flex flex-col items-center";
      var aLabel = document.createElement("p");
      aLabel.className = "text-center font-semibold latex";
      aLabel.textContent = "Matrix $A$";
      aDiv.appendChild(aLabel);
      var aTable = document.createElement("table");
      aTable.className = "border-collapse";
      for (var i = 0; i < m; i++) {
        var tr = document.createElement("tr");
        for (var j = 0; j < n; j++) {
          var td = document.createElement("td");
          td.className = "p-1";
          var input = document.createElement("input");
          input.type = "text";
          input.className = "matrix-cell w-16 p-2 text-center border-2 border-gray-300 hover:border-blue-500 hover:border-4 rounded-md focus:outline-none";
          input.id = "cell_" + i + "_" + j;
          td.appendChild(input);
          tr.appendChild(td);
        }
        aTable.appendChild(tr);
      }
      aDiv.appendChild(aTable);
      matrixDiv.appendChild(aDiv);
      renderMathInElement(matrixDiv, {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false }
        ],
        throwOnError: false
      });
    }

    function clearAll() {
      document.getElementById("m").value = "";
      document.getElementById("n").value = "";
      document.getElementById("matrixInput").innerHTML = "";
      document.getElementById("result").innerHTML = "";
      document.getElementById("displayType").value = "fractions";
    }

    document.getElementById("clearBtn").addEventListener("click", clearAll);

    function parseFraction(str) {
      str = str.trim();
      if (str === "") return 0; // Treat empty entries as zeros
      if (str.includes('/')) {
        let parts = str.split('/');
        if (parts.length === 2) {
          let numerator = parseFloat(parts[0]);
          let denominator = parseFloat(parts[1]);
          if (!isNaN(numerator) && !isNaN(denominator) && denominator !== 0) {
            return numerator / denominator;
          }
        }
      }
      return parseFloat(str);
    }

    function readMatrix() {
      var m = parseInt(document.getElementById("m").value, 10);
      var n = parseInt(document.getElementById("n").value, 10);
      var A = [];
      for (var i = 0; i < m; i++) {
        var row = [];
        for (var j = 0; j < n; j++) {
          var cell = document.getElementById("cell_" + i + "_" + j);
          var value = cell.value.trim();
          var num = parseFraction(value);
          if (isNaN(num)) {
            alert("Please enter valid numbers or fractions in all cells.");
            return null;
          }
          row.push(num);
        }
        A.push(row);
      }
      return A;
    }

    function transposeMatrix(A) {
      const m = A.length;
      const n = A[0].length;
      const At = Array(n).fill().map(() => Array(m));
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          At[j][i] = A[i][j];
        }
      }
      return At;
    }

    function multiplyMatrices(A, B) {
      const m = A.length;
      const n = B[0].length;
      const p = A[0].length;
      const C = Array(m).fill().map(() => Array(n).fill(0));
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          for (let k = 0; k < p; k++) {
            C[i][j] += A[i][k] * B[k][j];
          }
        }
      }
      return C;
    }

    function identityMatrix(size) {
      const I = Array(size).fill().map(() => Array(size).fill(0));
      for (let i = 0; i < size; i++) {
        I[i][i] = 1;
      }
      return I;
    }

    function isZeroMatrix(A) {
      const m = A.length;
      const n = A[0].length;
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          if (Math.abs(A[i][j]) > 1e-10) {
            return false;
          }
        }
      }
      return true;
    }

    function lcm(a, b) {
      const gcd = (x, y) => (!y ? x : gcd(y, x % y));
      return Math.abs(a * b) / gcd(a, b);
    }

    function computeLCM(numbers) {
      if (numbers.length === 0) return 1;
      return numbers.reduce((a, b) => lcm(a, b));
    }

    function jacobiEigenDecomposition(S, maxIter = 100, tol = 1e-12) {
      const n = S.length;
      let V = identityMatrix(n);
      let A = S.map(row => [...row]);
      for (let iter = 0; iter < maxIter; iter++) {
        let maxVal = 0;
        let p = 0;
        let q = 1;
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            if (Math.abs(A[i][j]) > maxVal) {
              maxVal = Math.abs(A[i][j]);
              p = i;
              q = j;
            }
          }
        }
        if (maxVal < tol) break;
        const a_pp = A[p][p];
        const a_pq = A[p][q];
        const a_qq = A[q][q];
        const theta = 0.5 * Math.atan2(2 * a_pq, a_qq - a_pp);
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        for (let i = 0; i < n; i++) {
          if (i !== p && i !== q) {
            const a_ip = A[i][p];
            const a_iq = A[i][q];
            A[i][p] = c * a_ip - s * a_iq;
            A[p][i] = A[i][p];
            A[i][q] = s * a_ip + c * a_iq;
            A[q][i] = A[i][q];
          }
        }
        const a_pp_new = c * c * a_pp - 2 * s * c * a_pq + s * s * a_qq;
        const a_qq_new = s * s * a_pp + 2 * s * c * a_pq + c * c * a_qq;
        const a_pq_new = (c * c - s * s) * a_pq + s * c * (a_pp - a_qq);
        A[p][p] = a_pp_new;
        A[q][q] = a_qq_new;
        A[p][q] = a_pq_new;
        A[q][p] = a_pq_new;
        const V_p = V.map(row => row[p]);
        const V_q = V.map(row => row[q]);
        for (let i = 0; i < n; i++) {
          V[i][p] = c * V_p[i] - s * V_q[i];
          V[i][q] = s * V_p[i] + c * V_q[i];
        }
      }
      const eigenvalues = A.map((row, i) => row[i]);
      const indices = eigenvalues.map((val, idx) => idx).sort((a, b) => eigenvalues[b] - eigenvalues[a]);
      const sortedEigenvalues = indices.map(i => eigenvalues[i]);
      const sortedV = Array(n).fill().map(() => Array(n));
      for (let j = 0; j < n; j++) {
        const idx = indices[j];
        for (let i = 0; i < n; i++) {
          sortedV[i][j] = V[i][idx];
        }
      }
      return { eigenvalues: sortedEigenvalues, eigenvectors: sortedV };
    }

    function formatForLatex(val) {
      if (Math.abs(val) < 1e-10) {
        return "0";
      } else if (Math.abs(val - Math.round(val)) < 1e-10) {
        return Math.round(val).toString();
      } else {
        return parseFloat(val.toFixed(6)).toString();
      }
    }

    function matrixToDecimalLatex(M) {
      const rows = M.length;
      const cols = M[0].length;
      let latex = "\\begin{pmatrix}";
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const formattedVal = formatForLatex(M[i][j]);
          latex += formattedVal;
          if (j < cols - 1) latex += " & ";
        }
        if (i < rows - 1) latex += " \\\\ ";
      }
      latex += "\\end{pmatrix}";
      return latex;
    }

    function decimalToFraction(decimal, tol = 1e-10, maxDenom = 5000) {
      if (Math.abs(decimal) < tol) {
        return { numerator: 0, denominator: 1 };
      }
      const sign = decimal < 0 ? -1 : 1;
      decimal = Math.abs(decimal);
      let n0 = 0, d0 = 1, n1 = 1, d1 = 0;
      let x = decimal;
      while (d1 <= maxDenom) {
        const a = Math.floor(x);
        const n = a * n1 + n0;
        const d = a * d1 + d0;
        const error = Math.abs(decimal - n / d);
        if (error < tol || d > maxDenom) {
          const gcd = (a, b) => b ? gcd(b, a % b) : a;
          const common = gcd(Math.abs(n), d);
          return { numerator: sign * (n / common), denominator: d / common };
        }
        n0 = n1; d0 = d1; n1 = n; d1 = d;
        const fracPart = x - a;
        if (fracPart < tol) break;
        x = 1 / fracPart;
      }
      const gcd = (a, b) => b ? gcd(b, a % b) : a;
      const common = gcd(Math.abs(n1), d1);
      return { numerator: sign * (n1 / common), denominator: d1 / common };
    }

    function matrixToFractionLatex(M, tol = 1e-10, maxDenom = 5000) {
      const rows = M.length;
      const cols = M[0].length;
      const fractions = M.map(row => row.map(val => Fraction.fromDecimal(val, maxDenom)));
      let allSimple = true;
      const denominators = [];
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const frac = fractions[i][j];
          if (frac.numerator !== 0 && frac.denominator !== 1) {
            if (Math.abs(frac.numerator) >= 5000 || frac.denominator >= 5000) allSimple = false;
            denominators.push(frac.denominator);
          }
        }
      }
      if (allSimple && denominators.length > 0) {
        const commonDen = computeLCM(denominators);
        let latex = `\\dfrac{1}{${commonDen}} \\begin{pmatrix}`;
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            const frac = fractions[i][j];
            const scaledNum = frac.numerator * (commonDen / (frac.denominator || 1));
            latex += scaledNum.toString();
            if (j < cols - 1) latex += " & ";
          }
          if (i < rows - 1) latex += " \\\\[0.5em] ";
        }
        latex += "\\end{pmatrix}";
        return latex;
      }
      let latex = "\\begin{pmatrix}";
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const frac = fractions[i][j];
          const sign = frac.numerator < 0 ? "-" : "";
          const absNum = Math.abs(frac.numerator);
          if (frac.numerator === 0) {
            latex += "0";
          } else if (frac.denominator === 1) {
            latex += sign + absNum.toString();
          } else {
            latex += sign + "\\dfrac{" + absNum + "}{" + frac.denominator + "}";
          }
          if (j < cols - 1) latex += " & ";
        }
        if (i < rows - 1) latex += " \\\\[0.5em] ";
      }
      latex += "\\end{pmatrix}";
      return latex;
    }

    function computeSVD(A) {
      const m = A.length;
      const n = A[0].length;
      if (isZeroMatrix(A)) {
        const U = identityMatrix(m);
        const Sigma = Array(m).fill().map(() => Array(n).fill(0));
        const V = identityMatrix(n);
        const Vt = transposeMatrix(V);
        return { U, Sigma, Vt };
      }
      const At = transposeMatrix(A);
      const AtA = multiplyMatrices(At, A);
      const { eigenvalues: lambda_V, eigenvectors: V } = jacobiEigenDecomposition(AtA);
      const singularValues = lambda_V.map(val => Math.sqrt(Math.max(val, 0)));
      const sortedIndices = singularValues.map((val, idx) => idx).sort((a, b) => singularValues[b] - singularValues[a]);
      const sortedSingularValues = sortedIndices.map(i => singularValues[i]);
      const sorted_V = Array(n).fill().map(() => Array(n));
      for (let j = 0; j < n; j++) {
        const idx = sortedIndices[j];
        for (let i = 0; i < n; i++) {
          sorted_V[i][j] = V[i][idx];
        }
      }
      const Sigma = Array(m).fill().map(() => Array(n).fill(0));
      for (let i = 0; i < Math.min(m, n); i++) {
        Sigma[i][i] = sortedSingularValues[i];
      }
      const U = Array(m).fill().map(() => Array(m).fill(0));
      for (let i = 0; i < Math.min(m, n); i++) {
        if (Math.abs(Sigma[i][i]) > 1e-10) {
          const Av = Array(m).fill(0);
          for (let k = 0; k < m; k++) {
            for (let l = 0; l < n; l++) {
              Av[k] += A[k][l] * sorted_V[l][i];
            }
          }
          const sigma = Sigma[i][i];
          for (let k = 0; k < m; k++) {
            U[k][i] = Av[k] / sigma;
          }
        }
      }
      for (let i = Math.min(m, n); i < m; i++) {
        for (let j = 0; j < m; j++) {
          U[j][i] = i === j ? 1 : 0;
        }
      }
      const Vt = transposeMatrix(sorted_V);
      return { U, Sigma, Vt };
    }

    document.getElementById("calcBtn").addEventListener("click", function () {
      var resultDiv = document.getElementById("result");
      resultDiv.innerHTML = ""; // Reset result div
      var A = readMatrix();
      if (A === null) return;
      var m = A.length;
      var n = A[0].length;
      var { U, Sigma, Vt } = computeSVD(A);
      var min_mn = Math.min(m, n);
      var Sigma_plus = Array(n).fill().map(() => Array(m).fill(0));
      const singularValues = Array.from({length: min_mn}, (_, i) => Sigma[i][i]);
      const sigma_max = singularValues.length > 0 ? Math.max(...singularValues) : 0;
      const tol = 1e-8 * sigma_max;
      for (var i = 0; i < min_mn; i++) {
        if (Sigma[i][i] > tol) {
          Sigma_plus[i][i] = 1 / Sigma[i][i];
        }
      }
      var U_transpose = transposeMatrix(U);
      var V = transposeMatrix(Vt);
      var Sigma_plus_Ut = multiplyMatrices(Sigma_plus, U_transpose);
      var A_plus = multiplyMatrices(V, Sigma_plus_Ut);
      var displayType = document.getElementById("displayType").value;
      var A_plus_latex;
      if (displayType === "fractions") {
        A_plus_latex = matrixToFractionLatex(A_plus);
      } else {
        A_plus_latex = matrixToDecimalLatex(A_plus);
      }
      resultDiv.innerHTML = `
        <div class="latex">$$ A^{\\dagger} = ${A_plus_latex} $$</div>
      `;
      renderMathInElement(resultDiv, {
        delimiters: [{ left: "$$", right: "$$", display: true }],
        throwOnError: false
      });
    });

    function togglePseudoConcepts() {
      var content = document.getElementById("pseudoContent");
      var icon = document.getElementById("pseudoToggleIcon");
      if (content.style.display === "none") {
        content.style.display = "block";
        icon.textContent = "−";
      } else {
        content.style.display = "none";
        icon.textContent = "+";
      }
    }

    function loadExample() {
      document.getElementById("m").value = "3";
      document.getElementById("n").value = "2";
      generateMatrix();
      setTimeout(() => {
        // Example: 3x2 rank-deficient matrix
        document.getElementById("cell_0_0").value = "1";
        document.getElementById("cell_0_1").value = "2";
        document.getElementById("cell_1_0").value = "2";
        document.getElementById("cell_1_1").value = "4";
        document.getElementById("cell_2_0").value = "3";
        document.getElementById("cell_2_1").value = "6";
      }, 100);
    }
  </script>
</body>

</html>
