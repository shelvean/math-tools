<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="description" content="Gram-Schmidt Orthogonalization Calculator with Steps">
    <meta name="keywords" content="Gram-Schmidt, Orthogonal Basis, Orthonormal Basis, Projections, Linear Algebra">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LEQE004C92"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LEQE004C92');
</script>
    <meta charset="UTF-8" />
    <title>Gram-Schmidt Orthogonalization</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" />
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        .katex-display { margin: 1em 0; overflow-x: auto; }
        .latex { text-align: center; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center">
    <div class="nav-container w-full fixed top-0 z-10 bg-white shadow-md">
        <nav class="max-w-4xl mx-auto py-4">
            <ul class="flex justify-center gap-8">
                <li><a href="index.html" class="text-indigo-500 hover:text-blue-600 transition-colors font-bold text-xl">Home</a></li>
                <li><a href="teaching.html" class="text-indigo-500 hover:text-blue-600 transition-colors font-bold text-xl">Teaching</a></li>
                <li><a href="projects.html" class="text-indigo-500 hover:text-blue-600 transition-colors font-bold text-xl">Diff Eq</a></li>
                <li><a href="linear.html" class="text-indigo-500 hover:text-blue-600 transition-colors font-bold text-xl">Linear Algebra</a></li>
                <li><a href="numerical.html" class="text-indigo-500 hover:text-blue-600 transition-colors font-bold text-xl">Numerical Methods</a></li>
            </ul>
        </nav>
    </div>
    <div class="bg-white p-6 rounded-lg shadow-md max-w-4xl w-full mt-16">
        <h2 class="text-2xl font-bold mb-4 text-center text-gray-800 latex">Gram-Schmidt Orthogonalization</h2>
        <p class="text-center text-gray-600 mb-6 latex">Enter matrix dimensions $m \times n$, generate input matrix $A$, fill values, and calculate orthogonal and orthonormal bases using the Gram-Schmidt process.<br>(Columns of $A$ are the vectors. If linearly dependent, a subset will be used)</p>
        <div id="inputSection" class="bg-gray-50 p-4 rounded-lg mb-6 flex justify-center items-center space-x-4">
            <label for="rows" class="text-gray-700">Rows:</label>
            <input type="number" id="rows" min="1" required class="w-12 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
            <label for="cols" class="text-gray-700">Columns:</label>
            <input type="number" id="cols" min="1" required class="w-12 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
            <button type="button" onclick="generateMatrix()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 transition duration-300">Generate Matrix</button>
        </div>
        <div id="matrixInput" class="mb-6 overflow-x-auto"></div>
        <div class="flex justify-center space-x-4 mb-6">
            <button id="calcBtn" type="button" class="bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-600 transition duration-300 w-1/3">Calculate</button>
            <button id="clearBtn" type="button" class="bg-gray-500 text-white px-6 py-2 rounded hover:bg-gray-600 transition duration-300 w-1/3">Clear All</button>
        </div>
        <div id="result" class="mt-6 p-4 bg-gray-50 rounded-lg"></div>
        <div class="mt-6 border-t pt-4 text-center text-gray-500 text-sm">
            Â© 2025 Shelvean Kapita: kapita@tamu.edu <br>
            Last modified: December 16, 2025 <br>
            Licensed under the <a href="https://opensource.org/licenses/MIT" target="_blank">MIT License</a>.
        </div>
    </div>
    <script>
        // Initialize KaTeX rendering after scripts are loaded
        window.onload = function() {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "$", right: "$", display: false },
                    { left: "\\(", right: "\\)", display: false }
                ],
                throwOnError: false,
                errorCallback: function(err) { console.error("KaTeX rendering error:", err); }
            });
        };

        var currentDisplayMode = "fraction";  // Will auto-detect surds, else use decimals

        // FRACTION CLASS
        class Fraction {
            constructor(numerator, denominator = 1) {
                if (denominator === 0) throw new Error('Denominator cannot be zero');
                const absNum = Math.abs(numerator);
                const absDen = Math.abs(denominator);
                const gcd = this.gcd(absNum, absDen);
                this.numerator = (numerator < 0 ? -absNum : absNum) / gcd * Math.sign(denominator);
                this.denominator = absDen / gcd;
                if (this.denominator < 0) {
                    this.numerator = -this.numerator;
                    this.denominator = -this.denominator;
                }
            }
            gcd(a, b) {
                while (b !== 0) {
                    const t = b;
                    b = a % b;
                    a = t;
                }
                return a;
            }
            add(other) {
                other = Fraction.from(other);
                const commonDen = this.denominator * other.denominator;
                const num1 = this.numerator * other.denominator;
                const num2 = other.numerator * this.denominator;
                return new Fraction(num1 + num2, commonDen);
            }
            subtract(other) {
                other = Fraction.from(other);
                const commonDen = this.denominator * other.denominator;
                const num1 = this.numerator * other.denominator;
                const num2 = other.numerator * this.denominator;
                return new Fraction(num1 - num2, commonDen);
            }
            multiply(other) {
                other = Fraction.from(other);
                return new Fraction(this.numerator * other.numerator, this.denominator * other.denominator);
            }
            divide(other) {
                other = Fraction.from(other);
                if (other.numerator === 0) throw new Error('Division by zero');
                return new Fraction(this.numerator * other.denominator, this.denominator * other.numerator);
            }
            toString() {
                if (this.denominator === 1) return this.numerator.toString();
                return this.numerator + '/' + this.denominator;
            }
            valueOf() {
                return this.numerator / this.denominator;
            }
            static from(value) {
                if (value instanceof Fraction) return value;
                if (typeof value === 'number') return Fraction.fromDecimal(value);
                return new Fraction(value);
            }
            static fromDecimal(decimal, maxDenominator = 1000) {
                if (Number.isInteger(decimal)) return new Fraction(decimal);
                let sign = decimal < 0 ? -1 : 1;
                decimal = Math.abs(decimal);
                let bestNum = 1, bestDen = 1, bestError = Math.abs(decimal - 1);
                for (let den = 1; den <= maxDenominator; den++) {
                    let num = Math.round(decimal * den);
                    let error = Math.abs(decimal - num / den);
                    if (error < bestError) {
                        bestNum = num;
                        bestDen = den;
                        bestError = error;
                    }
                }
                return new Fraction(sign * bestNum, bestDen);
            }
        }

        function gcd(a, b) {
            a = Math.abs(a); b = Math.abs(b);
            while (b !== 0) {
                const t = b;
                b = a % b;
                a = t;
            }
            return a;
        }

        function gcdMultiple(nums) {
            if (nums.length === 0) return 1;
            return nums.reduce((acc, num) => gcd(acc, num), nums[0]);
        }

        function lcm(a, b) {
            if (a === 0 || b === 0) return 0;
            return Math.abs(a * b) / gcd(a, b);
        }

        function lcmMultiple(nums) {
            if (nums.length === 0) return 1;
            return nums.reduce((acc, num) => lcm(acc, num), nums[0]);
        }

        function isPerfectSquare(n) {
            if (n < 0) return false;
            const sqrt = Math.sqrt(n);
            return Number.isInteger(sqrt) && sqrt * sqrt === n;
        }

        // Pre-computed square roots for performance
        const SQRT_CACHE = Array.from({length: 51}, (_, i) => Math.sqrt(i));

        function toSurd(val) {
            if (Math.abs(val) < 1e-7) return "0";
            let sign = val < 0 ? "-" : "";
            val = Math.abs(val);
            let tol = 1e-8;
            // Reduced search space for performance
            for (let rden = 1; rden <= 12; rden++) {
                let scaled = val * rden;
                for (let a = 1; a <= 50; a++) {
                    let sq = SQRT_CACHE[a];
                    if (Math.abs(scaled - Math.round(scaled / sq) * sq) < tol) {
                        let coeff = Math.round(scaled / sq);
                        if (Math.abs(coeff) <= 500 && rden <= 500) {
                            if (a === 1) return sign + (coeff / rden).toString();
                            return sign + (coeff === 1 ? "" : coeff.toString()) + "\\sqrt{" + a + "}" + (rden === 1 ? "" : "/" + rden);
                        }
                    }
                }
            }
            return null;
        }

        function isRepeatingOrShortDecimal(val) {
            if (Math.abs(val) < 1e-7) return false;
            const frac = Fraction.fromDecimal(val, 100);
            const decimalVal = frac.numerator / frac.denominator;
            if (Math.abs(decimalVal - val) < 1e-8 && Math.abs(frac.numerator) <= 500 && frac.denominator <= 500) {
                return frac;
            }
            return false;
        }

        function canRepresentAsSurdOrFraction(val) {
            if (Math.abs(val) < 1e-7) return true;
            const frac = isRepeatingOrShortDecimal(val);
            if (frac) return true;
            const surd = toSurd(val);
            if (surd) return true;
            return false;
        }

        function generateMatrix() {
            var m = parseInt(document.getElementById("rows").value, 10);
            var n = parseInt(document.getElementById("cols").value, 10);
            if (isNaN(m) || isNaN(n) || m <= 0 || n <= 0) {
                alert("Please enter valid positive integers for matrix dimensions.");
                return;
            }
            var matrixDiv = document.getElementById("matrixInput");
            matrixDiv.innerHTML = "";
            var statementDiv = document.createElement("div");
            statementDiv.className = "text-center mb-4";
            var statement = document.createElement("div");
            statement.className = "latex";
            statement.textContent = `$$ \\text{Gram-Schmidt orthogonalization for } ${m} \\times ${n} \\text{ matrix } A $$`;
            statementDiv.appendChild(statement);
            matrixDiv.appendChild(statementDiv);
            var aDiv = document.createElement("div");
            aDiv.className = "flex flex-col items-center";
            var aLabel = document.createElement("p");
            aLabel.className = "text-center font-semibold latex";
            aLabel.textContent = "Matrix $A$";
            aDiv.appendChild(aLabel);
            var aTable = document.createElement("table");
            aTable.className = "border-collapse";
            for (var i = 0; i < m; i++) {
                var tr = document.createElement("tr");
                for (var j = 0; j < n; j++) {
                    var td = document.createElement("td");
                    td.className = "p-1";
                    var input = document.createElement("input");
                    input.type = "text";
                    input.className = "matrix-cell w-16 p-2 text-center border-2 border-gray-300 hover:border-blue-500 hover:border-4 rounded-md focus:outline-none";
                    input.id = "cell_" + i + "_" + j;
                    td.appendChild(input);
                    tr.appendChild(td);
                }
                aTable.appendChild(tr);
            }
            aDiv.appendChild(aTable);
            matrixDiv.appendChild(aDiv);
            renderMathInElement(matrixDiv, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "$", right: "$", display: false }
                ],
                throwOnError: false,
                errorCallback: function(err) { console.error("KaTeX rendering error in matrixInput:", err); }
            });
        }

        function clearAll() {
            document.getElementById("rows").value = "";
            document.getElementById("cols").value = "";
            document.getElementById("matrixInput").innerHTML = "";
            document.getElementById("result").innerHTML = "";
            currentDisplayMode = "fraction";
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "$", right: "$", display: false }
                ],
                throwOnError: false,
                errorCallback: function(err) { console.error("KaTeX rendering error in clearAll:", err); }
            });
        }
        document.getElementById("clearBtn").addEventListener("click", clearAll);

        function parseFraction(str) {
            str = str.trim();
            if (str === "") return new Fraction(0);
            if (str.match(/^-?\d*\.?\d+$/)) {
                let num = parseFloat(str);
                if (!isNaN(num)) {
                    return Fraction.fromDecimal(num);
                }
            }
            if (str.includes('/')) {
                let parts = str.split('/');
                if (parts.length === 2) {
                    let numerator = parseInt(parts[0], 10);
                    let denominator = parseInt(parts[1], 10);
                    if (!isNaN(numerator) && !isNaN(denominator) && denominator !== 0) {
                        return new Fraction(numerator, denominator);
                    }
                }
            } else {
                let num = parseInt(str, 10);
                if (!isNaN(num)) {
                    return new Fraction(num);
                }
            }
            alert("Please enter valid integers, fractions, or decimals in all matrix cells.");
            return null;
        }

        function readMatrix() {
            var m = parseInt(document.getElementById("rows").value, 10);
            var n = parseInt(document.getElementById("cols").value, 10);
            if (isNaN(m) || isNaN(n) || m <= 0 || n <= 0) return null;

            // Pre-cache all DOM elements to avoid repeated lookups
            var elements = [];
            for (var i = 0; i < m; i++) {
                elements[i] = [];
                for (var j = 0; j < n; j++) {
                    elements[i][j] = document.getElementById("cell_" + i + "_" + j);
                    if (!elements[i][j]) {
                        alert("Matrix input fields not found. Please generate the matrix first.");
                        return null;
                    }
                }
            }

            // Now read the values
            var matrix = [];
            for (var i = 0; i < m; i++) {
                var row = [];
                for (var j = 0; j < n; j++) {
                    var value = elements[i][j].value.trim();
                    var num = parseFraction(value);
                    if (num === null) return null;
                    row.push(num);
                }
                matrix.push(row);
            }
            return matrix;
        }

        function formatNumber(num, useDfrac = false, returnSign = false) {
            if (num instanceof Fraction) {
                if (currentDisplayMode === "decimal") {
                    return parseFloat(num.valueOf().toFixed(3)).toString();
                } else {
                    if (returnSign) {
                        return num.numerator < 0 ? '-' : '';
                    }
                    if (num.numerator === 0) return '0';
                    const sign = num.numerator < 0 ? '-' : '';
                    const absNum = Math.abs(num.numerator);
                    if (num.denominator === 1) return `${sign}${absNum}`;
                    if (useDfrac) {
                        return `${sign}\\dfrac{${absNum}}{${num.denominator}}`;
                    }
                    return `${sign}${absNum}/${num.denominator}`;
                }
            } else {
                const epsilon = 1e-10;
                if (Math.abs(num - Math.round(num)) < epsilon) {
                    return Math.round(num).toString();
                }
                return parseFloat(num.toFixed(3)).toString();
            }
        }

        function formatScalarForLatex(formatted) {
            return formatted;
        }

        function vectorToLatex(vec, isNormalized = false, norm2 = null) {
            const absNums = vec.map(f => Math.abs(f.numerator));
            const vecGcd = gcdMultiple(absNums);
            let adjustedVec = vec;
            if (!isNormalized && vecGcd > 1) {
                adjustedVec = vec.map(f => f.divide(new Fraction(vecGcd)));
            }
            let latex = "\\begin{bmatrix}\n";
            latex += adjustedVec.map(function(num) {
                const formatted = formatNumber(num, true);
                return formatScalarForLatex(formatted);
            }).join(" \\\\ \n");
            latex += "\n\\end{bmatrix}";
            if (isNormalized && vecGcd > 1) {
                latex = `${formatNumber(new Fraction(vecGcd), true)} ${latex}`;
            }
            return latex;
        }

        function basisToLatex(basis, isOrthonormal = false, labelPrefix = "") {
            if (!basis.length) {
                return "\\{ \\mathbf{0} \\}";
            }
            let vectorLabels = "";
            if (labelPrefix !== "") {
                const labels = basis.map((_, i) => `${labelPrefix}_{${i+1}}`).join(", ");
                vectorLabels = `\\{ ${labels} \\} = `;
            }
            if (isOrthonormal) {
                const vectorsLatex = basis.map(function(item, index) {
                    const vec = item.vector;
                    const absNums = vec.map(f => Math.abs(f.numerator));
                    const vecGcd = gcdMultiple(absNums);
                    let adjustedVec = vec;
                    let norm2Adjusted = item.norm2;
                    if (vecGcd > 1) {
                        adjustedVec = vec.map(f => f.divide(new Fraction(vecGcd)));
                        norm2Adjusted = item.norm2.divide(new Fraction(vecGcd * vecGcd));
                    }
                    const normNum = norm2Adjusted.numerator;
                    const normDen = norm2Adjusted.denominator;
                    const isSquareFraction = isPerfectSquare(normNum) && isPerfectSquare(normDen);
                    let scalarLatex;
                    if (isSquareFraction) {
                        let sqrtNum = Math.sqrt(normNum);
                        let sqrtDen = Math.sqrt(normDen);
                        const gcdSD = gcd(sqrtDen, sqrtNum);
                        sqrtNum /= gcdSD;
                        sqrtDen /= gcdSD;
                        if (sqrtDen === 1) {
                            scalarLatex = `\\dfrac{1}{${sqrtNum}}`;
                        } else {
                            scalarLatex = `\\dfrac{${sqrtDen}}{${sqrtNum}}`;
                        }
                    } else {
                        const normLatex = normDen === 1 ? normNum.toString() : `\\dfrac{${normNum}}{${normDen}}`;
                        scalarLatex = `\\dfrac{1}{\\sqrt{${normLatex}}}`;
                    }
                    return `${scalarLatex} ${vectorToLatex(adjustedVec, true, norm2Adjusted)}`;
                }).join(",\\quad ");
                return vectorLabels + "\\left\\{ " + vectorsLatex + " \\right\\}";
            } else {
                const vectorsLatex = basis.map(function(item) {
                    return vectorToLatex(item);
                }).join(",\\quad ");
                return vectorLabels + "\\left\\{ " + vectorsLatex + " \\right\\}";
            }
        }

        function dot(u, v) {
            let sum = new Fraction(0);
            for (let i = 0; i < u.length; i++) {
                sum = sum.add(u[i].multiply(v[i]));
            }
            return sum;
        }

        function scalarMult(s, v) {
            return v.map(val => s.multiply(val));
        }

        function subtract(u, v) {
            return u.map((val, idx) => val.subtract(v[idx]));
        }

        function computeGramSchmidt(origMatrix) {
            const m = origMatrix.length;
            const n = origMatrix[0].length;
            // Optimized: extract column vectors without intermediate null array
            const vectors = [];
            for (let j = 0; j < n; j++) {
                const col = [];
                for (let i = 0; i < m; i++) {
                    col.push(origMatrix[i][j]);
                }
                vectors.push(col);
            }
            const steps = [];
            steps.push({desc: "Initial Basis", basis: vectors, type: "textbasis", label: "\\mathbf{v}"});
            const orthogonal = [];
            let dependent = false;
            for (let j = 0; j < n; j++) {
                let u = vectors[j].slice();
                const u_index = orthogonal.length + 1;
                let formula = `\\mathbf{u}_{${u_index}} = \\mathbf{v}_{${j + 1}}`;
                let abstractRhs = `\\mathbf{v}_{${j + 1}}`;
                let simplifiedRhs = `\\mathbf{v}_{${j + 1}}`;
                const innerTerms = [];
                for (let i = 0; i < orthogonal.length; i++) {
                    const innerVU = dot(vectors[j], orthogonal[i]);
                    const innerUU = dot(orthogonal[i], orthogonal[i]);
                    if (innerUU.numerator === 0) continue;
                    const coef = innerVU.divide(innerUU);
                    if (coef.numerator === 0) continue;
                    const formattedCoef = formatNumber(coef, true);
                    const innerTerm = `\\dfrac{\\langle \\mathbf{v}_{${j+1}}, \\mathbf{u}_{${i+1}} \\rangle}{\\langle \\mathbf{u}_{${i+1}}, \\mathbf{u}_{${i+1}} \\rangle} \\mathbf{u}_{${i+1}}`;
                    innerTerms.push(innerTerm);
                    const effectiveCoef = coef;  // positive for subtraction
                    const termSign = effectiveCoef.numerator >= 0 ? ' - ' : ' + ';
                    const absNumer = Math.abs(effectiveCoef.numerator);
                    const absEffective = new Fraction(absNumer, effectiveCoef.denominator);
                    const formattedAbsCoef = formatNumber(absEffective, true);
                    const uTerm = `${formattedAbsCoef} \\mathbf{u}_{${i + 1}}`;
                    simplifiedRhs += termSign + uTerm;
                    u = subtract(u, scalarMult(coef, orthogonal[i]));
                }
                const norm2U = dot(u, u);
                if (norm2U.numerator === 0) {
                    steps.push({ desc: "Vector ", formula: `\\mathbf{v}_{${j + 1}}`, suffix: " is linearly dependent. Skipping.", type: "text" });
                    dependent = true;
                    continue;
                }
                const dens = u.map(frac => frac.denominator);
                const lcm_den = lcmMultiple(dens);
                const scale = new Fraction(lcm_den);
                u = u.map(frac => frac.multiply(scale));
                const absNums = u.map(f => Math.abs(f.numerator));
                const vecGcd = gcdMultiple(absNums);
                if (vecGcd > 1) {
                    u = u.map(f => f.divide(new Fraction(vecGcd)));
                }
                if (innerTerms.length > 0) {
                    const subtractTerms = innerTerms.join(' - ');
                    abstractRhs += ` - ${subtractTerms}`;
                    formula = `\\mathbf{u}_{${u_index}} = ${abstractRhs} = ${simplifiedRhs}`;
                } else {
                    formula = `\\mathbf{u}_{${u_index}} = \\mathbf{v}_{${j + 1}}`;
                }
                steps.push({desc: formula, type: "latex"});
                steps.push({desc: `\\mathbf{u}_{${u_index}} = `, uvec: u, type: "vec"});
                orthogonal.push(u);
            }
            steps.push({desc: "Orthogonal Basis (not normalized)", basis: orthogonal, type: "textbasis", label: "\\mathbf{u}"});
            const orthonormal = orthogonal.map(u => ({ vector: u, norm2: dot(u, u) }));
            steps.push({desc: "Orthonormal Basis", basis: orthonormal, type: "textorthonormal", label: "\\mathbf{q}"});
            return { steps, dependent };
        }

        function renderSteps(steps, dependent) {
            const resultDiv = document.getElementById("result");
            resultDiv.innerHTML = "";

            // Top: Orthonormal basis - centered and prominent
            const orthonormalStep = steps.find(step => step.type === "textorthonormal");
            if (orthonormalStep) {
                const orthonormalDiv = document.createElement("div");
                orthonormalDiv.className = "mt-6 mb-8 text-center";
                const orthonormalTitle = document.createElement("h3");
                orthonormalTitle.className = "text-2xl font-bold text-gray-800 mb-4";
                orthonormalTitle.textContent = orthonormalStep.desc;
                orthonormalDiv.appendChild(orthonormalTitle);
                const orthonormalMath = document.createElement("div");
                orthonormalMath.className = "latex mb-4 text-center";
                orthonormalMath.textContent = "$$" + basisToLatex(orthonormalStep.basis, true, "\\mathbf{q}") + "$$";
                orthonormalDiv.appendChild(orthonormalMath);
                resultDiv.appendChild(orthonormalDiv);
            }

            if (dependent) {
                const note = document.createElement("p");
                note.className = "text-red-700 font-semibold mb-4 text-center mt-4";
                note.textContent = "Note: Some vectors were linearly dependent; a subset was used for the basis.";
                resultDiv.appendChild(note);
            }

            // Show initial basis
            const initialDiv = document.createElement("div");
            initialDiv.className = "mt-8 mb-6 text-center";
            const initialTitle = document.createElement("h3");
            initialTitle.className = "text-xl font-semibold text-gray-800 mb-3";
            initialTitle.textContent = steps[0].desc;
            initialDiv.appendChild(initialTitle);
            const initialMath = document.createElement("div");
            initialMath.className = "latex mb-4 text-center";
            const numVectors = steps[0].basis.length;
            const vectorLabels = numVectors > 0 ? `\\{ ${Array.from({length: numVectors}, (_, i) => `\\mathbf{v}_{${i+1}}`).join(", ")} \\} = ` : "";
            initialMath.textContent = "$$" + vectorLabels + basisToLatex(steps[0].basis, false, "") + "$$";
            initialDiv.appendChild(initialMath);
            resultDiv.appendChild(initialDiv);

            // Transformation steps
            const stepsHeader = document.createElement("h3");
            stepsHeader.className = "text-xl font-semibold text-gray-800 mb-4 mt-8 text-center";
            stepsHeader.textContent = "Transformation Steps:";
            resultDiv.appendChild(stepsHeader);

            // Detailed steps (excluding the final bases)
            for (let i = 1; i < steps.length; i++) {
                const step = steps[i];
                if (step.type === "textbasis" || step.type === "textorthonormal") continue;

                const stepDiv = document.createElement("div");
                stepDiv.className = "mt-6";

                if (step.type === "latex") {
                    const description = document.createElement("div");
                    description.className = "latex mb-2";
                    description.textContent = "$$" + step.desc + "$$";
                    stepDiv.appendChild(description);
                } else if (step.type === "vec") {
                    const vecDiv = document.createElement("div");
                    vecDiv.className = "latex mb-2";
                    vecDiv.textContent = "$$" + step.desc + vectorToLatex(step.uvec) + "$$";
                    stepDiv.appendChild(vecDiv);
                } else if (step.type === "text") {
                    const description = document.createElement("div");
                    description.className = "latex mb-2 text-red-700 font-semibold";
                    description.innerHTML = `${step.desc}<span class="katex-inline">\\(${step.formula}\\)</span>${step.suffix}`;
                    stepDiv.appendChild(description);
                }
                resultDiv.appendChild(stepDiv);
            }

            const orthoStep = steps.find(step => step.desc === "Orthogonal Basis (not normalized)");
            if (orthoStep) {
                const orthoDiv = document.createElement("div");
                orthoDiv.className = "mt-8";
                const orthoTitle = document.createElement("h3");
                orthoTitle.className = "text-lg font-semibold text-gray-800 mb-2 text-center";
                orthoTitle.textContent = orthoStep.desc;
                orthoDiv.appendChild(orthoTitle);
                const orthoMath = document.createElement("div");
                orthoMath.className = "latex mb-4";
                orthoMath.textContent = "$$" + basisToLatex(orthoStep.basis, false, "\\mathbf{u}") + "$$";
                orthoDiv.appendChild(orthoMath);
                resultDiv.appendChild(orthoDiv);
            }

            renderMathInElement(resultDiv, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "$", right: "$", display: false },
                    { left: "\\(", right: "\\)", display: false }
                ],
                throwOnError: false,
                errorCallback: function(err) { console.error("KaTeX rendering error in result:", err); }
            });
        }

        document.getElementById("calcBtn").addEventListener("click", function() {
            const matrix = readMatrix();
            if (matrix !== null) {
                const computation = computeGramSchmidt(matrix);
                renderSteps(computation.steps, computation.dependent);
            }
        });
    </script>
</body>
</html>

