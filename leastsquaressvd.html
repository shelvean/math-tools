<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="description" content="A web-based tool to compute the Least Squares Solution of a matrix system Ax ≈ b using Singular Value Decomposition (SVD) and the Pseudoinverse. Input the matrix dimensions, values for matrix A and vector b (empty spaces treated as 0), and calculate the solution x = A⁺b, with options for decimal or fraction output." />
  <meta name="keywords" content="least squares, pseudoinverse, SVD, matrix solver, linear algebra, numerical analysis" />
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LEQE004C92"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LEQE004C92');
</script>
  <title>Least Squares Solver using SVD and the Pseudoinverse</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" />
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjs@14.6.0/lib/browser/math.js"></script>
  <style>
    .katex-display { margin: 1em 0; overflow-x: auto; }
    body { padding-left: 12.5vw; padding-right: 12.5vw; }
    @media (max-width: 900px) { body { padding-left: 3vw; padding-right: 3vw; }}
    .matrix-cell { width: 4rem; padding: 0.5rem; text-align: center; border: 2px solid #d1d5db; border-radius: 0.375rem; }
    .matrix-cell:hover { border-color: #3b82f6; border-width: 3px; }
    .matrix-cell:focus { outline: none; border-color: #3b82f6; }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center">
  <div class="fixed top-0 left-0 w-full bg-white shadow-md z-10">
    <div class="max-w-4xl mx-auto px-4 py-2">
      <ul class="flex justify-center space-x-4">
        <li><a href="index.html" class="text-indigo-600 hover:text-blue-600 font-bold text-xl">Home</a></li>
        <li><a href="teaching.html" class="text-indigo-600 hover:text-blue-600 font-bold text-xl">Teaching</a></li>
        <li><a href="projects.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Diff Eq</a></li>
        <li><a href="linear.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Linear Algebra</a></li>
        <li><a href="numerical.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Numerical Methods</a></li>
      </ul>
    </div>
  </div>
  <div class="bg-white p-6 rounded-lg shadow-md max-w-4xl w-full mt-16">
    <h2 class="text-2xl font-bold mb-4 text-center text-gray-800">Least Squares Solver using SVD and the Pseudoinverse</h2>
    <p class="text-center text-gray-600 mb-6">
      Compute the least squares solution $\mathbf{x} = A^{\dagger}\mathbf{b}$ using the <strong>Moore-Penrose pseudoinverse</strong>.<br>
      <span class="text-sm">Most robust method for rank-deficient and ill-conditioned matrices.</span>
    </p>

    <!-- About Least Squares SVD - Collapsible -->
    <div class="bg-blue-50 border border-blue-300 rounded-lg mb-6 overflow-hidden">
      <button onclick="toggleSVDConcepts()" class="w-full p-4 text-left flex items-center justify-between hover:bg-blue-100 transition duration-200">
        <h3 class="font-bold text-lg text-blue-800">About Least Squares via SVD</h3>
        <span id="svdToggleIcon" class="text-blue-800 font-bold text-xl">−</span>
      </button>
      <div id="svdContent" class="px-4 pb-4">
        <p class="text-gray-700 mb-2 text-sm">The <strong>SVD-based method</strong> uses the pseudoinverse to solve least squares problems:</p>
        <p class="text-center mb-3">$ \mathbf{x} = A^{\dagger}\mathbf{b} $</p>
        <p class="text-gray-700 mb-2"><strong>How it works:</strong></p>
        <p class="text-gray-700 mb-2 text-sm">Compute SVD: $A = U\Sigma V^T$, then form the pseudoinverse:</p>
        <p class="text-center mb-3">$ A^{\dagger} = V\Sigma^{\dagger}U^T $</p>
        <p class="text-gray-700 mb-2 text-sm">where $\Sigma^{\dagger}$ inverts nonzero singular values and transposes.</p>
        <p class="text-gray-700 mb-2"><strong>Advantages:</strong></p>
        <ul class="text-gray-700 text-sm ml-6 list-disc">
          <li>Handles rank-deficient matrices automatically</li>
          <li>Most numerically stable method</li>
          <li>Provides minimum-norm solution for underdetermined systems</li>
          <li>Reveals condition number and numerical rank</li>
        </ul>
      </div>
    </div>

    <div class="bg-gray-50 p-4 rounded-lg mb-6 flex justify-center items-center space-x-4">
      <span class="text-gray-700">Rows $m$:</span>
      <input type="number" id="m" min="1" required class="w-16 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
      <span class="text-gray-700">Columns $n$:</span>
      <input type="number" id="n" min="1" required class="w-16 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
      <button type="button" onclick="generateMatrix()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 transition duration-300">Generate Matrix</button>
      <button type="button" onclick="loadExample()" class="bg-purple-500 text-white px-4 py-2 rounded hover:bg-purple-600 transition duration-300">Load Example</button>
    </div>
    <div class="flex justify-center mb-6 space-x-6">
      <span class="text-gray-700">Final Output as:</span>
      <label class="flex items-center">
        <input type="radio" name="displayMode" value="fractions" checked class="mr-2">
        <span>Fractions</span>
      </label>
      <label class="flex items-center">
        <input type="radio" name="displayMode" value="decimals" class="mr-2">
        <span>Decimals</span>
      </label>
    </div>
    <div id="matrixInput" class="mb-6 overflow-x-auto"></div>
    <div class="flex justify-center space-x-4 mb-6">
      <button id="calcBtn" type="button" class="bg-blue-500 text-white px-6 py-2 rounded hover:bg-blue-600 transition duration-300 w-1/3">Compute Solution</button>
      <button id="clearBtn" type="button" class="bg-gray-500 text-white px-6 py-2 rounded hover:bg-gray-600 transition duration-300 w-1/3">Clear All</button>
    </div>
    <div id="result" class="mt-6 p-4 bg-gray-50 rounded-lg"></div>
    <div class="mt-6 border-t pt-4 text-center text-gray-500 text-sm">
      &copy; 2025 Shelvean Kapita: kapita@tamu.edu <br>
      All code released under the MIT License. <br>
      Last modified: December 18, 2025
    </div>
  </div>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false }
        ],
        throwOnError: false,
        strict: false
      });
    });

    function toggleSVDConcepts() {
      var content = document.getElementById("svdContent");
      var icon = document.getElementById("svdToggleIcon");
      if (content.style.display === "none") {
        content.style.display = "block";
        icon.textContent = "−";
      } else {
        content.style.display = "none";
        icon.textContent = "+";
      }
    }

    function loadExample() {
      document.getElementById("m").value = "3";
      document.getElementById("n").value = "2";
      generateMatrix();
      setTimeout(() => {
        // Example: rank-deficient overdetermined system
        document.getElementById("A_0_0").value = "1";
        document.getElementById("A_0_1").value = "2";
        document.getElementById("A_1_0").value = "2";
        document.getElementById("A_1_1").value = "4";
        document.getElementById("A_2_0").value = "3";
        document.getElementById("A_2_1").value = "6";
        document.getElementById("b_0").value = "1";
        document.getElementById("b_1").value = "3";
        document.getElementById("b_2").value = "4";
      }, 100);
    }

    let currentDisplayMode = "fractions";
    document.querySelectorAll('input[name="displayMode"]').forEach(function(radio) {
      radio.addEventListener("change", function () {
        currentDisplayMode = this.value;
      });
    });

    function generateMatrix() {
      var m = parseInt(document.getElementById("m").value, 10);
      var n = parseInt(document.getElementById("n").value, 10);
      if (isNaN(m) || m <= 0 || isNaN(n) || n <= 0) {
        alert("Please enter valid positive integers for m and n.");
        return;
      }
      var matrixDiv = document.getElementById("matrixInput");
      matrixDiv.innerHTML = "";
      var statementDiv = document.createElement("div");
      statementDiv.className = "text-center mb-4";
      var statement = document.createElement("div");
      statement.className = "latex";
      statement.textContent = `$$ \\text{Compute the least squares solution } x = A^{\\dagger} b \\text{ using SVD} $$`;
      statementDiv.appendChild(statement);
      var emptyStatement = document.createElement("div");
      emptyStatement.className = "latex";
      emptyStatement.textContent = `$$ \\text{(empty spaces are treated as 0)} $$`;
      statementDiv.appendChild(emptyStatement);
      matrixDiv.appendChild(statementDiv);
      var flexDiv = document.createElement("div");
      flexDiv.className = "flex justify-center space-x-8";
      var aDiv = document.createElement("div");
      aDiv.className = "flex flex-col items-center";
      var aLabel = document.createElement("p");
      aLabel.className = "text-center font-semibold latex";
      aLabel.textContent = "Matrix $A$";
      aDiv.appendChild(aLabel);
      var aTable = document.createElement("table");
      aTable.className = "border-collapse";
      for (var i = 0; i < m; i++) {
        var tr = document.createElement("tr");
        for (var j = 0; j < n; j++) {
          var td = document.createElement("td");
          td.className = "p-1";
          var input = document.createElement("input");
          input.type = "text";
          input.className = "matrix-cell";
          input.id = "A_" + i + "_" + j;
          td.appendChild(input);
          tr.appendChild(td);
        }
        aTable.appendChild(tr);
      }
      aDiv.appendChild(aTable);
      flexDiv.appendChild(aDiv);
      var bDiv = document.createElement("div");
      bDiv.className = "flex flex-col items-center";
      var bLabel = document.createElement("p");
      bLabel.className = "text-center font-semibold latex";
      bLabel.textContent = "Vector $b$";
      bDiv.appendChild(bLabel);
      var bTable = document.createElement("table");
      bTable.className = "border-collapse";
      for (var i = 0; i < m; i++) {
        var tr = document.createElement("tr");
        var td = document.createElement("td");
        td.className = "p-1";
        var input = document.createElement("input");
        input.type = "text";
        input.className = "matrix-cell";
        input.id = "b_" + i;
        td.appendChild(input);
        tr.appendChild(td);
        bTable.appendChild(tr);
      }
      bDiv.appendChild(bTable);
      flexDiv.appendChild(bDiv);
      matrixDiv.appendChild(flexDiv);
      renderMathInElement(matrixDiv, {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "$", right: "$", display: false }
        ],
        throwOnError: false
      });
    }

    function clearAll() {
      document.getElementById("m").value = "";
      document.getElementById("n").value = "";
      var matrixDiv = document.getElementById("matrixInput");
      if (matrixDiv) { matrixDiv.innerHTML = ""; }
      var resultDiv = document.getElementById("result");
      if (resultDiv) { resultDiv.innerHTML = ""; }
      document.querySelector('input[name="displayMode"][value="fractions"]').checked = true;
      currentDisplayMode = "fractions";
    }
    document.getElementById("clearBtn").addEventListener("click", clearAll);

    function parseFraction(str) {
      str = str.trim();
      if (str === '') return 0;
      try {
        let evaluated = math.evaluate(str);
        if (typeof evaluated === 'number') { return evaluated; }
        else { return 0; }
      } catch (e) {
        alert("Please enter valid numbers, fractions, or mathematical expressions in all cells.");
        return null;
      }
    }

    function readMatrix() {
      var m = parseInt(document.getElementById("m").value, 10);
      var n = parseInt(document.getElementById("n").value, 10);
      if (isNaN(m) || m <= 0 || isNaN(n) || n <= 0) {
        alert("Please enter valid positive integers for m and n.");
        return null;
      }
      var A = [];
      for (var i = 0; i < m; i++) {
        var row = [];
        for (var j = 0; j < n; j++) {
          var cell = document.getElementById("A_" + i + "_" + j);
          if (!cell) {
            alert("Error: Matrix input field A_" + i + "_" + j + " not found.");
            return null;
          }
          var value = cell.value.trim();
          var num = parseFraction(value);
          if (num === null) { return null; }
          row.push(num);
        }
        A.push(row);
      }
      return A;
    }

    function readVectorB() {
      var m = parseInt(document.getElementById("m").value, 10);
      var b = [];
      for (var i = 0; i < m; i++) {
        var cell = document.getElementById("b_" + i);
        if (!cell) {
          alert("Error: Vector input field b_" + i + " not found.");
          return null;
        }
        var value = cell.value.trim();
        var num = parseFraction(value);
        if (num === null) { return null; }
        b.push([num]);
      }
      return b;
    }

    function transposeMatrix(A) {
      const m = A.length;
      const n = A[0].length;
      const At = Array(n).fill().map(() => Array(m));
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          At[j][i] = A[i][j];
        }
      }
      return At;
    }

    function multiplyMatrices(A, B) {
      const m = A.length;
      const n = B[0].length;
      const p = A[0].length;
      const C = Array(m).fill().map(() => Array(n).fill(0));
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          for (let k = 0; k < p; k++) {
            C[i][j] += A[i][k] * B[k][j];
          }
        }
      }
      return C;
    }

    function identityMatrix(size) {
      const I = Array(size).fill().map(() => Array(size).fill(0));
      for (let i = 0; i < size; i++) {
        I[i][i] = 1;
      }
      return I;
    }

    function isZeroMatrix(A) {
      const m = A.length;
      const n = A[0].length;
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          if (Math.abs(A[i][j]) > 1e-10) {
            return false;
          }
        }
      }
      return true;
    }

    function jacobiEigenDecomposition(S, maxIter = 100, tol = 1e-12) {
      const n = S.length;
      let V = identityMatrix(n);
      let A = S.map(row => [...row]);
      for (let iter = 0; iter < maxIter; iter++) {
        let maxVal = 0;
        let p = 0;
        let q = 1;
        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            if (Math.abs(A[i][j]) > maxVal) {
              maxVal = Math.abs(A[i][j]);
              p = i;
              q = j;
            }
          }
        }
        if (maxVal < tol) break;
        const a_pp = A[p][p];
        const a_pq = A[p][q];
        const a_qq = A[q][q];
        const theta = 0.5 * Math.atan2(2 * a_pq, a_qq - a_pp);
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        for (let i = 0; i < n; i++) {
          if (i !== p && i !== q) {
            const a_ip = A[i][p];
            const a_iq = A[i][q];
            A[i][p] = c * a_ip - s * a_iq;
            A[p][i] = A[i][p];
            A[i][q] = s * a_ip + c * a_iq;
            A[q][i] = A[i][q];
          }
        }
        const a_pp_new = c * c * a_pp - 2 * s * c * a_pq + s * s * a_qq;
        const a_qq_new = s * s * a_pp + 2 * s * c * a_pq + c * c * a_qq;
        const a_pq_new = (c * c - s * s) * a_pq + s * c * (a_pp - a_qq);
        A[p][p] = a_pp_new;
        A[q][q] = a_qq_new;
        A[p][q] = a_pq_new;
        A[q][p] = a_pq_new;
        const V_p = V.map(row => row[p]);
        const V_q = V.map(row => row[q]);
        for (let i = 0; i < n; i++) {
          V[i][p] = c * V_p[i] - s * V_q[i];
          V[i][q] = s * V_p[i] + c * V_q[i];
        }
      }
      const eigenvalues = A.map((row, i) => row[i]);
      const indices = eigenvalues.map((val, idx) => idx).sort((a, b) => eigenvalues[b] - eigenvalues[a]);
      const sortedEigenvalues = indices.map(i => eigenvalues[i]);
      const sortedV = Array(n).fill().map(() => Array(n));
      for (let j = 0; j < n; j++) {
        const idx = indices[j];
        for (let i = 0; i < n; i++) {
          sortedV[i][j] = V[i][idx];
        }
      }
      return { eigenvalues: sortedEigenvalues, eigenvectors: sortedV };
    }

    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      while (b) {
        let t = b;
        b = a % b;
        a = t;
      }
      return a;
    }

    function lcm(a, b) {
      return (a * b) / gcd(a, b);
    }

    function decimalToFraction(val, maxDen = 500) {
      if (Math.abs(val) < 1e-10) return {num: 0, den: 1};
      let sign = val < 0 ? -1 : 1;
      val = Math.abs(val);
      let bestNum = 1;
      let bestDen = 1;
      let bestError = Math.abs(val - 1);
      for (let den = 1; den <= maxDen; den++) {
        let num = Math.round(val * den);
        let error = Math.abs(val - num / den);
        if (error < bestError) {
          bestError = error;
          bestNum = num;
          bestDen = den;
        }
      }
      let g = gcd(bestNum, bestDen);
      return {num: sign * (bestNum / g), den: bestDen / g};
    }

    function findCommonDenominator(fractions) {
      let l = 1;
      for (let i = 0; i < fractions.length; i++) {
        const den = fractions[i].den;
        if (den !== 1) {
          l = lcm(l, den);
        }
      }
      // Check if all numerators become integers when scaled
      let allValid = true;
      for (let i = 0; i < fractions.length; i++) {
        const scaledNum = fractions[i].num * (l / fractions[i].den);
        if (Math.abs(scaledNum - Math.round(scaledNum)) > 1e-10) {
          allValid = false;
          break;
        }
      }
      return allValid ? l : 1;
    }

    function formatFraction(val) {
      if (Math.abs(val) < 1e-10) return "0";
      if (Math.abs(val - Math.round(val)) < 1e-10) return Math.round(val).toString();
      let {num, den} = decimalToFraction(val);
      if (den === 1) return num.toString();
      return num + "/" + den;
    }

    function cleanDecimal(val) {
      if (Math.abs(val - Math.round(val)) < 1e-10) return Math.round(val).toString();
      return val.toFixed(6).replace(/0+$/, '').replace(/\.$/, '');
    }

    function matrixToFractionLatex(M) {
      let latex = "\\begin{bmatrix}";
      for (let i = 0; i < M.length; i++) {
        for (let j = 0; j < M[0].length; j++) {
          latex += formatFraction(M[i][j]);
          if (j < M[0].length - 1) latex += " & ";
        }
        if (i < M.length - 1) latex += " \\\\ ";
      }
      latex += "\\end{bmatrix}";
      return latex;
    }

    function matrixToDecimalLatex(M) {
      let latex = "\\begin{bmatrix}";
      for (let i = 0; i < M.length; i++) {
        for (let j = 0; j < M[0].length; j++) {
          latex += cleanDecimal(M[i][j]);
          if (j < M[0].length - 1) latex += " & ";
        }
        if (i < M.length - 1) latex += " \\\\ ";
      }
      latex += "\\end{bmatrix}";
      return latex;
    }

    function formatSolutionVector(x) {
      // Convert the solution vector to fractions
      const fractions = x.map(row => decimalToFraction(row[0]));
      const commonDen = findCommonDenominator(fractions);
      
      if (commonDen > 1) {
        // Factor out the common denominator
        const integerVector = fractions.map(frac => {
          const scaledNum = frac.num * (commonDen / frac.den);
          return Math.round(scaledNum);
        });
        return `\\frac{1}{${commonDen}}\\begin{bmatrix} ${integerVector.join(' \\\\ ')} \\end{bmatrix}`;
      } else {
        // No common denominator to factor out
        const vectorStr = fractions.map(frac => {
          if (frac.den === 1) return frac.num.toString();
          return `\\frac{${frac.num}}{${frac.den}}`;
        }).join(' \\\\ ');
        return `\\begin{bmatrix} ${vectorStr} \\end{bmatrix}`;
      }
    }

    function computeSVD(A) {
      const m = A.length;
      const n = A[0].length;
      if (isZeroMatrix(A)) {
        const U = identityMatrix(m);
        const Sigma = Array(m).fill().map(() => Array(n).fill(0));
        const V = identityMatrix(n);
        const Vt = transposeMatrix(V);
        return { U, Sigma, Vt };
      }
      const At = transposeMatrix(A);
      const AtA = multiplyMatrices(At, A);
      const { eigenvalues: lambda_V, eigenvectors: V } = jacobiEigenDecomposition(AtA);
      const singularValues = lambda_V.map(val => Math.sqrt(Math.max(val, 0)));
      const sortedIndices = singularValues.map((val, idx) => idx).sort((a, b) => singularValues[b] - singularValues[a]);
      const sortedSingularValues = sortedIndices.map(i => singularValues[i]);
      const sortedV = Array(n).fill().map(() => Array(n));
      for (let j = 0; j < n; j++) {
        const idx = sortedIndices[j];
        for (let i = 0; i < n; i++) {
          sortedV[i][j] = V[i][idx];
        }
      }
      const Sigma = Array(m).fill().map(() => Array(n).fill(0));
      for (let i = 0; i < Math.min(m, n); i++) {
        Sigma[i][i] = sortedSingularValues[i];
      }
      const U = Array(m).fill().map(() => Array(m).fill(0));
      for (let i = 0; i < Math.min(m, n); i++) {
        if (Math.abs(Sigma[i][i]) > 1e-10) {
          const Av = Array(m).fill(0);
          for (let k = 0; k < m; k++) {
            for (let l = 0; l < n; l++) {
              Av[k] += A[k][l] * sortedV[l][i];
            }
          }
          const sigma = Sigma[i][i];
          for (let k = 0; k < m; k++) {
            U[k][i] = Av[k] / sigma;
          }
        }
      }
      for (let i = Math.min(m, n); i < m; i++) {
        for (let j = 0; j < m; j++) {
          U[j][i] = i === j ? 1 : 0;
        }
      }
      const Vt = transposeMatrix(sortedV);
      return { U, Sigma, Vt };
    }

    document.getElementById("calcBtn").addEventListener("click", function () {
      var A = readMatrix();
      if (A === null) return;
      var b = readVectorB();
      if (b === null) return;
      var m = A.length;
      var n = A[0].length;
      var { U, Sigma, Vt } = computeSVD(A);
      var min_mn = Math.min(m, n);
      var Sigma_plus = Array(n).fill().map(() => Array(m).fill(0));
      const singularValues = Array.from({length: min_mn}, (_, i) => Sigma[i][i]);
      const sigma_max = singularValues.length > 0 ? Math.max(...singularValues) : 0;
      const tol = 1e-8 * sigma_max;
      for (var i = 0; i < min_mn; i++) {
        if (Sigma[i][i] > tol) {
          Sigma_plus[i][i] = 1 / Sigma[i][i];
        }
      }
      var U_transpose = transposeMatrix(U);
      var V = transposeMatrix(Vt);
      var Sigma_plus_Ut = multiplyMatrices(Sigma_plus, U_transpose);
      var A_plus = multiplyMatrices(V, Sigma_plus_Ut);
      var x = multiplyMatrices(A_plus, b);
      var resultDiv = document.getElementById("result");
      if (!resultDiv) return;

      let resultHTML = '';
      let x_latex;
      
      if (currentDisplayMode === "fractions") {
        x_latex = formatSolutionVector(x);
      } else {
        x_latex = matrixToDecimalLatex(x);
      }

      resultHTML += '<p class="font-semibold text-center text-black text-xl mb-6">Least Squares Solution \\( x = A^{\\dagger} b \\):</p>';
      resultHTML += '<div class="latex text-center text-2xl mb-8">$$ ' + x_latex + ' $$</div>';

      let A_latex = matrixToDecimalLatex(A);
      resultHTML += '<p class="font-semibold text-center text-black">Input Matrix A:</p>';
      resultHTML += '<div class="latex text-center">$$ ' + A_latex + ' $$</div>';

      let b_latex = '\\begin{bmatrix} ' + b.map(row => cleanDecimal(row[0])).join(' \\\\ ') + ' \\end{bmatrix}';
      resultHTML += '<p class="font-semibold text-center text-black mt-6">Input Vector \\( \\mathbf{b} \\):</p>';
      resultHTML += '<div class="latex text-center">$$ ' + b_latex + ' $$</div>';

      let U_latex = matrixToDecimalLatex(U);
      let Sigma_latex = matrixToDecimalLatex(Sigma);
      let Vt_latex = matrixToDecimalLatex(Vt);
      resultHTML += '<p class="font-semibold text-center text-black mt-8">SVD Decomposition:</p>';
      resultHTML += '<div class="latex text-center">$$ A = U \\Sigma V^T $$</div>';
      resultHTML += '<div class="latex text-center">$$ U = ' + U_latex + ' $$</div>';
      resultHTML += '<div class="latex text-center">$$ \\Sigma = ' + Sigma_latex + ' $$</div>';
      resultHTML += '<div class="latex text-center">$$ V^T = ' + Vt_latex + ' $$</div>';

      let Sigma_plus_latex = matrixToDecimalLatex(Sigma_plus);
      let A_plus_latex = matrixToDecimalLatex(A_plus);
      resultHTML += '<p class="font-semibold text-center text-black mt-8">Pseudoinverse Calculation:</p>';
      resultHTML += '<div class="latex text-center">$$ \\Sigma^+ = ' + Sigma_plus_latex + ' $$</div>';
      resultHTML += '<div class="latex text-center">$$ A^{\\dagger} = V \\Sigma^+ U^T = ' + A_plus_latex + ' $$</div>';

      let x_step_latex;
      if (currentDisplayMode === "fractions") {
        x_step_latex = formatSolutionVector(x);
      } else {
        x_step_latex = matrixToDecimalLatex(x);
      }
      resultHTML += '<p class="font-semibold text-center text-black mt-8">Solution Calculation:</p>';
      resultHTML += '<div class="latex text-center">$$ x = A^{\\dagger} b = ' + x_step_latex + ' $$</div>';

      resultDiv.innerHTML = resultHTML;

      renderMathInElement(resultDiv, {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "\\(", right: "\\)", display: false }
        ],
        throwOnError: false
      });
    });
  </script>
</body>
</html>
