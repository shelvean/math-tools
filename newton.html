<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="An interactive visualizer for Newton's Method, demonstrating root-finding convergence, initial guesses, and modified Newton's method for multiple roots.">
  <meta name="keywords" content="Newton's Method, root-finding, numerical analysis, interactive visualizer, mathematics, function plotting, function-plot.js, calculus">
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5B8PRB2WZT"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag("js", new Date());
    gtag("config", "G-5B8PRB2WZT");
  </script>
  <title>Newton's Method Visualizer</title>
  <!-- KaTeX CDN links -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"></script>
  <!-- d3.js and function-plot.js -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/function-plot@1.22.4/dist/function-plot.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f0f4f8;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
    }
    .container {
      max-width: 1400px;
      width: 100%;
      background-color: white;
      border-radius: 1rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 2rem;
    }
    .katex-display {
      overflow-x: auto;
      padding: 0.5rem;
    }
    .current-function {
      font-size: 1.25rem;
      padding: 0.5rem;
      text-align: center;
      background-color: #f1f5f9;
      border-radius: 0.5rem;
      margin: 1rem 0;
      display: inline-block;
      min-width: auto;
    }
    .control-panel {
      background-color: #f8fafc;
      padding: 1rem;
      border-radius: 0.5rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      width: 400px;
    }
    #graph {
      border: 1px solid #e2e8f0;
      border-radius: 0.5rem;
      width: 850px;
      height: 600px;
    }
    .function-button {
      padding: 0.25rem 0.5rem;
      font-size: 0.875rem;
    }
    .instructions {
      text-align: center;
      color: #4b5563;
      font-size: 0.875rem;
      margin-top: 0.5rem;
    }
    .equation-container {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
    }
    .graph-container {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      margin-top: 1rem;
    }
    .animate-btn {
      background-color: #10b981 !important;
      color: white !important;
    }
    .animate-btn:hover {
      background-color: #059669 !important;
    }
    .stop-btn {
      background-color: #ef4444 !important;
      color: white !important;
    }
    .stop-btn:hover {
      background-color: #dc2626 !important;
    }
    .animate-btn.running {
      background-color: #059669 !important;
    }
    .converged-message {
      background-color: #d1fae5;
      color: #065f46;
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.875rem;
      display: none;
    }
    .converged-message.show {
      display: block;
    }
    .tolerance-input {
      font-family: monospace;
    }
    .ratio-col {
      background-color: #f8fafc;
    }
  </style>
</head>
<body class="bg-gray-100">
  <div class="fixed top-0 left-0 w-full bg-white shadow-md z-10">
    <div class="max-w-4xl mx-auto px-4 py-2">
      <ul class="flex justify-center space-x-4">
        <li><a href="index.html" class="text-indigo-600 hover:text-blue-600 font-bold text-xl">Home</a></li>
        <li><a href="teaching.html" class="text-indigo-600 hover:text-blue-600 font-bold text-xl">Teaching</a></li>
        <li><a href="projects.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Diff Eq</a></li>
        <li><a href="linear.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Linear Algebra</a></li>
        <li><a href="numerical.html" class="text-indigo-500 hover:text-blue-600 font-bold text-xl">Numerical Methods</a></li>
      </ul>
    </div>
  </div>
  <div class="container mt-16">
    <header class="text-center mb-6">
      <h1 class="text-3xl font-bold text-gray-800">Newton's Method Visualizer</h1>
      <p class="text-gray-600 mt-2">Explore the convergence of Newton's method with interactive visualizations</p>
    </header>
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
      <div class="p-4 bg-gray-50 rounded-lg">
        <h3 class="font-semibold text-gray-700 mb-2">Newton's Method</h3>
        <div class="equation-container">
          <div class="text-base text-gray-600">\[ x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)} \]</div>
        </div>
        <p class="text-sm text-gray-500 mt-1 text-center">Quadratic convergence for simple roots</p>
      </div>
      <div class="p-4 bg-gray-50 rounded-lg">
        <h3 class="font-semibold text-gray-700 mb-2">Modified Newton's Method</h3>
        <div class="equation-container">
          <div class="text-base text-gray-600">\[ x_{n+1} = x_n - m \cdot \frac{f(x_n)}{f'(x_n)} \]</div>
        </div>
        <p class="text-sm text-gray-500 mt-1 text-center">Restores quadratic convergence for roots with multiplicity \( m \)</p>
      </div>
    </div>
    <div class="bg-white rounded-lg shadow p-6 mb-6 flex flex-row gap-4">
      <div class="flex-1">
        <div class="equation-container">
          <div id="current-function" class="current-function">\[ f(x) = e^{x-1} - 1 \]</div>
        </div>
        <div id="graph-container" class="graph-container">
          <div id="graph"></div>
        </div>
        <div id="converged-message" class="converged-message">
          ✓ Convergence achieved! Absolute error ≤ 1e-13
        </div>
        <div class="flex justify-center gap-4 mt-4">
          <button onclick="resetIterations()" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-md transition-colors">Reset</button>
          <button onclick="performIterationManual()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md transition-colors">Manual</button>
          <button id="animate-btn" onclick="toggleAnimation()" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-md transition-colors animate-btn">Animate</button>
          <button id="stop-btn" onclick="stopAnimation()" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md transition-colors stop-btn hidden">Stop</button>
        </div>
      </div>
      <div class="control-panel">
        <div class="mb-4">
          <h3 class="text-sm font-medium text-gray-700 mb-2">Select Function</h3>
          <div class="grid grid-cols-1 gap-2">
            <button onclick="selectFunction(0)" class="function-button bg-blue-50 hover:bg-blue-100 text-blue-700 rounded-md border border-blue-200 text-left">\[ f(x) = e^{x-1} - 1 \text{ (multiplicity 1)} \]</button>
            <button onclick="selectFunction(1)" class="function-button bg-green-50 hover:bg-green-100 text-green-700 rounded-md border border-blue-200 text-left">\[ f(x) = (x-1)^2 e^{x-2} \text{ (multiplicity 2)} \]</button>
            <button onclick="selectFunction(2)" class="function-button bg-purple-50 hover:bg-purple-100 text-purple-700 rounded-md border border-blue-200 text-left">\[ f(x) = x^3 - 2x + 2 \text{ (multiplicity 1)} \]</button>
            <button onclick="selectFunction(3)" class="function-button bg-orange-50 hover:bg-orange-100 text-orange-700 rounded-md border border-blue-200 text-left">\[ f(x) = (\sin(x) - x + 1)^2 \\ \text{ Root: } x \approx 1.93456, \quad m = 2 \]</button>
            <button onclick="selectFunction(4)" class="function-button bg-red-50 hover:bg-red-100 text-red-700 rounded-md border border-blue-200 text-left">\[ f(x) = (e^{x-2} - 1)^3 \\ \text{ Root: } x = 2, \quad m = 3 \]</button>
          </div>
        </div>
        <div class="mb-4">
          <label class="block text-sm font-medium text-gray-700 mb-2">Initial Guess \( x_0 \)</label>
          <input type="number" id="x0" value="2.5" step="0.1" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
        </div>
        <div class="mb-4">
          <label class="flex items-center">
            <input type="checkbox" id="modifiedMethod" class="rounded text-blue-600 focus:ring-blue-500">
            <span class="ml-2 text-sm text-gray-700">Use Modified Newton's Method</span>
          </label>
        </div>
        <div id="multiplicity-select" class="mb-4 hidden">
          <label class="block text-sm font-medium text-gray-700 mb-2">Multiplicity for Modified Method</label>
          <select id="multiplicity" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
            <option value="1">m = 1</option>
            <option value="2">m = 2</option>
            <option value="3">m = 3</option>
          </select>
        </div>
        <div class="mb-4">
          <label class="block text-sm font-medium text-gray-700 mb-2">Convergence Tolerance</label>
          <div class="flex flex-col gap-2">
            <input type="text" id="convergence-tolerance" value="1e-13" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 tolerance-input">
            <div class="text-xs text-gray-500 text-center">Enter any positive number (e.g., 1e-6, 0.0001, 1e-15)</div>
          </div>
        </div>
        <div class="mb-4">
          <label class="block text-sm font-medium text-gray-700 mb-2">Animation Speed</label>
          <div class="flex items-center">
            <span class="text-xs text-gray-500 mr-2">Fast</span>
            <input type="range" id="animation-speed" min="500" max="3000" value="1500" step="100" class="flex-1">
            <span class="text-xs text-gray-500 ml-2">Slow</span>
          </div>
          <div class="text-center text-xs text-gray-500 mt-1" id="speed-display">1500 ms</div>
        </div>
        <div id="error-message" class="mt-4 p-3 bg-red-100 text-red-700 rounded-md hidden text-sm"></div>
      </div>
    </div>
    <div class="mt-6 bg-white rounded-lg shadow p-6">
      <h2 class="text-xl font-semibold text-gray-800 mb-4">Iteration Details</h2>
      <div class="overflow-x-auto">
        <table class="w-full border-collapse">
          <thead>
            <tr class="bg-gray-100">
              <th class="border border-gray-200 px-4 py-2 text-center font-semibold">Iteration (n)</th>
              <th class="border border-gray-200 px-4 py-2 text-center font-semibold">\( x_n \)</th>
              <th class="border border-gray-200 px-4 py-2 text-center font-semibold">\( f(x_n) \)</th>
              <th class="border border-gray-200 px-4 py-2 text-center font-semibold">\( f'(x_n) \)</th>
              <th class="border border-gray-200 px-4 py-2 text-center font-semibold">Absolute Error \( e_n \)</th>
              <th class="border border-gray-200 px-4 py-2 text-center font-semibold ratio-col">\( e_{n+1} / e_n \)</th>
              <th class="border border-gray-200 px-4 py-2 text-center font-semibold ratio-col">\( e_{n+1} / e_n^2 \)</th>
            </tr>
          </thead>
          <tbody id="iteration-data"></tbody>
        </table>
      </div>
    </div>
    <div class="mt-6 border-t pt-4 text-center text-gray-500 text-sm">
      © 2025 Shelvean Kapita: kapita@tamu.edu <br> Last modified: September 8, 2025
    </div>
  </div>
  <script>
    const functions = [
      {
        f: x => Math.exp(x - 1) - 1,
        df: x => Math.exp(x - 1),
        fStr: "e^{x-1} - 1",
        plotFn: "exp(x-1) - 1",
        root: 1,
        multiplicity: 1
      },
      {
        f: x => Math.pow(x - 1, 2) * Math.exp(x - 2),
        df: x => {
          const term1 = 2 * (x - 1) * Math.exp(x - 2);
          const term2 = Math.pow(x - 1, 2) * Math.exp(x - 2);
          return term1 + term2;
        },
        fStr: "(x-1)^2 e^{x-2}",
        plotFn: "(x-1)^2 * exp(x-2)",
        root: 1,
        multiplicity: 2
      },
      {
        f: x => Math.pow(x, 3) - 2 * x + 2,
        df: x => 3 * Math.pow(x, 2) - 2,
        fStr: "x^3 - 2x + 2",
        plotFn: "x^3 - 2*x + 2",
        root: -1.769292354238631,
        multiplicity: 1
      },
      {
        f: x => Math.pow(Math.sin(x) - x + 1, 2),
        df: x => {
          const inner = Math.sin(x) - x + 1;
          const innerDeriv = Math.cos(x) - 1;
          return 2 * inner * innerDeriv;
        },
        fStr: "(\\sin(x) - x + 1)^2",
        plotFn: "(sin(x) - x + 1)^2",
        root: 1.934563210752024, // Solution to sin(x) = x - 1
        multiplicity: 2
      },
      {
        f: x => Math.pow(Math.exp(x - 2) - 1, 3),
        df: x => {
          const inner = Math.exp(x - 2) - 1;
          return 3 * Math.pow(inner, 2) * Math.exp(x - 2);
        },
        fStr: "(e^{x-2} - 1)^3",
        plotFn: "(exp(x-2) - 1)^3",
        root: 2,
        multiplicity: 3
      }
    ];

    let currentFunction = functions[0];
    let iterations = [];
    let currentIteration = 0;
    let xMin = -2, xMax = 5;
    let yMin = -5, yMax = 10;
    const tangentColor = '#8B4513';
    let animationInterval = null;
    let isAnimating = false;
    let CONVERGENCE_TOLERANCE = 1e-13; // Variable tolerance

    function renderKaTeX() {
      renderMathInElement(document.body, {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "\\[", right: "\\]", display: true },
          { left: "\\(", right: "\\)", display: false }
        ],
        throwOnError: false,
        output: 'html'
      });
    }

    function parseTolerance(value) {
      // Remove any whitespace
      value = value.trim();
      
      // If empty, return default
      if (value === '') {
        return 1e-13;
      }
      
      // Handle scientific notation (e.g., 1e-13, 1E-13, 1e-6)
      if (/^[0-9]+(\.[0-9]+)?[eE][+-]?[0-9]+$/.test(value)) {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          return num;
        }
      }
      
      // Handle decimal notation (e.g., 0.0001, .0001)
      if (/^[0-9]*\.?[0-9]+$/.test(value)) {
        const num = parseFloat(value);
        if (!isNaN(num) && num > 0) {
          return num;
        }
      }
      
      // Handle pure integer (e.g., 1, 10 - though these would be unusual tolerances)
      if (/^[0-9]+$/.test(value)) {
        const num = parseInt(value);
        if (!isNaN(num) && num > 0) {
          return num;
        }
      }
      
      // If we can't parse it, return the default
      return 1e-13;
    }

    function init() {
      const modifiedCheckbox = document.getElementById('modifiedMethod');
      const multiplicitySelect = document.getElementById('multiplicity-select');
      const speedSlider = document.getElementById('animation-speed');
      const speedDisplay = document.getElementById('speed-display');
      const toleranceInput = document.getElementById('convergence-tolerance');

      function updateMultiplicityVisibility() {
        if (modifiedCheckbox.checked && (currentFunction.multiplicity === 2 || currentFunction.multiplicity === 3)) {
          multiplicitySelect.classList.remove('hidden');
        } else {
          multiplicitySelect.classList.add('hidden');
        }
      }

      function updateSpeedDisplay() {
        speedDisplay.textContent = `${speedSlider.value} ms`;
      }

      function updateTolerance() {
        const value = toleranceInput.value;
        const parsed = parseTolerance(value);
        CONVERGENCE_TOLERANCE = parsed;
        
        // Only update the input field if the parsed value is different AND the field is not empty
        // This allows the user to clear the field completely
        if (value !== '' && value !== parsed.toString() && value !== parsed.toExponential()) {
          // Use a small timeout to avoid interrupting the user's typing
          setTimeout(() => {
            toleranceInput.value = parsed.toExponential();
          }, 100);
        }
        
        updateConvergenceMessage();
      }

      modifiedCheckbox.addEventListener('change', () => {
        updateMultiplicityVisibility();
        resetIterations();
      });

      document.getElementById('x0').addEventListener('change', resetIterations);
      document.getElementById('multiplicity').addEventListener('change', resetIterations);
      speedSlider.addEventListener('input', updateSpeedDisplay);
      
      // Use 'blur' event instead of 'change' for better UX
      toleranceInput.addEventListener('blur', updateTolerance);
      // Also update on Enter key
      toleranceInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          updateTolerance();
          toleranceInput.blur(); // Remove focus
        }
      });

      resetIterations();
      updateMultiplicityVisibility();
      updateSpeedDisplay();
      updateTolerance();
      renderKaTeX();
      drawGraph();
    }

    function selectFunction(index) {
      currentFunction = functions[index];
      const currentFunctionDiv = document.getElementById('current-function');
      currentFunctionDiv.innerHTML = `\\[ f(x) = ${currentFunction.fStr} \\]`;
      document.getElementById('multiplicity').value = currentFunction.multiplicity || 1;
      resetIterations();
      document.getElementById('modifiedMethod').checked = false;
      document.getElementById('multiplicity-select').classList.add('hidden');
      stopAnimation();
      renderKaTeX();
    }

    function getAbsoluteError(x) {
      return Math.abs(x - currentFunction.root);
    }

    function hasConverged() {
      if (iterations.length === 0) return false;
      const lastError = iterations[iterations.length - 1].error;
      return lastError <= CONVERGENCE_TOLERANCE;
    }

    function updateConvergenceMessage() {
      const messageDiv = document.getElementById('converged-message');
      if (hasConverged() && iterations.length > 0) {
        const lastError = iterations[iterations.length - 1].error;
        const scientificNotation = lastError.toExponential(2);
        const toleranceScientific = CONVERGENCE_TOLERANCE.toExponential(2);
        messageDiv.innerHTML = `✓ Convergence achieved! Absolute error = ${scientificNotation} ≤ ${toleranceScientific}`;
        messageDiv.classList.add('show');
      } else {
        messageDiv.classList.remove('show');
      }
    }

    function resetIterations() {
      stopAnimation();
      const x0 = parseFloat(document.getElementById('x0').value);
      if (isNaN(x0)) {
        showError("Invalid initial guess");
        return;
      }
      iterations = [{ n: 0, x: x0, fx: currentFunction.f(x0), dfx: currentFunction.df(x0), error: getAbsoluteError(x0), prevRatioLinear: "-", prevRatioQuadratic: "-", ratioLinear: "-", ratioQuadratic: "-" }];
      currentIteration = 0;
      updateTable();
      updateConvergenceMessage();
      drawGraph();
      hideError();
    }

    function performIteration() {
      if (currentIteration >= 50) {
        showError("Maximum iterations (50) reached");
        stopAnimation();
        return;
      }
      
      // Check if already converged
      if (hasConverged()) {
        stopAnimation();
        return;
      }
      
      const modified = document.getElementById('modifiedMethod').checked;
      let multiplicity = modified ? currentFunction.multiplicity || parseInt(document.getElementById('multiplicity').value) : 1;
      const lastIteration = iterations[iterations.length - 1];
      
      if (Math.abs(lastIteration.dfx) < 1e-15) {
        showError("Newton's method failed: derivative is zero");
        stopAnimation();
        return;
      }
      
      const xNext = lastIteration.x - multiplicity * lastIteration.fx / lastIteration.dfx;
      const fxNext = currentFunction.f(xNext);
      const dfxNext = currentFunction.df(xNext);
      const error = getAbsoluteError(xNext);
      
      // Calculate ratios for the previous iteration (n-1) to current iteration (n)
      let ratioLinear = "-";
      let ratioQuadratic = "-";
      
      if (iterations.length > 0) {
        const prevError = iterations[iterations.length - 1].error;
        if (prevError > 0) {
          ratioLinear = (error / prevError).toFixed(10);
          ratioQuadratic = (error / (prevError * prevError)).toFixed(10);
        } else if (error === 0) {
          ratioLinear = "0";
          ratioQuadratic = "0";
        }
      }
      
      // Add new iteration with ratios (these will be displayed in the next row)
      iterations.push({ 
        n: iterations.length, 
        x: xNext, 
        fx: fxNext, 
        dfx: dfxNext, 
        error: error,
        prevRatioLinear: ratioLinear,  // Ratio from previous iteration to this one
        prevRatioQuadratic: ratioQuadratic,  // Ratio from previous iteration to this one
        ratioLinear: "-",  // Will be calculated when next iteration is computed
        ratioQuadratic: "-"  // Will be calculated when next iteration is computed
      });
      
      currentIteration++;
      updateTable();
      updateConvergenceMessage();
      drawGraph();
      hideError();
      
      // Check for convergence after updating
      if (hasConverged()) {
        stopAnimation();
        return;
      }
      
      if (currentIteration >= 50) {
        showError("Maximum iterations (50) reached");
        stopAnimation();
      }
    }

    function performIterationManual() {
      stopAnimation();
      performIteration();
    }

    function toggleAnimation() {
      if (isAnimating) {
        stopAnimation();
      } else {
        startAnimation();
      }
    }

    function startAnimation() {
      if (isAnimating) return;
      
      // Don't start if already converged
      if (hasConverged()) {
        showError("Already converged! Reset to start animation.");
        return;
      }
      
      isAnimating = true;
      const animateBtn = document.getElementById('animate-btn');
      const stopBtn = document.getElementById('stop-btn');
      
      animateBtn.classList.add('running');
      animateBtn.classList.add('hidden');
      stopBtn.classList.remove('hidden');
      
      const speed = parseInt(document.getElementById('animation-speed').value);
      
      animationInterval = setInterval(() => {
        // Stop if converged
        if (hasConverged()) {
          stopAnimation();
          return;
        }
        
        if (currentIteration >= 50) {
          stopAnimation();
          return;
        }
        performIteration();
      }, speed);
    }

    function stopAnimation() {
      if (!isAnimating) return;
      
      isAnimating = false;
      const animateBtn = document.getElementById('animate-btn');
      const stopBtn = document.getElementById('stop-btn');
      
      animateBtn.classList.remove('running');
      animateBtn.classList.remove('hidden');
      stopBtn.classList.add('hidden');
      
      if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = null;
      }
    }

    function updateTable() {
      const tableBody = document.getElementById('iteration-data');
      tableBody.innerHTML = '';
      iterations.forEach((iter, index) => {
        const row = document.createElement('tr');
        // Highlight converged rows
        const isConverged = iter.error <= CONVERGENCE_TOLERANCE;
        const bgColor = isConverged ? 'bg-green-50' : '';
        
        // For iteration n, show:
        // - For n=0: ratios are "-" (we don't have e_{-1})
        // - For n>0: show prevRatioLinear and prevRatioQuadratic (which are e_n/e_{n-1} and e_n/e_{n-1}^2)
        const ratioLinearDisplay = iter.prevRatioLinear;
        const ratioQuadraticDisplay = iter.prevRatioQuadratic;
        
        row.innerHTML = `
          <td class="border border-gray-200 px-4 py-2 text-center ${bgColor}">${iter.n}</td>
          <td class="border border-gray-200 px-4 py-2 text-center ${bgColor}">${iter.x.toFixed(15)}</td>
          <td class="border border-gray-200 px-4 py-2 text-center ${bgColor}">${iter.fx.toExponential(10)}</td>
          <td class="border border-gray-200 px-4 py-2 text-center ${bgColor}">${iter.dfx.toExponential(10)}</td>
          <td class="border border-gray-200 px-4 py-2 text-center ${bgColor}">${iter.error.toExponential(10)}</td>
          <td class="border border-gray-200 px-4 py-2 text-center ${bgColor} ratio-col">${ratioLinearDisplay}</td>
          <td class="border border-gray-200 px-4 py-2 text-center ${bgColor} ratio-col">${ratioQuadraticDisplay}</td>
        `;
        tableBody.appendChild(row);
      });
    }

    function calculateGraphBounds() {
      // Start with default bounds
      xMin = -2;
      xMax = 5;
      yMin = -5;
      yMax = 10;
      
      // Adjust based on current function
      if (currentFunction.fStr === "(\\sin(x) - x + 1)^2") {
        // For sin function example
        xMin = 0;
        xMax = 4;
        yMin = -0.5;
        yMax = 4;
      } else if (currentFunction.fStr === "(e^{x-2} - 1)^3") {
        // For exponential function example
        xMin = 0;
        xMax = 4;
        yMin = -2;
        yMax = 2;
      }
      
      // If we have iterations, adjust bounds to show tangent line and x-intersection prominently
      if (iterations.length > 1) {
        const lastIter = iterations[iterations.length - 2];
        const currentIter = iterations[iterations.length - 1];
        
        // Get the tangent line points
        const slope = lastIter.dfx;
        const intercept = lastIter.fx - slope * lastIter.x;
        
        // Calculate x where tangent line crosses y=0 (next iteration)
        const xZero = currentIter.x;
        
        // Get points for the tangent line
        const tangentPoints = [];
        for (let x = lastIter.x - 2; x <= lastIter.x + 2; x += 0.5) {
          tangentPoints.push([x, slope * x + intercept]);
        }
        
        // Find min/max of tangent line
        const tangentX = tangentPoints.map(p => p[0]);
        const tangentY = tangentPoints.map(p => p[1]);
        
        // Find min/max of function points around the area of interest
        const funcPoints = [];
        const centerX = (lastIter.x + xZero) / 2;
        const range = Math.max(Math.abs(lastIter.x - xZero) * 3, 3);
        
        for (let x = centerX - range; x <= centerX + range; x += 0.5) {
          funcPoints.push([x, currentFunction.f(x)]);
        }
        
        const funcX = funcPoints.map(p => p[0]);
        const funcY = funcPoints.map(p => p[1]);
        
        // Combine all relevant x and y values
        const allX = [...tangentX, ...funcX, lastIter.x, xZero, currentFunction.root];
        const allY = [...tangentY, ...funcY, lastIter.fx, 0, 0];
        
        // Calculate bounds with padding
        const xMinVal = Math.min(...allX);
        const xMaxVal = Math.max(...allX);
        const yMinVal = Math.min(...allY);
        const yMaxVal = Math.max(...allY);
        
        // Add 30% padding to ensure visibility
        const xPadding = Math.max((xMaxVal - xMinVal) * 0.3, 0.5);
        const yPadding = Math.max((yMaxVal - yMinVal) * 0.3, 0.5);
        
        xMin = Math.min(xMin, xMinVal - xPadding);
        xMax = Math.max(xMax, xMaxVal + xPadding);
        yMin = Math.min(yMin, yMinVal - yPadding);
        yMax = Math.max(yMax, yMaxVal + yPadding);
        
        // Ensure we don't make the bounds too extreme
        xMin = Math.max(xMin, -10);
        xMax = Math.min(xMax, 10);
        yMin = Math.max(yMin, -15);
        yMax = Math.min(yMax, 15);
      }
    }

    function drawGraph() {
      calculateGraphBounds(); // Calculate dynamic bounds
      
      const graphContainer = document.getElementById('graph');
      graphContainer.innerHTML = ''; // Clear previous plot
      
      // Add root as a large red dot (removed vertical dashed line and annotation)
      let rootScatter = {
        points: [[currentFunction.root, 0]],
        fnType: 'points',
        graphType: 'scatter',
        color: '#ef4444', // Red color
        attr: { r: 8 } // Large dot
      };
      
      let tangentData = [];
      if (iterations.length > 1) {
        const iter = iterations[iterations.length - 2];
        const slope = iter.dfx;
        const intercept = iter.fx - slope * iter.x;
        const tanFn = `${slope.toFixed(10)} * x + ${intercept.toFixed(10)}`;
        tangentData.push({
          fn: tanFn,
          color: tangentColor,
          sampler: 'builtIn',
          graphType: 'polyline',
          attr: { 'stroke-width': 2 }
        });
      }
      let verticals = [];
      iterations.forEach((iter, index) => {
        if (index > 0) {
          const col = index === iterations.length - 1 ? '#ef4444' : '#64748b';
          verticals.push({
            points: [[iter.x, 0], [iter.x, iter.fx]],
            fnType: 'points',
            graphType: 'polyline',
            color: col,
            attr: { 'stroke-dasharray': '5 5', 'stroke-width': 1.5 }
          });
        }
      });
      let prevPoints = iterations.slice(0, -1).map(iter => [iter.x, 0]);
      let prevScatter = {
        points: prevPoints,
        fnType: 'points',
        graphType: 'scatter',
        color: '#64748b',
        attr: { r: 5 }
      };
      let lastScatter = null;
      if (iterations.length > 0) {
        const lastIter = iterations[iterations.length - 1];
        lastScatter = {
          points: [[lastIter.x, 0]],
          fnType: 'points',
          graphType: 'scatter',
          color: '#ef4444',
          attr: { r: 6 }
        };
      }
      let data = [
        {
          fn: currentFunction.plotFn,
          color: '#3b82f6',
          sampler: 'builtIn',
          graphType: 'polyline',
          nSamples: 400,
          attr: { 'stroke-width': 3 }
        },
        rootScatter // Add the root as a large red dot
      ];
      data = data.concat(verticals);
      data = data.concat(tangentData);
      if (prevPoints.length > 0) {
        data.push(prevScatter);
      }
      if (lastScatter) {
        data.push(lastScatter);
      }
      try {
        functionPlot({
          target: '#graph',
          width: 1050,
          height: 600,
          xAxis: { domain: [xMin, xMax] },
          yAxis: { domain: [yMin, yMax] },
          grid: true,
          disableZoom: false,
          data: data,
          annotations: [] // Removed root annotations
        });
        // Re-render KaTeX for annotations after function-plot
        const graphElement = document.getElementById('graph');
        renderMathInElement(graphElement, {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "\\[", right: "\\]", display: true },
            { left: "\\(", right: "\\)", display: false }
          ],
          throwOnError: false,
          output: 'html'
        });
      } catch (e) {
        console.error('Graph rendering error:', e);
        showError(`Graph rendering failed: ${e.message}`);
      }
    }

    function showError(message) {
      const errorDiv = document.getElementById('error-message');
      errorDiv.textContent = message;
      errorDiv.classList.remove('hidden');
    }

    function hideError() {
      const errorDiv = document.getElementById('error-message');
      errorDiv.classList.add('hidden');
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>
