<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="description" content="Simple Pendulum Simulation Second Order Differential Equation, Damping, Spring Constant">
    <meta name="keywords" content="Pendulum, Simulation, Damping, Spring Constant, Second Order, Differential Equations">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5B8PRB2WZT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-5B8PRB2WZT');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Damped Pendulum Simulator</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        :root {
            --primary: #6c5ce7;
            --secondary: #4a47a3;
            --background: #f8f9fa;
            --surface: #e9ecef;
            --text: #212529;
            --accent: #00b4d8;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 30px;
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .main-container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            text-align: center;
        }
        .content-wrapper {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            align-items: start;
        }
        .simulation-column {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        .controls-wrapper {
            background: rgba(255,255,255,0.9);
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 14px;
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.06);
        }
        svg {
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            border: 2px solid var(--surface);
            background: white;
        }
        #simulationSvg {
            width: 100%;
            height: 400px;
        }
        .graph-container {
            background: white;
            border: 1px solid var(--surface);
            border-radius: 16px;
            padding: 1rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.06);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .controls label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.9rem;
            color: var(--secondary);
        }
        .controls input {
            width: 80px;
            padding: 0.4rem;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            font-size: 0.9rem;
        }
        button {
            padding: 0.6rem 1rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        button:hover {
            background: var(--accent);
            transform: translateY(-1px);
        }
        .alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            padding: 1rem;
            background: #f8d7da;
            color: #721c24;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: none;
        }
        .graph-label {
            font-size: 0.8rem;
            fill: var(--text);
        }
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px 0;
            color: var(--secondary);
            font-size: 0.9rem;
            border-top: 1px solid var(--surface);
        }
        #equationGeneral {
            text-align: center;
            color: blue;
        }
        .flex {
            display: flex;
        }
        .justify-center {
            justify-content: center;
        }
        .font-bold {
            font-weight: bold;
        }
        .text-xl {
            font-size: 1.25rem;
        }
        .mb-4 {
            margin-bottom: 1rem;
        }
        .mx-4 {
            margin-left: 1rem;
            margin-right: 1rem;
        }
        nav a {
            color: var(--text);
            text-decoration: none;
        }
        nav a:hover {
            color: var(--primary);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.0.0/math.min.js"></script>
</head>
<body>
    <div class="main-container">
        <nav class="flex justify-center mb-4">
            <a href="index.html" class="font-bold text-xl mx-4" style="color: var(--primary);">Home</a>
            <a href="teaching.html" class="font-bold text-xl mx-4" style="color: var(--primary);">Teaching</a>
            <a href="projects.html" class="font-bold text-xl mx-4" style="color: var(--primary);">Diff Eq</a>
            <a href="linear.html" class="font-bold text-xl mx-4" style="color: var(--primary);">Linear Algebra</a>
            <a href="numerical.html" class="font-bold text-xl mx-4" style="color: var(--primary);">Numerical Methods</a>
        </nav>
        <h1>Damped Pendulum Simulator</h1>
        <div id="equationGeneral"></div>
        <div class="content-wrapper">
            <div class="simulation-column">
                <svg id="simulationSvg" width="500" height="400" viewBox="0 0 500 400"></svg>
                <div class="graph-container">
                    <h2>Phase Space (θ' vs θ)</h2>
                    <canvas id="phaseGraphCanvas" width="400" height="300"></canvas>
                </div>
            </div>
            <div class="controls-wrapper">
                <div style="font-size: 0.9rem; color: var(--secondary); margin-bottom: 1rem;">
                    Inputs can accept mathematical expressions like pi/4.
                </div>
                <div class="controls">
                    <div>
                        <label for="length">Length (L) [m]:<input type="text" id="length" value="2.5"></label>
                        <label for="initialAngle">Initial Angle (θ₀) [rad]:<input type="text" id="initialAngle" value="3*pi/4"></label>
                        <label for="initialVelocity">Angular Velocity (ω₀) [rad/s]:<input type="text" id="initialVelocity" value="pi/2"></label>
                    </div>
                    <div>
                        <label for="mass">Mass (m) [kg]:<input type="text" id="mass" value="5.0"></label>
                        <label for="damping">Damping (b) [kg/s]:<input type="text" id="damping" value="2.3"></label>
                        <button onclick="resetSimulation()" style="margin-top: 1rem;">Reset</button>
                    </div>
                </div>
                <div class="graph-container">
                    <h2>Angular Displacement vs Time</h2>
                    <canvas id="graphCanvas" width="350" height="200"></canvas>
                </div>
            </div>
        </div>
        <div id="alertContainer" class="alert"></div>
        <footer>
    &copy; 2025 Shelvean Kapita: kapita@tamu.edu<br>
    <a href="https://opensource.org/licenses/MIT">MIT License</a> | Last modified: September 28, 2025
</footer>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script>
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');
        const phaseGraphCanvas = document.getElementById('phaseGraphCanvas');
        const phaseGraphCtx = phaseGraphCanvas.getContext('2d');
        const svg = document.getElementById('simulationSvg');
        const g = 9.81;
        let L = 2, theta0 = 1.4, omega0 = 1, m = 1, b = 0.15;
        let theta = theta0, omega = omega0, t = 0;
        let dt = 0.025;
        const graphMaxTime = 60;
        let isSimulationRunning = true;
        const graphData = [];
        let useBackwardEuler = false;
        let b_over_m, g_over_L, denom, c1, c2;
        let stepsPerFrame = 3;
        const maxPhasePoints = 2500;
        function toPiRange(theta) {
            let mod = theta % (2 * Math.PI);
            if (mod > Math.PI) mod -= 2 * Math.PI;
            if (mod < -Math.PI) mod += 2 * Math.PI;
            return mod;
        }
        function calculateDerivatives(theta, omega) {
            const alpha = -b_over_m * omega - g_over_L * Math.sin(theta);
            return { theta: omega, omega: alpha };
        }
        function backwardEulerStep(theta, omega, dt) {
            let theta_next = theta;
            const tolerance = 1e-6;
            const maxIterations = 100;
            for (let i = 0; i < maxIterations; i++) {
                const f_val = theta_next - theta - c1 * omega + c2 * Math.sin(theta_next);
                const f_prime_val = 1 + c2 * Math.cos(theta_next);
                if (Math.abs(f_prime_val) < 1e-12) break;
                const delta = f_val / f_prime_val;
                theta_next -= delta;
                if (Math.abs(delta) < tolerance) break;
            }
            const omega_next = (omega - (dt * g_over_L * Math.sin(theta_next))) / denom;
            return { theta: theta_next, omega: omega_next };
        }
        function updatePhysics() {
            if (useBackwardEuler) {
                const nextState = backwardEulerStep(theta, omega, dt);
                theta = nextState.theta;
                omega = nextState.omega;
            } else {
                const k1 = calculateDerivatives(theta, omega);
                const k2 = calculateDerivatives(
                    theta + (k1.theta * dt) / 2,
                    omega + (k1.omega * dt) / 2
                );
                const k3 = calculateDerivatives(
                    theta + (k2.theta * dt) / 2,
                    omega + (k2.omega * dt) / 2
                );
                const k4 = calculateDerivatives(
                    theta + k3.theta * dt,
                    omega + k3.omega * dt
                );
                theta += (k1.theta + 2 * k2.theta + 2 * k3.theta + k4.theta) * dt / 6;
                omega += (k1.omega + 2 * k2.omega + 2 * k3.omega + k4.omega) * dt / 6;
            }
            t += dt;
            graphData.push({ t, theta: toPiRange(theta), omega });
            if (t > graphMaxTime) isSimulationRunning = false;
        }
        function drawPendulum() {
            const pivotX = 250;
            const pivotY = 200;
            const scale = 60;
            const bobRadius = 18;
            const visualLength = L * scale;
            const bobX = pivotX + visualLength * Math.sin(theta);
            const bobY = pivotY + visualLength * Math.cos(theta);
            rod.setAttribute("x2", bobX);
            rod.setAttribute("y2", bobY);
            bob.setAttribute("cx", bobX);
            bob.setAttribute("cy", bobY);
        }
        function drawGraph() {
            graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
            graphCtx.beginPath();
            graphCtx.moveTo(50, 20);
            graphCtx.lineTo(50, graphCanvas.height - 30);
            graphCtx.lineTo(graphCanvas.width - 20, graphCanvas.height - 30);
            graphCtx.strokeStyle = '#000';
            graphCtx.stroke();
            if (graphData.length === 0) return;
            const minTheta = -Math.PI;
            const maxTheta = Math.PI;
            const maxTime = graphMaxTime;
            graphCtx.fillStyle = '#000';
            graphCtx.font = '10px Arial';
            graphCtx.textAlign = 'right';
            const labelCount = 5;
            for (let i = 0; i <= labelCount; i++) {
                const thetaVal = minTheta + (i / labelCount) * (maxTheta - minTheta);
                const y = graphCanvas.height - 30 - (i / labelCount) * (graphCanvas.height - 50);
                graphCtx.textBaseline = 'middle';
                graphCtx.fillText(thetaVal.toFixed(2), 45, y);
            }
            graphCtx.textAlign = 'center';
            graphCtx.textBaseline = 'top';
            for (let tVal = 0; tVal <= maxTime; tVal += maxTime/5) {
                const x = 50 + (tVal/maxTime) * (graphCanvas.width - 70);
                graphCtx.fillText(tVal.toFixed(1), x, graphCanvas.height - 25);
            }
            graphCtx.strokeStyle = '#007bff';
            graphCtx.lineWidth = 2;
            const verticalRange = graphCanvas.height - 50;
            graphCtx.beginPath();
            let prevTheta = graphData[0].theta;
            let x = 50 + (graphData[0].t / maxTime) * (graphCanvas.width - 70);
            let y = graphCanvas.height - 30 - ((graphData[0].theta - minTheta) / (maxTheta - minTheta)) * verticalRange;
            graphCtx.moveTo(x, y);
            graphData.forEach((point, idx) => {
                if (idx === 0) return;
                x = 50 + (point.t / maxTime) * (graphCanvas.width - 70);
                y = graphCanvas.height - 30 - ((point.theta - minTheta) / (maxTheta - minTheta)) * verticalRange;
                const deltaTheta = point.theta - prevTheta;
                if (Math.abs(deltaTheta) > Math.PI) {
                    graphCtx.stroke();
                    graphCtx.beginPath();
                    graphCtx.moveTo(x, y);
                } else {
                    graphCtx.lineTo(x, y);
                }
                prevTheta = point.theta;
            });
            graphCtx.stroke();
        }
        function drawPhaseGraph() {
            phaseGraphCtx.clearRect(0, 0, phaseGraphCanvas.width, phaseGraphCanvas.height);
            if (graphData.length === 0) return;
            const phaseData = graphData.slice(-maxPhasePoints);
            const thetaValues = phaseData.map(d => d.theta);
            const omegaValues = phaseData.map(d => d.omega);
            const minTheta = -Math.PI;
            const maxTheta = Math.PI;
            const minOmega = Math.min(...omegaValues);
            const maxOmega = Math.max(...omegaValues);
            const thetaRange = maxTheta - minTheta || 0.001;
            const omegaRange = maxOmega - minOmega || 0.001;
            const thetaMin = minTheta;
            const thetaMax = maxTheta;
            const omegaMin = minOmega - 0.1 * omegaRange;
            const omegaMax = maxOmega + 0.1 * omegaRange;
            const W = phaseGraphCanvas.width;
            const H = phaseGraphCanvas.height;
            phaseGraphCtx.beginPath();
            phaseGraphCtx.moveTo(50, H - 30);
            phaseGraphCtx.lineTo(W - 30, H - 30);
            phaseGraphCtx.moveTo(50, 20);
            phaseGraphCtx.lineTo(50, H - 30);
            phaseGraphCtx.strokeStyle = '#000';
            phaseGraphCtx.stroke();
            phaseGraphCtx.fillStyle = '#000';
            phaseGraphCtx.font = '10px Arial';
            phaseGraphCtx.textAlign = 'center';
            phaseGraphCtx.textBaseline = 'top';
            const thetaLabels = [thetaMin, 0, thetaMax];
            const xPositions = [50, 50 + (W - 80) / 2, W - 30];
            thetaLabels.forEach((val, idx) => {
                phaseGraphCtx.fillText(val.toFixed(2), xPositions[idx], H - 25);
            });
            phaseGraphCtx.textAlign = 'right';
            phaseGraphCtx.textBaseline = 'middle';
            const omegaLabels = [omegaMin, 0, omegaMax];
            const yPositions = [H - 30, (20 + H - 30) / 2, 20];
            omegaLabels.forEach((val, idx) => {
                phaseGraphCtx.fillText(val.toFixed(2), 45, yPositions[idx]);
            });
            phaseGraphCtx.strokeStyle = '#007bff';
            phaseGraphCtx.lineWidth = 1.5;
            phaseGraphCtx.beginPath();
            let prevTheta = phaseData[0].theta;
            let x = 50 + (phaseData[0].theta - thetaMin) / (thetaMax - thetaMin) * (W - 80);
            let y = H - 30 - (phaseData[0].omega - omegaMin) / (omegaMax - omegaMin) * (H - 50);
            phaseGraphCtx.moveTo(x, y);
            phaseData.forEach((point, idx) => {
                if (idx === 0) return;
                x = 50 + (point.theta - thetaMin) / (thetaMax - thetaMin) * (W - 80);
                y = H - 30 - (point.omega - omegaMin) / (omegaMax - omegaMin) * (H - 50);
                const deltaTheta = point.theta - prevTheta;
                if (Math.abs(deltaTheta) > Math.PI) {
                    phaseGraphCtx.stroke();
                    phaseGraphCtx.beginPath();
                    phaseGraphCtx.moveTo(x, y);
                } else {
                    phaseGraphCtx.lineTo(x, y);
                }
                prevTheta = point.theta;
            });
            phaseGraphCtx.stroke();
            if (phaseData.length > 0) {
                const current = phaseData[phaseData.length - 1];
                const x = 50 + (current.theta - thetaMin) / (thetaMax - thetaMin) * (W - 80);
                const y = H - 30 - (current.omega - omegaMin) / (omegaMax - omegaMin) * (H - 50);
                phaseGraphCtx.beginPath();
                phaseGraphCtx.arc(x, y, 4, 0, Math.PI * 2);
                phaseGraphCtx.fillStyle = '#8B4513';
                phaseGraphCtx.fill();
            }
        }
        function resetSimulation() {
            const inputs = {
                length: document.getElementById('length').value,
                initialAngle: document.getElementById('initialAngle').value,
                initialVelocity: document.getElementById('initialVelocity').value,
                mass: document.getElementById('mass').value,
                damping: document.getElementById('damping').value
            };
            try {
                L = math.evaluate(inputs.length);
                theta0 = math.evaluate(inputs.initialAngle);
                omega0 = math.evaluate(inputs.initialVelocity);
                m = math.evaluate(inputs.mass);
                b = math.evaluate(inputs.damping);
                if (L <= 0 || m <= 0) {
                    throw new Error("Length and mass must be positive.");
                }
                b_over_m = b / (m*L);
                g_over_L = g / L;
                const D = b_over_m ** 2 - 4 * g_over_L;
                useBackwardEuler = D > 0;
                if (useBackwardEuler) {
                    denom = 1 + dt * b_over_m;
                    c1 = dt / denom;
                    c2 = (dt * dt * g_over_L) / denom;
                }
                theta = theta0;
                omega = omega0;
                t = 0;
                graphData.length = 0;
                isSimulationRunning = true;
                drawPendulum();
                drawGraph();
                drawPhaseGraph();
                removeAlert();
            } catch (error) {
                showAlert("Invalid input: " + error.message);
            }
        }
        function showAlert(message) {
            const alertContainer = document.getElementById('alertContainer');
            alertContainer.innerHTML = `
                <div style="background:#f87171;color:white;padding:1rem;border-radius:8px;display:flex;align-items:center;">
                    ${message}
                    <button onclick="removeAlert()" style="margin-left:auto;background:none;border:none;color:white;cursor:pointer;">×</button>
                </div>
            `;
            alertContainer.style.display = 'block';
        }
        function removeAlert() {
            const alertContainer = document.getElementById('alertContainer');
            alertContainer.style.display = 'none';
            alertContainer.innerHTML = '';
        }
        function animate() {
            if (isSimulationRunning) {
                for (let i = 0; i < stepsPerFrame; i++) {
                    updatePhysics();
                }
                drawPendulum();
                drawGraph();
                drawPhaseGraph();
            }
            requestAnimationFrame(animate);
        }
        document.addEventListener('DOMContentLoaded', () => {
            let pivot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            pivot.setAttribute("id", "pivot");
            pivot.setAttribute("cx", "250");
            pivot.setAttribute("cy", "200");
            pivot.setAttribute("r", "9");
            pivot.setAttribute("fill", "#000");
            svg.appendChild(pivot);
            rod = document.createElementNS("http://www.w3.org/2000/svg", "line");
            rod.setAttribute("id", "rod");
            rod.setAttribute("x1", "250");
            rod.setAttribute("y1", "200");
            rod.setAttribute("stroke", "#000");
            rod.setAttribute("stroke-width", "4");
            svg.appendChild(rod);
            bob = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            bob.setAttribute("id", "bob");
            bob.setAttribute("r", "18");
            bob.setAttribute("fill", "#8B4513");
            bob.setAttribute("stroke", "#000");
            svg.appendChild(bob);
            katex.render(
                `\\ddot{\\theta} + \\frac{b}{mL} \\dot{\\theta} + \\frac{g}{L} \\sin(\\theta) = 0, \\quad \\theta(0) = \\theta_0, \\quad \\dot{\\theta}(0) = \\omega_0`,
                document.getElementById('equationGeneral'),
                { throwOnError: false, displayMode: true }
            );
            resetSimulation();
            animate();
        });
    </script>
</body>

</html>
