<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Damped Pendulum Simulator</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        :root {
            --primary: #6c5ce7;
            --secondary: #4a47a3;
            --background: #f8f9fa;
            --surface: #e9ecef;
            --text: #212529;
            --accent: #00b4d8;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 30px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .main-container { 
            max-width: 1400px; 
            width: 100%; 
            margin: 0 auto; 
            padding: 20px; 
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        h1 { text-align: center; margin-bottom: 0.5rem; }
        #equationGeneral {
            text-align: center;
            margin: 1rem 0 2rem 0;
            font-size: 1.6rem;
        }
        .content-wrapper {
            display: grid;
            grid-template-columns: 1fr 1fr 400px;
            gap: 30px;
            align-items: start;
            flex: 1;
        }
        .simulation-column { 
            display: flex; 
            flex-direction: column; 
            gap: 30px; 
        }
        .controls-wrapper {
            background: rgba(255,255,255,0.9);
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 14px;
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.06);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        svg {
            border-radius: 16px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.15);
            border: 2px solid var(--surface);
            background: #E3F2FD;
        }
        #simulationSvg { width: 100%; height: auto; max-height: 70vh; }
        .graph-container {
            background: white;
            border: 1px solid var(--surface);
            border-radius: 16px;
            padding: 1rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.06);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }
        .controls label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.9rem;
            color: var(--secondary);
        }
        .controls input {
            width: 100px;
            padding: 0.4rem;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            font-size: 0.9rem;
        }
        button {
            padding: 0.8rem 1rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 1rem;
        }
        button:hover {
            background: var(--accent);
            transform: translateY(-2px);
        }
        nav {
            margin-bottom: 2rem;
            text-align: center;
        }
        nav a {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary);
            text-decoration: none;
            margin: 0 1.5rem;
        }
        nav a:hover { color: var(--accent); }
        .about-section {
            background: rgba(255,255,255,0.9);
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 14px;
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.06);
            font-size: 0.95rem;
            line-height: 1.6;
        }
        .about-section h2 {
            color: var(--secondary);
            margin-top: 0;
            font-size: 1.2rem;
        }
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px 0;
            color: var(--secondary);
            font-size: 0.9rem;
            border-top: 1px solid var(--surface);
        }
        @media (max-width: 1200px) {
            .content-wrapper { grid-template-columns: 1fr 1fr; }
            .about-section { grid-column: 1 / -1; order: 3; }
        }
        @media (max-width: 900px) {
            .content-wrapper { grid-template-columns: 1fr; }
            #simulationSvg { max-height: 50vh; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.0.0/math.min.js"></script>
</head>
<body>
    <div class="main-container">
        <nav>
            <a href="index.html">Home</a>
            <a href="teaching.html">Teaching</a>
            <a href="projects.html">Diff Eq</a>
            <a href="linear.html">Linear Algebra</a>
            <a href="numerical.html">Numerical Methods</a>
        </nav>

        <h1>Damped Pendulum Simulator</h1>
        <div id="equationGeneral"></div>

        <div class="content-wrapper">
            <div class="simulation-column">
                <svg id="simulationSvg" viewBox="0 0 600 600"></svg>

                <div class="graph-container">
                    <h2>Phase Space (ω vs θ)</h2>
                    <canvas id="phaseGraphCanvas" width="500" height="350"></canvas>
                </div>
            </div>

            <div class="controls-wrapper">
                <div style="font-size: 0.9rem; color: var(--secondary);">
                    Inputs can accept expressions like pi/4, 2*pi, etc.
                </div>
                <div class="controls">
                    <div>
                        <label for="length">Length (L) [m]:<input type="text" id="length" value="2"></label>
                        <label for="initialAngle">Initial Angle (θ₀) [rad]:<input type="text" id="initialAngle" value="pi - 0.1"></label>
                        <label for="initialVelocity">Angular Velocity (ω₀) [rad/s]:<input type="text" id="initialVelocity" value="0"></label>
                    </div>
                    <div>
                        <label for="mass">Mass (m) [kg]:<input type="text" id="mass" value="5"></label>
                        <label for="damping">Damping (b) [kg/s]:<input type="text" id="damping" value="0.5"></label>
                        <button onclick="resetSimulation()">Reset Simulation</button>
                    </div>
                </div>

                <div class="graph-container">
                    <h2>Angular Displacement vs Time</h2>
                    <canvas id="graphCanvas" width="400" height="250"></canvas>
                </div>
            </div>

            <div class="about-section">
                <h2>About This Simulation</h2>
                <p>This interactive simulator models a <strong>damped simple pendulum</strong> governed by the nonlinear second-order differential equation:</p>
                <p style="text-align:center; margin:1.5rem 0; font-size:1.1rem;" id="aboutEquation"></p>
                <p>with initial conditions θ(0) = θ₀ and θ'(0) = ω₀.</p>
                <p>Adjust the parameters to explore small-angle approximation, large-amplitude motion, underdamped/overdamped behavior, and phase space trajectories.</p>
                <p><strong>Numerical methods:</strong> RK4 by default; switches to backward Euler for stiff overdamped cases.</p>
            </div>
        </div>

        <footer>
            © 2025 Shelvean Kapita: kapita@tamu.edu<br>
            <a href="https://opensource.org/licenses/MIT">MIT License</a> | Last modified: December 20, 2025
        </footer>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script>
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');
        const phaseGraphCanvas = document.getElementById('phaseGraphCanvas');
        const phaseGraphCtx = phaseGraphCanvas.getContext('2d');
        const svg = document.getElementById('simulationSvg');
        const g = 9.81;
        let L = 2, theta0 = Math.PI - 0.1, omega0 = 0, m = 5, b = 0.5;
        let theta = theta0, omega = omega0, t = 0;
        let dt = 0.025;
        const graphMaxTime = 60;
        let isSimulationRunning = true;
        const graphData = [];
        let useBackwardEuler = false;
        let b_over_m, g_over_L, denom, c1, c2;
        let stepsPerFrame = 4;
        const maxPhasePoints = 4000;

        let rod, bob;

        function toPiRange(theta) {
            let mod = theta % (2 * Math.PI);
            if (mod > Math.PI) mod -= 2 * Math.PI;
            if (mod < -Math.PI) mod += 2 * Math.PI;
            return mod;
        }

        function calculateDerivatives(theta, omega) {
            const alpha = -b_over_m * omega - g_over_L * Math.sin(theta);
            return { theta: omega, omega: alpha };
        }

        function backwardEulerStep(theta, omega, dt) {
            let theta_next = theta;
            const tolerance = 1e-6;
            const maxIterations = 100;
            for (let i = 0; i < maxIterations; i++) {
                const f_val = theta_next - theta - c1 * omega + c2 * Math.sin(theta_next);
                const f_prime_val = 1 + c2 * Math.cos(theta_next);
                if (Math.abs(f_prime_val) < 1e-12) break;
                const delta = f_val / f_prime_val;
                theta_next -= delta;
                if (Math.abs(delta) < tolerance) break;
            }
            const omega_next = (omega - (dt * g_over_L * Math.sin(theta_next))) / denom;
            return { theta: theta_next, omega: omega_next };
        }

        function updatePhysics() {
            if (useBackwardEuler) {
                const nextState = backwardEulerStep(theta, omega, dt);
                theta = nextState.theta;
                omega = nextState.omega;
            } else {
                const k1 = calculateDerivatives(theta, omega);
                const k2 = calculateDerivatives(theta + k1.theta * dt / 2, omega + k1.omega * dt / 2);
                const k3 = calculateDerivatives(theta + k2.theta * dt / 2, omega + k2.omega * dt / 2);
                const k4 = calculateDerivatives(theta + k3.theta * dt, omega + k3.omega * dt);
                theta += (k1.theta + 2*k2.theta + 2*k3.theta + k4.theta) * dt / 6;
                omega += (k1.omega + 2*k2.omega + 2*k3.omega + k4.omega) * dt / 6;
            }
            t += dt;
            graphData.push({ t, theta: toPiRange(theta), omega });
            if (t > graphMaxTime) isSimulationRunning = false;
        }

        function drawPendulum() {
            const pivotX = 300;
            const pivotY = 300;  // Centered vertically
            const scale = 80;    // Reduced scale so max L ≈ 3–3.5 m still allows full 360° swing visibly
            const visualLength = L * scale;
            const bobRadius = 18;

            const bobX = pivotX + visualLength * Math.sin(theta);
            const bobY = pivotY + visualLength * Math.cos(theta);

            rod.setAttribute("x1", pivotX);
            rod.setAttribute("y1", pivotY);
            rod.setAttribute("x2", bobX);
            rod.setAttribute("y2", bobY);

            bob.setAttribute("cx", bobX);
            bob.setAttribute("cy", bobY);
        }

        function drawGraph() {
            graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
            graphCtx.strokeStyle = '#000';
            graphCtx.beginPath();
            graphCtx.moveTo(50, 20);
            graphCtx.lineTo(50, graphCanvas.height - 30);
            graphCtx.lineTo(graphCanvas.width - 20, graphCanvas.height - 30);
            graphCtx.stroke();

            if (graphData.length === 0) return;

            const minTheta = -Math.PI;
            const maxTheta = Math.PI;
            const verticalRange = graphCanvas.height - 50;

            graphCtx.fillStyle = '#000';
            graphCtx.font = '10px Arial';
            graphCtx.textAlign = 'right';
            graphCtx.textBaseline = 'middle';
            for (let i = 0; i <= 5; i++) {
                const thetaVal = minTheta + (i / 5) * (maxTheta - minTheta);
                const y = graphCanvas.height - 30 - (i / 5) * verticalRange;
                graphCtx.fillText(thetaVal.toFixed(2), 45, y);
            }

            graphCtx.textAlign = 'center';
            graphCtx.textBaseline = 'top';
            for (let i = 0; i <= 5; i++) {
                const tVal = (i / 5) * graphMaxTime;
                const x = 50 + (i / 5) * (graphCanvas.width - 70);
                graphCtx.fillText(tVal.toFixed(1), x, graphCanvas.height - 25);
            }

            graphCtx.strokeStyle = '#007bff';
            graphCtx.lineWidth = 2;
            graphCtx.beginPath();
            let prevTheta = graphData[0].theta;
            let x = 50 + (graphData[0].t / graphMaxTime) * (graphCanvas.width - 70);
            let y = graphCanvas.height - 30 - ((graphData[0].theta - minTheta) / (maxTheta - minTheta)) * verticalRange;
            graphCtx.moveTo(x, y);

            graphData.forEach((point, idx) => {
                if (idx === 0) return;
                x = 50 + (point.t / graphMaxTime) * (graphCanvas.width - 70);
                y = graphCanvas.height - 30 - ((point.theta - minTheta) / (maxTheta - minTheta)) * verticalRange;
                if (Math.abs(point.theta - prevTheta) > Math.PI * 0.9) {
                    graphCtx.stroke();
                    graphCtx.beginPath();
                    graphCtx.moveTo(x, y);
                } else {
                    graphCtx.lineTo(x, y);
                }
                prevTheta = point.theta;
            });
            graphCtx.stroke();
        }

        function drawPhaseGraph() {
            phaseGraphCtx.clearRect(0, 0, phaseGraphCanvas.width, phaseGraphCanvas.height);
            if (graphData.length === 0) return;

            const phaseData = graphData.slice(-maxPhasePoints);
            const thetaValues = phaseData.map(d => d.theta);
            const omegaValues = phaseData.map(d => d.omega);
            const minTheta = -Math.PI;
            const maxTheta = Math.PI;
            const minOmega = Math.min(...omegaValues) - 0.2;
            const maxOmega = Math.max(...omegaValues) + 0.2;
            const omegaRange = maxOmega - minOmega || 1;

            const W = phaseGraphCanvas.width;
            const H = phaseGraphCanvas.height;

            phaseGraphCtx.strokeStyle = '#000';
            phaseGraphCtx.beginPath();
            phaseGraphCtx.moveTo(50, H - 30);
            phaseGraphCtx.lineTo(W - 30, H - 30);
            phaseGraphCtx.moveTo(50, 20);
            phaseGraphCtx.lineTo(50, H - 30);
            phaseGraphCtx.stroke();

            phaseGraphCtx.fillStyle = '#000';
            phaseGraphCtx.font = '10px Arial';
            phaseGraphCtx.textAlign = 'center';
            phaseGraphCtx.textBaseline = 'top';
            [-Math.PI, 0, Math.PI].forEach((val, i) => {
                const x = 50 + i * (W - 80)/2;
                phaseGraphCtx.fillText(val.toFixed(2), x, H - 25);
            });

            phaseGraphCtx.textAlign = 'right';
            phaseGraphCtx.textBaseline = 'middle';
            [minOmega, 0, maxOmega].forEach((val, i) => {
                const y = H - 30 - i * (H - 50)/2;
                phaseGraphCtx.fillText(val.toFixed(2), 45, y);
            });

            phaseGraphCtx.strokeStyle = '#007bff';
            phaseGraphCtx.lineWidth = 1.8;
            phaseGraphCtx.beginPath();
            let prevTheta = phaseData[0].theta;
            let x = 50 + (phaseData[0].theta + Math.PI) / (2 * Math.PI) * (W - 80);
            let y = H - 30 - (phaseData[0].omega - minOmega) / omegaRange * (H - 50);
            phaseGraphCtx.moveTo(x, y);

            phaseData.forEach((point, idx) => {
                if (idx === 0) return;
                x = 50 + (point.theta + Math.PI) / (2 * Math.PI) * (W - 80);
                y = H - 30 - (point.omega - minOmega) / omegaRange * (H - 50);
                if (Math.abs(point.theta - prevTheta) > Math.PI * 0.9) {
                    phaseGraphCtx.stroke();
                    phaseGraphCtx.beginPath();
                    phaseGraphCtx.moveTo(x, y);
                } else {
                    phaseGraphCtx.lineTo(x, y);
                }
                prevTheta = point.theta;
            });
            phaseGraphCtx.stroke();

            if (phaseData.length > 0) {
                const current = phaseData[phaseData.length - 1];
                x = 50 + (current.theta + Math.PI) / (2 * Math.PI) * (W - 80);
                y = H - 30 - (current.omega - minOmega) / omegaRange * (H - 50);
                phaseGraphCtx.beginPath();
                phaseGraphCtx.arc(x, y, 6, 0, Math.PI * 2);
                phaseGraphCtx.fillStyle = '#8B4513';
                phaseGraphCtx.fill();
            }
        }

        function resetSimulation() {
            const inputs = {
                length: document.getElementById('length').value,
                initialAngle: document.getElementById('initialAngle').value,
                initialVelocity: document.getElementById('initialVelocity').value,
                mass: document.getElementById('mass').value,
                damping: document.getElementById('damping').value
            };
            try {
                L = math.evaluate(inputs.length);
                theta0 = math.evaluate(inputs.initialAngle);
                omega0 = math.evaluate(inputs.initialVelocity);
                m = math.evaluate(inputs.mass);
                b = math.evaluate(inputs.damping);
                if (L <= 0 || m <= 0) throw new Error("Length and mass must be positive.");

                b_over_m = b / (m * L);
                g_over_L = g / L;
                const D = b_over_m ** 2 - 4 * g_over_L;
                useBackwardEuler = D > 0;
                if (useBackwardEuler) {
                    denom = 1 + dt * b_over_m;
                    c1 = dt / denom;
                    c2 = (dt * dt * g_over_L) / denom;
                }

                theta = theta0;
                omega = omega0;
                t = 0;
                graphData.length = 0;
                isSimulationRunning = true;
                drawPendulum();
                drawGraph();
                drawPhaseGraph();
            } catch (error) {
                alert("Invalid input: " + (error.message || error));
            }
        }

        function animate() {
            if (isSimulationRunning) {
                for (let i = 0; i < stepsPerFrame; i++) {
                    updatePhysics();
                }
                drawPendulum();
                drawGraph();
                drawPhaseGraph();
            }
            requestAnimationFrame(animate);
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Pivot point (small black circle)
            const pivot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            pivot.setAttribute("cx", "300");
            pivot.setAttribute("cy", "300");
            pivot.setAttribute("r", "8");
            pivot.setAttribute("fill", "#000");
            svg.appendChild(pivot);

            // Rod - thin black line
            rod = document.createElementNS("http://www.w3.org/2000/svg", "line");
            rod.setAttribute("x1", "300");
            rod.setAttribute("y1", "300");
            rod.setAttribute("x2", "300");
            rod.setAttribute("y2", "420");
            rod.setAttribute("stroke", "#000");
            rod.setAttribute("stroke-width", "4");
            svg.appendChild(rod);

            // Bob - solid brown circle
            bob = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            bob.setAttribute("cx", "300");
            bob.setAttribute("cy", "420");
            bob.setAttribute("r", "18");
            bob.setAttribute("fill", "#8B4513");
            bob.setAttribute("stroke", "#000");
            bob.setAttribute("stroke-width", "2");
            svg.appendChild(bob);

            katex.render(
                `\\ddot{\\theta} + \\dfrac{b}{m L} \\dot{\\theta} + \\dfrac{g}{L} \\sin(\\theta) = 0`,
                document.getElementById('equationGeneral'),
                { throwOnError: false, displayMode: true }
            );

            katex.render(
                `\\ddot{\\theta} + \\dfrac{b}{m L} \\dot{\\theta} + \\dfrac{g}{L} \\sin(\\theta) = 0`,
                document.getElementById('aboutEquation'),
                { throwOnError: false }
            );

            resetSimulation();
            animate();
        });
    </script>
</body>
</html>

