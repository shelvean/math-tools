<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Finite Difference Generator with Orders of Convergence | Shelvean Kapita</title>
  <meta name="description" content="Compute finite difference coefficients with error terms for numerical differentiation. Free online tool for students and researchers in numerical analysis.">
  <meta name="keywords" content="finite difference, numerical differentiation, coefficients calculator, error terms, numerical methods, mathematics, engineering, Shelvean Kapita">
  <meta name="author" content="Shelvean Kapita">
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- KaTeX for better math rendering -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
  <!-- Load IBM Plex Sans and IBM Plex Serif from Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,400;0,700;1,400;1,700&family=IBM+Plex+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet" />
  <!-- Plotly.js for convergence plots -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js" charset="utf-8"></script>
  <style>
    .math-container {
      overflow-x: auto;
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
    }
    .results-container {
      background-color: #f7f7f7;
      border-radius: 0.5rem;
      padding: 1rem;
      min-height: 150px;
      width: 100%;
    }
    .scroll-area {
      width: 100%;
      overflow-x: auto;
    }
    /* Custom width for results section */
    .results-full-width {
      width: calc(100% - 1rem);
      margin-left: 0.5rem;
      margin-right: 0.5rem;
    }
    body {
      font-family: 'IBM Plex Sans', sans-serif;
      font-size: 16px;
    }
    h1, h2, h3 {
      font-family: 'IBM Plex Serif', serif;
    }
    h2, h3 {
      display: inline-block;
    }
    ul.list-disc {
      display: inline-block;
      text-align: left;
    }
    #content ul {
      font-family: 'IBM Plex Serif', serif;
    }
    #content a {
      font-weight: 600;
      color: #0000EE;
    }
    #content a:hover {
      color: #2563eb;
    }
    .katex-explanation {
      font-size: 0.9rem;
      color: #6b7280;
      margin-top: 0.5rem;
      text-align: center;
    }
    .loading {
      display: none;
      text-align: center;
      padding: 10px;
    }
    .loading-spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 2s linear infinite;
      margin: 0 auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .warning-message {
      background-color: #fef3cd;
      border: 1px solid #ffc107;
      color: #856404;
      padding: 8px 12px;
      border-radius: 4px;
      margin-top: 8px;
      font-size: 0.9rem;
      text-align: center;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }
    .text-center {
      text-align: center;
    }
    .input-container {
      display: flex;
      justify-content: center;
      align-items: center;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }
    #convergence-plot {
      width: 100%;
      height: 400px;
    }
  </style>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LEQE004C92"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LEQE004C92');
</script>
</head>
<body class="bg-gray-50 text-gray-800 antialiased font-sans">
  <div id="preamble" class="status">
    <header class="bg-white shadow-sm py-6 px-4 sticky top-0 z-10">
      <h1 class="text-4xl text-black text-center mb-4 font-bold">
        <a href="index.html">Shelvean Kapita</a>
      </h1>
      <nav>
        <ul class="flex justify-center gap-8">
          <li>
            <a href="index.html" class="text-indigo-500 text-opacity-100 hover:text-blue-600 transition-colors font-bold text-xl">Home</a>
          </li>
          <li>
            <a href="teaching.html" class="text-indigo-500 text-opacity-100 hover:text-blue-600 transition-colors font-bold text-xl">Teaching</a>
          </li>
          <li>
            <a href="projects.html" class="text-indigo-500 text-opacity-100 hover:text-blue-600 transition-colors font-bold text-xl">Diff Eq</a>
          </li>
          <li>
            <a href="linear.html" class="text-indigo-500 text-opacity-100 hover:text-blue-600 transition-colors font-bold text-xl">Linear Algebra</a>
          </li>
          <li>
            <a href="numerical.html" class="text-indigo-500 text-opacity-100 hover:text-blue-600 transition-colors font-bold text-xl">Numerical Methods</a>
          </li>
        </ul>
      </nav>
    </header>
  </div>
  <div class="container mx-auto px-4 py-8 max-w-7xl">
    <header class="text-center mb-12">
      <h1 class="text-4xl font-bold text-indigo-700 mb-2 text-center">Finite Difference Generator with Orders of Convergence</h1>
      <p class="text-gray-600 text-lg text-center">Compute finite difference coefficients with error terms</p>
    </header>

    <!-- About Finite Differences - Collapsible -->
    <div class="bg-blue-50 border border-blue-300 rounded-lg mb-6 overflow-hidden max-w-4xl mx-auto">
      <button onclick="toggleFDConcepts()" class="w-full p-4 text-left flex items-center justify-between hover:bg-blue-100 transition duration-200">
        <h3 class="font-bold text-lg text-blue-800">About Finite Differences & Taylor's Theorem</h3>
        <span id="fdToggleIcon" class="text-blue-800 font-bold text-xl">−</span>
      </button>
      <div id="fdContent" class="px-4 pb-4">
        <p class="text-gray-700 mb-2 text-sm"><strong>Finite differences</strong> approximate derivatives using function values at discrete points. They are fundamental in numerical differentiation and solving differential equations.</p>

        <p class="text-gray-700 mb-2 mt-3"><strong>Taylor's Theorem with Remainder:</strong></p>
        <p class="text-gray-700 mb-2 text-sm">For a smooth function $f(x)$ and point $x_0$, the Taylor expansion is:</p>
        <p class="text-center mb-3" style="font-size: 0.95em;">$ f(x_0 + h) = f(x_0) + hf'(x_0) + \frac{h^2}{2!}f''(x_0) + \frac{h^3}{3!}f'''(x_0) + \cdots + \frac{h^n}{n!}f^{(n)}(x_0) + R_n(h) $</p>
        <p class="text-gray-700 mb-3 text-sm">where the remainder term is $R_n(h) = \frac{h^{n+1}}{(n+1)!}f^{(n+1)}(\xi)$ for some $\xi \in (x_0, x_0 + h)$.</p>

        <p class="text-gray-700 mb-2 mt-3"><strong>Common Finite Difference Formulas:</strong></p>
        <ul class="text-gray-700 text-sm ml-6 list-disc mb-3">
          <li><strong>Forward:</strong> $f'(x) \approx \frac{f(x+h) - f(x)}{h} + O(h)$</li>
          <li><strong>Backward:</strong> $f'(x) \approx \frac{f(x) - f(x-h)}{h} + O(h)$</li>
          <li><strong>Central:</strong> $f'(x) \approx \frac{f(x+h) - f(x-h)}{2h} + O(h^2)$ (higher accuracy!)</li>
          <li><strong>Second derivative:</strong> $f''(x) \approx \frac{f(x+h) - 2f(x) + f(x-h)}{h^2} + O(h^2)$</li>
        </ul>

        <p class="text-gray-700 mb-2 mt-3"><strong>Applications:</strong></p>
        <ul class="text-gray-700 text-sm ml-6 list-disc">
          <li>Numerical solution of differential equations (finite difference methods)</li>
          <li>Computing derivatives from experimental or discrete data</li>
          <li>Image processing and edge detection</li>
          <li>Computational fluid dynamics and heat transfer simulations</li>
        </ul>
      </div>
    </div>

    <main class="bg-white rounded-xl shadow-lg p-6 mb-8">
      <div class="flex flex-col items-center">
        <div class="mb-6 w-full max-w-md">
          <label class="block text-gray-700 mb-2 font-medium text-center" for="points">Stencil Points (e.g., -1, 0, 1)</label>
          <div class="input-container">
            <input type="text" id="points" class="w-full px-4 py-2 border border-gray-300 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-indigo-500" value="-1, 0, 1" placeholder="Enter integer points separated by commas">
            <button id="add-point" class="bg-indigo-100 text-indigo-700 px-4 py-2 rounded-r-lg hover:bg-indigo-200 transition-colors">
              <i class="fas fa-plus"></i>
            </button>
          </div>
          <div class="katex-explanation">Enter integer points relative to x: <span id="katex-examples"></span></div>
          <div id="points-warning" class="warning-message hidden"></div>
        </div>
        <div class="mb-6 w-full max-w-md">
          <label class="block text-gray-700 mb-2 font-medium text-center" for="derivative-order">Derivative Order</label>
          <div class="input-container">
            <input type="number" id="derivative-order" min="1" value="2" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
          </div>
        </div>
        <div class="flex justify-center">
          <button id="calculate" class="bg-indigo-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-indigo-700 transition-colors shadow-md w-auto">Calculate Differences</button>
          <button id="clear" class="bg-gray-500 text-white px-6 py-2 rounded-lg font-semibold hover:bg-gray-600 transition-colors shadow-md w-auto ml-2">Clear</button>
        </div>
      </div>
      <!-- Loading indicator -->
      <div id="loading" class="loading">
        <div class="loading-spinner"></div>
        <p class="mt-2 text-gray-600">Calculating coefficients...</p>
      </div>
      <!-- Results section -->
      <div id="results" class="hidden mt-8 results-full-width text-center">
        <h2 class="text-xl font-semibold text-gray-800 mb-4 text-center">Results</h2>
        <div id="error-message" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4 hidden text-center"></div>
        <div class="results-container">
          <div class="scroll-area">
            <div id="formula" class="math-container"></div>
          </div>
        </div>
      </div>
      <div class="mt-8 text-center">
        <h2 class="text-xl font-semibold text-gray-800 mb-4 text-center">Instructions</h2>
        <div class="bg-blue-50 p-4 rounded-lg border border-blue-200 max-w-md mx-auto">
          <ul class="list-disc pl-5 space-y-2 text-gray-700 text-center">
            <li>Enter integer stencil points relative to \( x \) (e.g., -2, -1, 0, 1, 2)</li>
            <li>Duplicate points are automatically removed</li>
            <li>Need at least \( n+1 \) points for \( n \)-th order derivative</li>
            <li>Results include coefficients and error term</li>
          </ul>
        </div>
      </div>
      <div id="graph-section" class="mt-8 text-center hidden">
        <h2 class="text-xl font-semibold text-gray-800 mb-4 text-center">Convergence Demonstration</h2>
        <div class="bg-white p-4 rounded-lg border border-gray-200 max-w-3xl mx-auto shadow-md">
          <div id="chart-title" class="text-center font-semibold text-lg mb-2"></div>
          <div id="convergence-plot"></div>
          <p id="chart-caption" class="mt-2 text-gray-600 text-center"></p>
        </div>
      </div>
    </main>
  </div>
  <div id="postamble" class="status">
    <footer class="text-center py-6 border-t border-gray-200 text-gray-600 text-sm">
    <p>
        Last modified on <span id="last-modified">2025-October-1</span>. &copy; Shelvean Kapita: kapita@tamu.edu
        <br>
        All code released under the <a href="https://opensource.org/licenses/MIT">MIT License</a>.
    </p>
</footer>
  </div>
  <script>
    function toggleFDConcepts() {
      var content = document.getElementById("fdContent");
      var icon = document.getElementById("fdToggleIcon");
      if (content.style.display === "none") {
        content.style.display = "block";
        icon.textContent = "−";
      } else {
        content.style.display = "none";
        icon.textContent = "+";
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
      const pointsInput = document.getElementById('points');
      const derivativeOrderInput = document.getElementById('derivative-order');
      const calculateButton = document.getElementById('calculate');
      const clearButton = document.getElementById('clear');
      const resultsDiv = document.getElementById('results');
      const formulaDiv = document.getElementById('formula');
      const errorMessageDiv = document.getElementById('error-message');
      const addPointButton = document.getElementById('add-point');
      const katexExamplesDiv = document.getElementById('katex-examples');
      const loadingDiv = document.getElementById('loading');
      const pointsWarningDiv = document.getElementById('points-warning');
      
      // Render KaTeX examples for stencil points
      function renderKatexExamples() {
        const examples = [
          { point: '-1', explanation: 'for \\(f(x-h)\\)' },
          { point: '0', explanation: 'for \\(f(x)\\)' },
          { point: '1', explanation: 'for \\(f(x+h)\\)' },
          { point: '-2', explanation: 'for \\(f(x-2h)\\)' }
        ];
        let html = '';
        examples.forEach((example, index) => {
          html += `<span class="inline-block mx-1">${example.point}</span> ${example.explanation}`;
          if (index < examples.length - 1) {
            html += '<span class="mx-1">|</span>';
          }
        });
        katexExamplesDiv.innerHTML = html;
        // Render the KaTeX
        renderMathInElement(katexExamplesDiv, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
          ],
          throwOnError: false
        });
      }
      
      // Render KaTeX in instructions and description
      const descriptionBoxes = document.querySelectorAll('.bg-blue-50');
      descriptionBoxes.forEach(box => {
        renderMathInElement(box, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
          ],
          throwOnError: false
        });
      });

      // Initialize KaTeX examples
      renderKatexExamples();
      
      // Clear button functionality
      clearButton.addEventListener('click', function() {
        pointsInput.value = '-1, 0, 1';
        derivativeOrderInput.value = '1';
        resultsDiv.classList.add('hidden');
        errorMessageDiv.classList.add('hidden');
        pointsWarningDiv.classList.add('hidden');
        formulaDiv.innerHTML = '';
        document.getElementById('graph-section').classList.add('hidden');
        // Clear the Plotly plot
        const plotDiv = document.getElementById('convergence-plot');
        plotDiv.innerHTML = '';
      });
      
      // Add a new point input field
      addPointButton.addEventListener('click', function() {
        const currentPoints = pointsInput.value;
        if (currentPoints.trim() === '') {
          pointsInput.value = '0';
        } else {
          pointsInput.value = currentPoints + ', 0';
        }
      });
      
      // Validate input for integers only
      pointsInput.addEventListener('input', function() {
        const value = pointsInput.value;
        // Remove any non-digit, non-comma, non-minus characters
        pointsInput.value = value.replace(/[^\d,\-\s]/g, '');
      });
      
      // Calculate coefficients when button is clicked
      calculateButton.addEventListener('click', function() {
        // Clear previous results
        resultsDiv.classList.add('hidden');
        errorMessageDiv.classList.add('hidden');
        pointsWarningDiv.classList.add('hidden');
        formulaDiv.innerHTML = '';
        document.getElementById('graph-section').classList.add('hidden');
        
        // Show loading indicator
        loadingDiv.style.display = 'block';
        
        // Use setTimeout to allow UI to update before computation
        setTimeout(calculateCoefficients, 10);
      });
      
      function calculateCoefficients() {
        // Hide error message
        errorMessageDiv.classList.add('hidden');
        pointsWarningDiv.classList.add('hidden');
        
        try {
          // Parse inputs
          const pointsText = pointsInput.value.trim();
          const derivativeOrder = parseInt(derivativeOrderInput.value);
          
          if (isNaN(derivativeOrder) || derivativeOrder < 1) {
            throw new Error('Derivative order must be a positive integer');
          }
          
          // Parse points and remove duplicates
          const pointStrings = pointsText.split(',').map(s => s.trim()).filter(s => s !== '');
          if (pointStrings.length === 0) {
            throw new Error('Please enter at least one point');
          }
          
          const points = parseAndValidatePoints(pointStrings);
          
          if (points.length < derivativeOrder + 1) {
            throw new Error(`Need at least ${derivativeOrder + 1} distinct points for a ${derivativeOrder}${getOrdinalSuffix(derivativeOrder)} order derivative`);
          }
          
          // Calculate coefficients using stable Vandermonde approach
          const result = computeFiniteDifferenceCoefficients(points, derivativeOrder);
          
          // Display results
          displayResults(result, points, derivativeOrder);
          drawConvergenceGraph(points, derivativeOrder, result.rationalCoefficients, result.errorOrder);
          
          // Show results section
          resultsDiv.classList.remove('hidden');
          
          // Render KaTeX in results
          renderMathInElement(formulaDiv, {
            delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
            ],
            throwOnError: false
          });
        } catch (error) {
          errorMessageDiv.textContent = error.message;
          errorMessageDiv.classList.remove('hidden');
        } finally {
          // Hide loading indicator
          loadingDiv.style.display = 'none';
        }
      }
      
      function parseAndValidatePoints(pointStrings) {
        const points = [];
        const uniquePoints = new Set();
        let hasDuplicates = false;
        let originalCount = pointStrings.length;
        
        for (const pointStr of pointStrings) {
          // Parse as integer
          const point = parseInt(pointStr);
          if (isNaN(point)) {
            throw new Error(`Invalid integer: "${pointStr}"`);
          }
          
          // Check for duplicates
          if (uniquePoints.has(point)) {
            hasDuplicates = true;
            continue; // Skip duplicate
          }
          uniquePoints.add(point);
          points.push(point);
        }
        
        // Show warning if duplicates were removed
        if (hasDuplicates) {
          const removedCount = originalCount - points.length;
          pointsWarningDiv.textContent = `Removed ${removedCount} duplicate point${removedCount > 1 ? 's' : ''}. Using unique points only.`;
          pointsWarningDiv.classList.remove('hidden');
        }
        
        // Sort points for consistent behavior
        points.sort((a, b) => a - b);
        return points;
      }
      
      function getOrdinalSuffix(n) {
        if (n % 10 === 1 && n % 100 !== 11) return 'st';
        if (n % 10 === 2 && n % 100 !== 12) return 'nd';
        if (n % 10 === 3 && n % 100 !== 13) return 'rd';
        return 'th';
      }
      
      // BigInt helpers
      function gcdBig(a, b) {
        a = a < 0n ? -a : a;
        b = b < 0n ? -b : b;
        while (b !== 0n) {
          const t = b;
          b = a % b;
          a = t;
        }
        return a;
      }
      
      function lcmBig(a, b) {
        return (a * b) / gcdBig(a, b);
      }
      
      function lcmArrayBig(arr) {
        let result = arr[0];
        for (let i = 1; i < arr.length; i++) {
          result = lcmBig(result, arr[i]);
        }
        return result;
      }
      
      function factorialBig(n) {
        if (n === 0 || n === 1) return 1n;
        let result = 1n;
        for (let i = 2; i <= n; i++) {
          result *= BigInt(i);
        }
        return result;
      }
      
      class Rational {
        constructor(num, den = 1n) {
          this.num = BigInt(num);
          this.den = BigInt(den);
          this.normalize();
        }
        
        normalize() {
          if (this.den < 0n) {
            this.num = -this.num;
            this.den = -this.den;
          }
          const g = gcdBig(this.num, this.den);
          this.num /= g;
          this.den /= g;
        }
        
        add(other) {
          return new Rational(this.num * other.den + other.num * this.den, this.den * other.den);
        }
        
        sub(other) {
          return new Rational(this.num * other.den - other.num * this.den, this.den * other.den);
        }
        
        mul(other) {
          return new Rational(this.num * other.num, this.den * other.den);
        }
        
        div(other) {
          return new Rational(this.num * other.den, this.den * other.num);
        }
        
        abs() {
          return new Rational(this.num < 0n ? -this.num : this.num, this.den);
        }
        
        compare(other) {
          const diff = this.sub(other);
          if (diff.num > 0n) return 1;
          if (diff.num < 0n) return -1;
          return 0;
        }
        
        isZero() {
          return this.num === 0n;
        }
        
        toString() {
          if (this.den === 1n) return this.num.toString();
          return this.num.toString() + '/' + this.den.toString();
        }
      }
      
      // Using Vandermonde matrix with exact rational arithmetic
      function computeFiniteDifferenceCoefficients(points, derivativeOrder) {
        const n = points.length;
        const pointsBig = points.map(BigInt);
        
        // Create the Vandermonde matrix
        const A = [];
        for (let i = 0; i < n; i++) {
          A[i] = [];
          for (let j = 0; j < n; j++) {
            A[i][j] = new Rational(pointsBig[j] ** BigInt(i));
          }
        }
        
        // Create the right-hand side vector
        const b = Array(n).fill(new Rational(0n));
        b[derivativeOrder] = new Rational(factorialBig(derivativeOrder));
        
        // Solve the linear system A * c = b
        const coefficients = solveLinearSystemRational(A, b);
        
        // Rational coefficients
        const rationalCoefficients = coefficients;
        
        // Find the least common multiple of denominators
        const denominators = rationalCoefficients.map(r => r.den);
        const lcmDenom = lcmArrayBig(denominators);
        
        // Scale to integers
        const integerCoefficients = rationalCoefficients.map(r => r.num * (lcmDenom / r.den));
        
        // Calculate error term
        const errorResult = computeErrorTerm(pointsBig, rationalCoefficients, derivativeOrder);
        
        return {
          coefficients: integerCoefficients,
          denominator: lcmDenom,
          errorOrder: errorResult.errorOrder,
          errorConstant: errorResult.errorConstant,
          errorDerivativeOrder: errorResult.errorDerivativeOrder,
          rationalCoefficients: rationalCoefficients
        };
      }
      
      function solveLinearSystemRational(A, b) {
        const n = A.length;
        const augmented = [];
        for (let i = 0; i < n; i++) {
          augmented[i] = [...A[i], b[i]];
        }
        
        // Gaussian elimination with partial pivoting
        for (let i = 0; i < n; i++) {
          // Partial pivoting
          let maxRow = i;
          for (let j = i + 1; j < n; j++) {
            if (augmented[j][i].abs().compare(augmented[maxRow][i].abs()) > 0) {
              maxRow = j;
            }
          }
          
          // Swap rows
          [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
          
          // Check if pivot is zero
          if (augmented[i][i].isZero()) {
            throw new Error('Matrix is singular or poorly conditioned');
          }
          
          // Make the diagonal element 1
          const pivot = augmented[i][i];
          for (let j = i; j <= n; j++) {
            augmented[i][j] = augmented[i][j].div(pivot);
          }
          
          // Eliminate below and above
          for (let j = 0; j < n; j++) {
            if (j !== i) {
              const factor = augmented[j][i];
              for (let k = i; k <= n; k++) {
                augmented[j][k] = augmented[j][k].sub(factor.mul(augmented[i][k]));
              }
            }
          }
        }
        
        // Extract solution
        const solution = [];
        for (let i = 0; i < n; i++) {
          solution[i] = augmented[i][n];
        }
        return solution;
      }
      
      function computeErrorTerm(pointsBig, coefficients, derivativeOrder) {
        const n = pointsBig.length;
        
        // Find the first non-zero term in the Taylor expansion beyond the derivative order
        let errorOrder = 0;
        let errorConstant = new Rational(0n);
        let errorDerivativeOrder = 0;
        
        // Dynamically adjust maxSearchOrder based on number of points to ensure error term is found
        const maxSearchOrder = Math.max(derivativeOrder + n + 1, 20);
        
        for (let k = derivativeOrder + 1; k <= maxSearchOrder; k++) {
          let sum = new Rational(0n);
          for (let i = 0; i < n; i++) {
            const pow = new Rational(pointsBig[i] ** BigInt(k));
            sum = sum.add(coefficients[i].mul(pow));
          }
          const fact = new Rational(factorialBig(k));
          const term = sum.div(fact);
          
          if (!term.isZero()) {
            errorOrder = k - derivativeOrder;
            errorConstant = term;
            errorDerivativeOrder = k;
            break;
          }
        }
        
        return { errorOrder, errorConstant, errorDerivativeOrder };
      }
      
      function formatPointExpr(p) {
        if (p === 0) { return 'x'; }
        else if (p === 1) { return 'x+h'; }
        else if (p === -1) { return 'x-h'; }
        else if (p > 0) { return `x+${p}h`; }
        else { return `x-${Math.abs(p)}h`; }
      }
      
      function displayResults(result, points, derivativeOrder) {
        const { coefficients, denominator, errorOrder, errorConstant, errorDerivativeOrder } = result;
        const n = points.length;
        
        // Find overall GCD of all absolute coefficients and the denominator to simplify
        let overallGCD = denominator;
        coefficients.forEach(c => {
          const absC = c < 0n ? -c : c;
          overallGCD = gcdBig(overallGCD, absC);
        });
        
        const simplifiedCoefficients = coefficients.map(c => c / overallGCD);
        const simplifiedDenominator = denominator / overallGCD;
        
        // Display formula
        let formulaHTML = '';
        
        // Build numerator - REVERSED: from highest to lowest points
        let numerator = '';
        let firstTerm = true;
        
        // Create an array of indices sorted by points in descending order
        const indices = Array.from({length: n}, (_, i) => i);
        indices.sort((i, j) => points[j] - points[i]);
        
        for (const i of indices) {
          const coeff = simplifiedCoefficients[i];
          if (coeff !== 0n) {
            const absCoeff = coeff < 0n ? -coeff : coeff;
            const sign = coeff > 0n ? '+' : '-';
            
            // Format the function notation
            let functionNotation;
            if (points[i] === 0) { functionNotation = 'f(x)'; }
            else if (points[i] === 1) { functionNotation = 'f(x+h)'; }
            else if (points[i] === -1) { functionNotation = 'f(x-h)'; }
            else if (points[i] > 0) { functionNotation = `f(x+${points[i]}h)`; }
            else { functionNotation = `f(x-${Math.abs(points[i])}h)`; }
            
            if (firstTerm) {
              numerator += (coeff < 0n ? '-' : '') + (absCoeff !== 1n ? absCoeff.toString() : '') + functionNotation;
              firstTerm = false;
            } else {
              numerator += ` ${sign} ${absCoeff !== 1n ? absCoeff.toString() : ''}${functionNotation}`;
            }
          }
        }
        
        // Build formula
        const derivativeSymbol = derivativeOrder === 1 ? "f'(x)" : derivativeOrder === 2 ? "f''(x)" : `f^{(${derivativeOrder})}(x)`;
        
        // Format denominator - include the proper scaling factor
        let denominatorStr = '';
        const denomStr = simplifiedDenominator === 1n ? '' : simplifiedDenominator.toString();
        if (simplifiedDenominator === 1n) {
          denominatorStr = derivativeOrder === 1 ? 'h' : `h^{${derivativeOrder}}`;
        } else {
          denominatorStr = derivativeOrder === 1 ? `${denomStr}h` : `${denomStr} h^{${derivativeOrder}}`;
        }
        
        formulaHTML += `<p class="text-lg">\\[${derivativeSymbol} = \\frac{${numerator}}{${denominatorStr}}`;
        
        // Add error term
        if (!errorConstant.isZero()) {
          const absErrorConstant = errorConstant.abs();
          const errorConstantStr = formatErrorConstantRational(absErrorConstant);
          const errorDerivativeSymbol = errorDerivativeOrder === 1 ? "f'(\\xi)" : errorDerivativeOrder === 2 ? "f''(\\xi)" : `f^{(${errorDerivativeOrder})}(\\xi)`;
          const errorSign = errorConstant.num > 0n ? '-' : '+';
          
          // Display h without exponent if power is 1
          const hPower = errorOrder === 1 ? 'h' : `h^{${errorOrder}}`;
          formulaHTML += ` ${errorSign} ${errorConstantStr} ${hPower} ${errorDerivativeSymbol}`;
        }
        formulaHTML += `\\]</p>`;
        
        const minPoint = Math.min(...points);
        const maxPoint = Math.max(...points);
        const minExpr = formatPointExpr(minPoint);
        const maxExpr = formatPointExpr(maxPoint);
        formulaHTML += `<p class="text-lg text-center">where \\(\\xi \\in (${minExpr}, ${maxExpr})\\)</p>`;
        
        formulaDiv.innerHTML = formulaHTML;
      }
      
      function formatErrorConstantRational(rat) {
        if (rat.num === 1n && rat.den !== 1n) {
          return `\\frac{1}{${rat.den}}`;
        } else if (rat.den === 1n) {
          return rat.num === 1n ? '' : rat.num.toString();
        } else {
          return `\\frac{${rat.num}}{${rat.den}}`;
        }
      }
      
      function drawConvergenceGraph(points, derivativeOrder, rationalCoefficients, errorOrder) {
        // Show the graph section
        const graphSection = document.getElementById('graph-section');
        graphSection.classList.remove('hidden');
        
        const chartTitleDiv = document.getElementById('chart-title');
        
        // Set chart title with LaTeX
        let k_str;
        if (derivativeOrder === 1) k_str = "'";
        else if (derivativeOrder === 2) k_str = "''";
        else k_str = `^{(${derivativeOrder})}`;
        
        chartTitleDiv.innerHTML = `Convergence for \\(f${k_str}(x)\\) with \\(f(x) = e^x\\)`;
        renderMathInElement(chartTitleDiv, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
          ],
          throwOnError: false
        });
        
        // Test function f(x) = e^x at x=1
        const x0 = 1;
        const f = (t) => Math.exp(t);
        const exactDeriv = Math.exp(x0); // All derivatives of e^x are e^x
        
        // Generate step sizes
        const hs = [0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625];
        const errors = [];
        
        // Calculate errors
        for (let i = 0; i < hs.length; i++) {
          const h = hs[i];
          let sum = 0.0;
          
          for (let j = 0; j < points.length; j++) {
            const p = points[j];
            const rat_c = rationalCoefficients[j];
            const c = Number(rat_c.num) / Number(rat_c.den);
            sum += c * f(x0 + p * h);
          }
          
          const approx = sum / Math.pow(h, derivativeOrder);
          const error = Math.abs(approx - exactDeriv);
          errors.push(error);
        }
        
        // Create reference line
        const refH = hs[2];
        const refError = errors[2];
        const refData = hs.map(h => refError * Math.pow(h / refH, errorOrder));
        
        // Calculate dynamic error range
        const minError = Math.min(...errors);
        const maxError = Math.max(...errors);
        
        // Determine the appropriate y-axis range
        let minExponent, maxExponent;
        
        if (minError <= 1e-15) {
          // If the smallest error is less than 10^-15, cap at 10^-15
          minExponent = -15;
        } else {
          // If the smallest error is larger than 10^-15, go one order below
          minExponent = Math.floor(Math.log10(minError)) - 1;
        }
        
        // Set max exponent to 0 (10^0 = 1) or the next order above max error
        maxExponent = Math.max(0, Math.ceil(Math.log10(maxError)));
        
        // Generate y-axis tick values
        const yTickExponents = [];
        for (let i = minExponent; i <= maxExponent; i++) {
          yTickExponents.push(i);
        }
        
        const yTickVals = yTickExponents.map(e => Math.pow(10, e));
        const yTickText = yTickExponents.map(e => `10<sup>${e}</sup>`);
        
        // Format step sizes with one decimal place in scientific notation
        const formatStepSize = (h) => {
          if (h >= 1) {
            return h.toFixed(1);
          }
          
          const exponent = Math.floor(Math.log10(h));
          const coefficient = h / Math.pow(10, exponent);
          const roundedCoefficient = Math.round(coefficient * 10) / 10;
          
          // Handle cases where rounding might give us 10.0
          const finalCoefficient = roundedCoefficient >= 10 ? 1.0 : roundedCoefficient;
          const finalExponent = roundedCoefficient >= 10 ? exponent + 1 : exponent;
          
          return `${finalCoefficient.toFixed(1)}e${finalExponent}`;
        };
        
        // Create Plotly trace for actual errors
        const actualTrace = {
          x: hs,
          y: errors,
          mode: 'markers',
          type: 'scatter',
          name: 'Actual Error',
          marker: {
            size: 8,
            color: 'rgb(59, 130, 246)'
          }
        };
        
        // Create Plotly trace for expected convergence
        const expectedTrace = {
          x: hs,
          y: refData,
          mode: 'lines',
          type: 'scatter',
          name: `Order O(h<sup>${errorOrder}</sup>)`,
          line: {
            dash: 'dash',
            color: 'rgb(239, 68, 68)',
            width: 2
          }
        };
        
        // Create the layout
        const layout = {
          title: '',
          xaxis: {
            title: 'Step Size',
            type: 'log',
            autorange: 'reversed',
            tickvals: hs,
            ticktext: hs.map(h => formatStepSize(h)),
            showgrid: true,
            showline: true,
            mirror: true
          },
          yaxis: {
            title: 'Absolute Error',
            type: 'log',
            range: [minExponent, maxExponent],
            tickvals: yTickVals,
            ticktext: yTickText,
            showgrid: true,
            showline: true,
            mirror: true
          },
          showlegend: true,
          legend: {
            x: 0.5,
            y: 1,
            xanchor: 'right',
            yanchor: 'top',
            bgcolor: 'rgba(255,255,255,0.8)'
          },
          margin: {
            l: 80,
            r: 40,
            t: 40,
            b: 80
          }
        };
        
        // Plot the data
        Plotly.newPlot('convergence-plot', [actualTrace, expectedTrace], layout, {
          responsive: true,
          displayModeBar: true
        });
        
        // Update caption with LaTeX
        const captionDiv = document.getElementById('chart-caption');
        captionDiv.innerHTML = `Log-log plot of absolute error vs. step size. Dashed line shows expected convergence rate \\(O(h^{${errorOrder}})\\).`;
        renderMathInElement(captionDiv, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
          ],
          throwOnError: false
        });
      }
    });
  </script>
</body>

</html>

